<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>软件设计与体系结构 | 李阳的秘密小屋</title><meta name="keywords" content="软件工程"><meta name="author" content="李阳"><meta name="copyright" content="李阳"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="软件设计与体系结构"><meta name="application-name" content="软件设计与体系结构"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="软件设计与体系结构"><meta property="og:url" content="https://blog.baskly.fun/posts/e2e289e8/index.html"><meta property="og:site_name" content="李阳的秘密小屋"><meta property="og:description" content="软工必备，李师傅呕心沥血版"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://i1.wp.com/dev.ruom.top/i/2025/03/02/339668.webp"><meta property="article:author" content="李阳"><meta property="article:tag" content="bask,李阳"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://i1.wp.com/dev.ruom.top/i/2025/03/02/339668.webp"><meta name="description" content="软工必备，李师傅呕心沥血版"><link rel="shortcut icon" href="/img/flow-32x32.ico"><link rel="canonical" href="https://blog.baskly.fun/posts/e2e289e8/"><link rel="preconnect" href="//cdn.cbd.int"><meta name="google-site-verification" content="xxx"><meta name="baidu-site-verification" content="code-xxx"><meta name="msvalidate.01" content="xxx"><link rel="manifest" href="/manifest.json"><meta name="msapplication-TileColor" content="var(--anzhiyu-main)"><link rel="mask-icon" href="/img/siteicon/yang180.png" color="#5bbad5"><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/yang180.png"><link rel="apple-touch-icon-precomposed" sizes="180x180" href="/img/siteicon/yang180.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/yang32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/yang16.png"><link rel="bookmark" href="/img/siteicon/yang180.png"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-2732.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2732-2048.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2388.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2388-1668.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1536-2048.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-1536.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2224.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2224-1668.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1620-2160.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2160-1620.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1290-2796.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2796-1290.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1179-2556.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2556-1179.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1284-2778.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2778-1284.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1170-2532.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2532-1170.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1125-2436.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2436-1125.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2688.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2688-1242.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-828-1792.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1792-828.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2208.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2208-1242.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-750-1334.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1334-750.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-640-1136.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1136-640.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={linkPageTop:void 0,peoplecanvas:void 0,postHeadAiDescription:{enable:!0,gptName:"Liyang",mode:"local",switchBtn:!1,btnLink:"https://afdian.net/item/886a79d4db6711eda42a52540025c377",randomNum:3,basicWordCount:1e3,key:"xxxx",Referer:"https://xx.xx/"},diytitle:{enable:!0,leaveTitle:"不要走",backTitle:"不要离开我     -"},LA51:void 0,greetingBox:{enable:!0,default:"晚上好👋",list:[{greeting:"晚安😴",startTime:0,endTime:5},{greeting:"早上好鸭👋, 祝你一天好心情！",startTime:6,endTime:9},{greeting:"上午好👋, 状态很好，鼓励一下～",startTime:10,endTime:10},{greeting:"11点多啦, 在坚持一下就吃饭啦～",startTime:11,endTime:11},{greeting:"午安👋, 要睡觉喽",startTime:12,endTime:14},{greeting:"🌈充实的一天辛苦啦！",startTime:14,endTime:18},{greeting:"19点喽, 奖励一顿丰盛的大餐吧🍔。",startTime:19,endTime:19},{greeting:"晚上好👋, 在属于自己的时间好好放松😌~",startTime:20,endTime:24}]},twikooEnvId:"https://twikoo.baskly.fun",commentBarrageConfig:void 0,music_page_default:"nav_music",root:"/",preloader:{source:3},friends_vue_info:void 0,navMusic:!0,mainTone:{mode:"both",api:null,cover_change:!0},authorStatus:{skills:["东隅已逝 桑榆非晚","集中精神 攻克难关"]},algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简",rightMenuMsgToTraditionalChinese:"转为繁体",rightMenuMsgToSimplifiedChinese:"转为简体"},noticeOutdate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:330},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,simplehomepage:!0,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{copy:!0,copyrightEbable:!1,limitCount:50,languages:{author:"作者: 李阳",link:"链接: ",source:"来源: 李阳的秘密小屋",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",copySuccess:"复制成功，复制和转载请标注本文地址"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#425AEF",bgDark:"#1f1f1f",position:"top-center"},source:{justifiedGallery:{js:"https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js",css:"https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1,shortcutKey:void 0,autoDarkmode:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={configTitle:"李阳的秘密小屋",title:"软件设计与体系结构",postAI:"",pageFillDescription:"软件设计与体系结构, 第一章 软件设计模式相关内容介绍, 1.设计模式概述, 1.1产生背景, 1.2软件设计模式概念, 1.3学习软件设计的必要性, 1.4正确使用设计模式具有以下优点。, 1.5设计模式分类, 创建型模式, 结构型模式, 行为型模式, 2.UML, 2.1类图概述, 2.2类图作用, 2.3类图表示法, 2.3.1类图表示方式, 2.3.2类与类之间的表示方式, 2.3.2.1关联联系, 2.3.2.1.1单向关联, 2.3.2.1.2双向关联, 2.3.2.1.3自关联（链表）, 2.3.2.2聚合关系, 2.3.2.3组合关系, 2.3.2.4依赖关系, 2.3.2.5泛化/继承关系, 2.3.2.6实现关系, 3.软件设计原则, 3.1设计模式目的, 3.2七大原则, 3.2.1单一职责 SRP—一个类一个方法, 单一设计原则注意事项和细节, 3.2.2接口隔离原则ISP—最小接口, 3.2.3依赖倒转原则 DIP—依赖接口和抽象, 依赖关系传递的三种方式（看懂即可）, 方式一 接口传递, 方式二 构造方法传递, 方法三 setter传递, 总结, 3.2.4里氏替换原则LSP—继承, oo中的基础性的思考和说明, 基本介绍, 代码案例, 我决定要做一个违背祖宗的决定！, 改写案例, 3.2.5 开闭原则OCP（特别重要）, 案例, 我决定…, 改进, 3.2.6迪米特法则LoD, 基本介绍, 案例, 旧版, 错误原因, 改版, 注意, 3.2.7 合成复用原则 CARP, 基本介绍, 案例引用, 3.3设计原则的核心思想, 4. 23种设计模式, 简介, 分类, 创建型模式, 1.单例模式, 单例模式的八种方式, 1.饿汉式(静态常量), 小测试, 优缺点, 3.懒汉式(线程不安全), 优缺点, 4.懒汉式(线程安全同步方法), 优缺点, 5.懒汉式(线程安全同步代码块), 优缺点, 6.双重检查（推荐）, 优缺点, 7.静态内部类（推荐）, 优缺点, 8.枚举（最完美）, 优缺点, 单例模式的注意事项和细节说明, 2.简单工厂模式, 案例应用, 传统代码, 传统方式优缺点, 改进思路, 简单工厂模式期末考试分完美上岸后序有时间再慢慢更新嘿嘿软件设计与体系结构逆水行舟用力撑一篙松劲退千寻董必武题赠送中学生这里暂时就不更新了等我如果挂科了我在更新第一章软件设计模式相关内容介绍设计模式概述产生背景年软件工程界开始研讨设计模式的话题后来召开了多次关于设计模式的研讨会直到年艾瑞克伽马理查德海尔姆拉尔夫约翰森约翰威利斯迪斯等位作者合作出版了设计模式可复用面向对象软件的基础一书在此书中收录了个设计模式这是设计模式领域里程碑的事件导致了软件设计模式的突破这位作者在软件开发领域里也以他们的四人组著称软件设计模式概念软件设计模式又称设计模式是一套被反复使用多数人知晓的经过分类编目的代码设计经验的总结它描述了在软件设计过程中的一些不断重复发生的问题以及该问题的解决方案也就是说它是解决特定问题的一系列套路是前辈们的代码设计经验的总结具有一定的普遍性可以反复使用学习软件设计的必要性设计模式的本质是面向对象设计原则的实际运用是对类的封装性继承性和多态性以及类的关联关系和组合关系的充分理解正确使用设计模式具有以下优点可以提高程序员的思维能力编程能力和设计能力使程序设计更加标准化代码编制更加工程化使软件开发效率大大提高从而缩短软件的开发周期使设计的代码可重用性高可读性强可靠性高灵活性好可维护性强设计模式分类创建型模式用于描述怎样创建对象它的主要特点是将对象的创建与使用分离四人组书中提供了单例原型工厂方法抽象工厂建造者等种创建型模式结构型模式用于描述如何将类或对象按某种布局组成更大的结构四人组书中提供了代理适配器桥接装饰外观享元组合等种结构型模式行为型模式用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务以及怎样分配职责四人组书中提供了模板方法策略命令职责链状态观察者中介者迭代器访问者备忘录解释器等种行为型模式统一建模语言是用来设计软件的可视化建模语言它的特点是简单统一图形化能表达软件设计中的动态与静态信息从目标系统的不同角度出发定义了用例图类图对象图状态图活动图时序图协作图构件图部署图等种图静态结构图类图对象图包图组件图部署图动态行为图交互图时序图与协作图状态图活动图类图概述类图是显示了模型的静态结构特别是模型中存在的类类的内部结构以及它们与其他类的关系等类图不显示暂时性的信息类图是面向对象建模的主要组成部分类图作用在软件工程中类图是一种静态的结构图描述了系统的类的集合类的属性和类之间的关系可以简化了人们对系统的理解类图是系统分析和设计阶段的重要产物是系统编码和测试的重要模型类图表示法类图表示方式属性方法名称前加的加号和减号表示了这个属性方法的见性类图中表示可见性的符号有三种表示表示表示属性的完整表示方式是可见性名称类型缺省值方法的完整表示方式是可见性名称参数列表返回类型类与类之间的表示方式关联联系关联关系实际上就是类与类之间的联系他是依赖关系的特例关联具有导航性即双向关系或单向姜系关系具有多重性如表示有且仅有一个表示个或者多个表示个或者一个表示到个都可以表示至少个关联关系是对象之间的一种引用关系用于表示一类对象与另一类对象之间的联系如老师和学生师傅和徒弟丈夫和妻子等关联关系是类与类之间最常用的一种关系分为一般关联关系聚合关系和组合关系单向关联在类图中单向关联用一个带箭头的实线表示上图表示每个顾客都有一个地址这通过让类持有一个类型为的成员变量类实现指向的是类型的小德莫李阳我们的里面有但是我们的没有双向关联双方各持有对方类型的成员变量这里一个顾客可购买多个商品一个商品也可以指定被哪个顾客购买在类图中双向关联用一个不带箭头的直线表示上图中在类中维护一个表示一个顾客可以购买多个商品在类中维护一个类型的成员变量表示这个产品被哪个顾客所购买小德莫李阳你中有我我中有你你我如同并蒂莲共沐风雨心相连自关联链表自关联在类图中用一个带有箭头且指向自身的线表示上图的意思就是类包含类型为的成员变量也就是自己包含自己聚合关系聚合关系表示的是整体和部分的关系整体与部分可以分开聚合关系是关联关系的特例所以他具有关联的导航性与多重性如一台电脑由键盘显示器鼠标等组成组成电脑的各个配件是可以从电脑上分离出来的使用带空心菱形的实线来表示如果他们的关系可以分开就是聚合关系不可分开就是组合关系聚合关系是关联关系的一种是强关联关系是整体和部分之间的关系聚合关系也是通过成员对象来实现的其中成员对象是整体对象的一部分但是成员对象可以脱离整体对象而独立存在例如学校与老师的关系学校包含老师但如果学校停办了老师依然存在公司倒闭了但是程序员还可以去其他公司找工作在类图中聚合关系可以用带空心菱形的实线来表示菱形指向整体下图所示是大学和教师的关系图大学是整体老师是部分成员对象是整体对象的一部分但是成员变量可以脱离整体存在这里没有小德莫我懒得写了算辽算辽以防我自己后面看不懂我还是写吧李阳你可不能做一个懒惰的人李阳组合关系组合表示类之间的整体与部分的关系但它是一种更强烈的聚合关系在组合关系中整体对象可以控制部分对象的生命周期一旦整体对象不存在部分对象也将不存在部分对象不能脱离整体对象而存在例如身体和头的关系身体没了头也不存在了皮之不存毛将附焉在类图中组合关系用带实心菱形的实线来表示菱形指向整体下图所示是头和嘴的关系图小德莫李阳当我们创建对象的时候和都会自动对象他们是共生的我泥中有尔尔泥中有我我侬词依赖关系耦合最小的只要是在类中用到了对方那他们就存在依赖关系类中用到了对方如果是类的成员属性如果是方法的返回类型是方法接收的参数类型方法中使用到依赖关系是一种使用关系它是对象之间耦合度最弱的一种关联方式是临时性的关联在代码中某个类的方法通过局部变量方法的参数或者对静态方法的调用来访问另一个类被依赖类中的某些方法来完成一些职责在类图中依赖关系使用带箭头的虚线来表示箭头从使用类指向被依赖的类下图所示是司机和汽车的关系图司机驾驶汽车在一个方法中创建了另外一个对象通过那个对象来调用方法这里的创建了一个类型的形参通过形参调用里面的方法我们来用非常非常简单的代码来演示吧李阳好啦接下来聪明的你猜一猜哪里是有依赖的呢答案是全都有哈哈这几个都有用到哦泛化继承关系耦合最大的泛化关系泛化就是继承继承关系是对象之间耦合度最大的一种关系表示一般与特殊的关系是父类与子类之间的关系工是一种继承关系在类图中泛化关系用带空心三角箭头的实线来表示箭头从子类指向父类在代码实现时使用面向对象的继承机制来实现泛化关系例如类和类都是类的子类其类图如下图所示我们来看一个非常非常简单的小李阳哇这就是继承不过是箭头表示虽然很简单但是不要忘记哦实现关系实际上就是类实现他是依赖关系的特例比如接口被类实现了实现关系是接口与实现类之间的关系在这种关系中类实现了接口类中的操作实现了接口中所声明的所有的抽象操作在类图中实现关系使用带空心三角箭头的虚线来表示箭头从实现类指向接口例如汽车和船实现了交通工具实现了接口小小的德莫李阳很简单吧嘻嘻软件设计原则在软件开发中为了提高软件系统的可维护性和可复用性增加软件的可扩展性和灵活性程序员要尽量根据条原则采开发程序从而提高软件开发效率节约软件开发成本和维护成本设计模式目的编写软件过程中程序员面临着来耦合性内聚性以及可维护性可扩展性重用性灵活性等多方面的挑战设计模式是为了让程序软件具有更好代码重用性即相同功能的代码不用多次编写可读性可扩展性可靠性使程序呈现高内聚低耦合的特性七大原则单一职责原则接口隔离原则依赖倒转原则里氏替换原则开闭原则迪米特法则最少知道原则合成复用原则单一职责一个类一个方法一个类一个方法对类来说的即一个类应该只负责一项职责如类负责两个不同职责职责职责当职责需求变更而改变时可能造成职责执行错误所以需要将类的粒度分解为摩托车汽车飞机在公路上运行在这个方法中违反了单一设计原则这个类既要负责公路上的车辆还要负责天上飞的飞机我们可以根据交通工具运行的方法不同分解为不同的类即可解决办法摩托车汽车飞机在公路上运行在天上上运行在水里上运行遵守了单一原则但是这样做改动太大了即要将代码修改还需要修改客户端改进摩托车汽车飞机在公路上运行在天上上运行在水里上运行这里虽然没有在类上遵循单一设计原则但是在方法级别上任然是遵守单一设计原则这不就是加方法嘛小小单一设计原则拿下拿下单一设计原则注意事项和细节降低类的复杂度一个类只负责一项职责提高类的可读性可维护性降低变更引起的风险通常情况下我们应当遵守单一职责原则只有逻辑足够简单才可以在代码级违反单一职责原则只有类中方法数量足够少可以在方法级别保持单一职责原则接口隔离原则最小接口最小接口客户端不应该依赖它不需要的接口即一个类对另一个类的依赖应该建立在最小的接口上通过接口会使用到但是他只会使用到的方法但是实现了接口所以他必须要实现接口的所有的功能照成结果方法使用不了导致浪费我瞎编的不过大概可能就是这个意思我们来看代码吧可能会好理解一点一个接口里面个方法实现了接口里的个功能这是方法这是方法这是方法这是方法这是方法也实现了接口的个功能这是的方法这是的方法这是的方法这是的方法这是的方法现在我们的依赖但是只需要个方法使用类通过接口使用了类的方法那劳资的里面的剩下俩方法不就白写了退钱现在我们的依赖但是只需要方法啊你玩我呢那我还写这么多干嘛没错这样我们就很好的解释了为什么需要接口隔离原则你明白了吗这里还有一个小小的疑问我们的和是怎么依赖和的呢这里的可以经行替换为我们的和类通过接依赖类类通过接口依赖类如果接口对于类和类来说不是最小接口那么类和类必须去实现他们不需要的方法按隔离原则应当这样处理将接口拆分为独立的几个接口类和类分别衔他们需要的接口建立依赖关系也就是采用接口隔离原则所以这些接口要以最小接口原则经行拆分现在我们要经行改进变得爸爸妈妈都不认识你将接口拆分为独立的几个接口类和类分别与他们需要的接口建立依赖关系也就是采用接口隔离原则接口中出现的方法根据实际情况拆分为三个接口代码实现这就是接口隔离感觉代码量变好高我们来看看代码首先是个接口和两个实现类这是方法这是方法这是方法这是的方法这是的方法这是的方法和两个依赖类使用类通过接口使用了类的方法嘿嘿嘿嘿嘿这样我们就避免了资源浪费不过感觉程序会很庞大测试类类通过接口依赖类安全下车咕噜拜依赖倒转原则依赖接口和抽象依赖接口和抽象高层模块不应该依赖低层模块二者都应该依赖其抽象抽象不应该依赖细节细节应该依颗抽象依赖倒转倒置的中心思想是面向接口编程依赖倒转原则是基于这样的设计理念相对于细节的多变性抽象的东西要稳定的多以抽象为基础搭建的架构比以细节为基础的架构要稳定的多在中抽象指的是接口或抽象类细节就是具体的实现类使用接口或抽象类的目的是制定好规范而不涉及任何具体的操作把展现细节的任务交给他们的实现类去完成你有没有一点点蒙反正我先蒙了那么我们一起来看一个小案例吧李阳依赖倒置演示案例电子邮件类电子邮件信息完成接收信息的功能这种比较简单且容易实现但是如果我们需要获取其他途径的信息比如微信等则新增加类也要增加相应的接收方法哎你别说你还真别说好像是感觉不太好那我们一起来看看怎么修改的吧解决思路引用抽象的接口表示接收者这样类与接口发生依赖因为等等都属于接收范围他们各自实现接口就了这样我们就符合了依赖倒转原则了废话不多说我们直接上代码干就完了首先定义一个接口李阳定义接口再来一个李阳电子邮件类电子邮件信息一个人员去实现方法李阳人员类这里面你传给我的是谁我就依赖谁最后再来一个测试类李阳依赖倒置演示案例神奇的事情发生了结果居然和之前是一样的太奇妙了神奇我们在仔细的看一下人员类的方法因为就这个改变最大这里面你传给我的是谁我就依赖谁首先我们创建了一个的对象然后传入了一个的对象然后调用这样如果我们在加一个微信类只需要在主方法里面就可以了好像明白了依赖倒置原则了之前需要在里面重新写实例化方法现在都不需要变更了依赖关系传递的三种方式看懂即可这里微微有点绕我又迷糊了接口传递构造方法传递传递方式一接口传递李阳方式通过接口实现依赖海尔电视就是吊看不懂看不懂完全看不懂这种耦合度还是有点高的下面两种方式更好哦哦我看明白了先别着急放弃我给你慢慢讲首先呢我们创建了两个接口一个电视接口一个关闭某个电视的接口关键字某个我们要关闭哪个电视就往里面传入哪个接口就可以了然后呢我们定义了一个海尔电视去实现这个接口重点来啦类去实现上面的接口当我们创建这个对象的时候我们只需要往里面传入我们的接口类型的我们就能调用哪个方法是一个接口所以我们传入的是接口然后我们实例化重点是后面的这里我们实例化之后里面有一个方法方法里面是一个接口类型因为我们传入的是所以我们会调用里面的方法我懵懵懂懂不知道什么是爱也不知道该该如何表达不过大概是这个意思不太明白的可以补一下面向对象的知识相信会有更大收获方式二构造方法传递李阳方式二构造方法传递长虹电视不太吊我又来啦我们一起来看下这段代码吧别放弃别放弃别放弃求求你了首先还是两个接口先不要看方法然后呢我们的实现了那么我们是不是要实现接口里面的方法定义了一个接口类型变量然后传入一个带参数的构造器将我们传入的变量给了这个临时变量然后定义一个方法通过临时变量来获取这个方法很巧妙但是我写不出来然后下面的实现接口里面有一个方法最后我们经行调用我们的是一个带参数的构造器然后这个传入的类里面有一个方法这时候我们调用方法就会自动执行也就是相当于调用不过大致是这个意思妙妙妙方法三传递这个比较常用我见过这个代码李阳通过方法经行依赖传递格力电视我没见过我该怎么编给你听不对是讲给你听我看明白了这个就和上面方法二差不多就多了一个设置方法首先接口的定义表示开启某个设备如电视这个方法用于依赖注入将一个实现了接口的对象即电视传递给当前类接口就不重复了类实现了接口它有一个字段类型是用于存储一个具体的电视实例方法是一个方法通过它可以将一个实现了接口的对象例如类的实例注入到类中方法调用了启动电视播放内容主程序逻辑使用方法将对象电视注入到类中也就是说类现在持有了类的引用最后调用它会调用的方法输出格力电视我没见过总结依赖注入类通过方法依赖注入了一个类型的对象这里是实现了类之间的松耦合这使得类不需要关心具体的电视类型只要是实现了接口的类它都能正常工作接口的作用和接口分别定义了开关操作和电视播放的行为通过接口程序的各个部分可以独立开发和扩展比如你可以轻松添加新的电视品牌例如只需要让新的品牌类实现接口而不需要修改类总结低层模块尽量都要有抽象类或接口或者两者都有程序稳定性更好变量的声明类型尽量是抽象类或接口这样我们的变量引用和实际对象间就存在一个缓冲层利于程序扩展和优化继承时遵循里氏替换原则有点类似需要第三方的感觉比如说我是小学生我喜欢玩王者荣耀但是我每天只能玩一个小时的游戏我想上最强王者那么我可以联系代练让代练去操控我的号解决防沉迷顺便帮我上最强王者比我自己玩要好的多我损失了钱大量类但是我成功上了王者方便了功能操作总体来说利大于弊因此需要一个缓冲里氏替换原则继承继承中的基础性的思考和说明继承包含这样一层含义父类中凡是已经实现好的方法实际上是在设定规范和契约虽然它不强制要求所有的子类必须遵循这些契约但是如果子类对这些已经实现的方法任意修改就会对整个继承体系造成破坏继承在给程序设计带来便利的同时也带来了弊端比如使用继承会给程序带来侵入性程序的可移植性降低增加对象间的耦合性如果一个类被其他的类所继承则当这个类需要修改时必须考虑到所有的子类并且父类修改后所有涉及到子类的功能都有可能产生故障问题提出在编程中如何正确的使用继承里氏替换原则基本介绍里氏替换原则在年由麻省理工学院的以为姓里的女士提出的如果对每个类型为的对象都有类型为的对象使得以定义的所有程序在所有的对象都代换成时程序的行为没有发生变化那么类型是类型的子类型换句话说所有引用基类的地方必须能透明地使用其子类的对象在使用继承时遵循里氏替换原则在子类中尽量不要重写父类的方法迫不得已也不可以那你可以用聚合组合依赖来解决问题里氏替换原则告诉我们继承实际上让两个类耦合性增强了在适当的情况下可以通过聚合组合依赖来解决问题突突突说一堆不过说白了就是子类替换父类对之前的父类的地方没有影响子类可以扩展父类功能但不能改变父类原有功能代码案例这里例子不太好建议参考一下正方形不是长方形以及鸵鸟不是鸟等案例我决定要做一个违背祖宗的决定李阳返回两个数的差完成两个数相加然后和求和这里重写了父类方法这里因为重写了父类的方法所以结果会不一样子类重写了父类但是造成了影响重写违反了里氏替换原则所以到底是故意的还是不小心的我们发现原来运行正常的相减功能发生了错误原因就是类无意中重写了父类的方法造成原有功能出现错误在实际编程中我们常常会通过重写父类的方法完成新的功能这样写起来虽然简单但整个继承体系的复用性会比较差特别是运行多态比较频繁的时候通用的做法是原来的父类和子类都继承一个更通俗的基类原有的继承关系去掉采用依赖聚合组合等关系代替改写案例李阳使用组合任然可以使用到类相关方法创建一个更加基础的基类把更基础的方法和成员写到里面返回两个数的差完成两个数相加然后和求和如果需要使用类的方法使用组合关系这里我们重写了类的方法这里重写了父类方法开闭原则特别重要不能修改源代码只能进行功能增加开闭原则是编程中最基础最重要的设计原则一个软件实体如类模块和函数应该对扩展开放对修改关闭对提供方扩展开放对使用方修改关闭用抽象构建框架用实现扩展细节当软件需要变化时尽量通过扩展软件实体的行为来实现变化而不是通过修改已有的代码来实现变化编程中遵循其它原则以及使用设计模式的目的就是遵循开闭原则就是比方我们在玩王者荣耀的时候我们可以打开王者荣耀快乐的玩游戏腾讯公司提供商可以对王者荣耀里面的功能扩充但是呢我们玩家使用方不能经行修改比如开挂等等案例我决定李阳这是一个绘图类接收对象然后根据来绘制不同的图形画矩形画圆形类基类优点是比较好理解简单易操作缺点是违反了设计模式的原则即对扩展开放对修改关闭即当我们给类增加新功能的时候尽量不修改代码或者尽可能少修改代码比如我们这时要新增加一个图形种类我们需要做如下修改修改的地方较多比如新加三角形需要创建类然后修改使用方代码添加三角形的功能好像有点道理改动地方确实比较多改进思路把创建类做成抽象类并提供一个抽象的方法让子类去实现即可这样我们有新的图形种类时只需要让新的图形类继承并实现方法即可使用方代码就不需要修满足了开闭原则李阳这是一个绘图类接收对象然后根据来绘制不同的图形类基类一个抽象方法绘制矩形绘制圆形啊他是怎么运行的啊好像有点点头绪了这是抽象的知识定义一个抽象方法然后实现再用一个类传一个方法类型的方法假设我们再新建一个类只需要创建类不需要修改实现类里面的东西妙妙喵迪米特法则米莱迪法则陌生的类不要以局部变量的形式出现在类的内部基本介绍一个对象应该对其他对象保持最少的了解类与类关系越密切耦合度越大迪米特法则又叫最少知道原则即一个类对自己依赖的类知道的越少越好也就是说对于被依赖的类不管多么复杂都尽量将逻辑封装在类的内部对外除了提供的方法不对外泄露任何信息迪米特法则还有个更简单的定义只与直接的朋友通信直接的朋友每个对象都会与其他对象由耦合关系只要两个对象之间有耦合关系我们就说这两个对象之间是朋友关系耦合的方式很多依赖关联组合聚合等其中我们称出现成员变量方法参数方法返回值中的类为直接的朋友而出现在局部变量中的类不是直接的朋友也就是说陌生的类最好不要以局部变量的形式出现在类的内部案例旧版李阳迪米特法则输出学院员工和学院总部学校总部员工学院员工管理学院员工类返回学院所以员工创建个员工学院返回学校总部所以员工学校总部员工获取学院员工分公司学校总部员工总部我有点累了有点不太想说话了不许累哎学吧学吧不学干嘛呢我们来分析一下直接朋友间接朋友吧以为例返回学校总部所以员工学校总部员工获取学院员工分公司学校总部员工总部首先是直接朋友出现在成员变量方法参数方法返回值中的类为直接朋友这里是方法参数也是直接朋友他是方法参数对应循环的他不是成员变量方法参数方法返回值中的类所以是间接朋友违背了迪米特法则以局部变量的形式出现的错误原因比如说你天天用你室友的水卡洗澡在学校总部类中打印学院人数虽然洗干净澡的目的都达到了结果正确输出了不过水卡毕竟是人家的类是学校总部类人情比钱更加难以偿还为了避免这种情况我们要使用自己的水卡在学院类中打印输出我是天才这里我们打印学院人员的代码出现在了管理学校总部人员的类之中了因此需要改进改版前面设计的问题在于中类并不是类的直接朋友分析按照迪米特法则应该避免类中出现这样非直接朋友关系的耦合李阳迪米特法则输出学院员工和学院总部学校总部员工学院员工管理学院员工类返回学院所以员工创建个员工学院获取学院员工分公司返回学校总部所以员工学校总部员工学校总部员工总部卧槽好厉害原来这就是软件设计注意迪米特法则的核心是降低类之间的耦合但是注意由于每个类都减少了不必要的依赖因此迪米特法则只是要求降低类间对象间耦合关系并不是要求完全没有依赖天系合成复用原则基本介绍原则是尽量使用合成聚合的方式而不是继承案例引用我们假设有一个什么呢我想想假设我们村里有一个乒乓球室一个类我想去里面打乒乓球一个类想要实现里面的方法然后我就直接去那里天天打乒乓球最简单的方法就是我们直接继承可是有一天乒乓球馆扩建了类添加了很多类不需要的功能所以耦合性就变高了很多里面建了篮球场羽毛球排球突然间体育馆人变多了很多可我只想要打乒乓球我还是喜欢安静一点的地方那么我们该如何解决呢对啦聪明的你肯定想到了我们前面有讲依赖传递的三种方式这里无论用那种都可以将与的关系分开来设计原则的核心思想找出应用中可能需要变化之处把它们独立出来不要和那些不需要变化的代码混在一起针对接口编程而不是针对实现编程为了交互对象之间的松耦合设计而努力我们的七大设计原则就到这里啦要及时复习哦还是很容易混的加油加油加油你一定可以的种设计模式简介设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验模式不是代码而是某类问题的通用解决方案设计模式代表了最佳的实践这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的设计模式的本质提高软件的维护性通用性和扩展性并降低软件的复杂分类创建型模式单例摸式抽象工厂模式原型模式建造者模式工厂模式结构型模式适配器模式桥接模式装饰模式组合模式外观模式享元模式代理模式行为型模式模版方法模式命令模式访问者模式迭代器模式观察者模式中介者模式备忘录模式解释器模式模式状态模式策略模式职责链模式责任链模式反正我是先爆炸了创建型模式单例模式所谓类的单例设计模式就是采取一定的方法保证在整个的软件系统中对某个类只能存在一个对象实例并且该类只提供一个取得其对象实例的方法单例模式的八种方式饿汉式静态常量饿汉式静态代码块懒汉式线程不安全懒汉式线程安全同步方法懒汉式线程安全同步代码块双重检查静态内部类枚举太多了不学了饿汉式静态常量构造器私有化防止通过创建实例类的内部创建对象向外暴露一个静态的公共方法返回实例代码实现小测试李阳饿汉式静态常量这两个实例是同一个实例静态变量饿汉式构造器私有化外部不能本类内部创建实例对象提供一个公有的静态方法返回实例对象嗨嗨嗨准备好要听李师傅瞎编了没呢我们来一起解释一下代码吧首先我们先来看类这里将构造器私有化也就是我们不能在外部写然后呢我们在本类中创建一个实例私有不可更改且唯一的实例化欸我们现在将这个实例给私有了那别人怎么用呢我们再给他一个静态方法让外部只能调用这个方法才能有返回同时呢我们的单例模式的宗旨就是一个类只能存在一个对象实例所以我们要使用静态来修饰优缺点优缺点说明优点这种写法比较简单就是在类装载的时候就完成实例化避免了线程同步问题缺点在类装载的时候就完成实例化没有达到满加载的效果如果从始至终从未使用过这个实例则会造成内存的浪费这种方式基于类装载机制避免了多线程的同步问题不过在类装载时就实例化在单例模式中大多数都是调用方法但是导致类装载的原因有很多种因此不能确定有其他的方式或者其他的静态方法导致类装载这时候初始化就没有达到的效果结论这种单例模式可用可能造成内存浪费饿汉式静态代码块我们来看代码吧李阳饿汉式静态代码块检查两个实例是否相等结果应为检查两个实例的是否相等结果应为构造器私有化外部不能直接本类内部创建单例对象在静态代码块中创建单例对象提供一个公有的静态方法返回实例对象准备好了吗我又要开始瞎编啦还是一样的我们私有化构造器单例类的构造器被私有化意味着外部无法直接通过关键字创建该类的实例这是为了防止在外部代码中实例化多个对象从而违反单例模式的原则是一个类型的变量它用来存储单例对象表示这个变量属于类本身而不是某个实例也就是说类加载时这个变量就会被分配内存空间静态代码块用于在类加载时初始化对象静态代码块在类被加载到中时只执行一次因此这里创建的对象也只会存在一个实例这样就实现了单例模式的特性保证了只有一个实例由于是的所以即使类没有被实例化仍然可以通过类名直接访问什么你还是听不懂听不懂就对了这是写的不是我说的我也还没看懂不过这是一个因为我们先创建了一个私有变量会在内存中开辟一段空间这个空间是在类加载中就加载我们传统的是实例化的时候加载所以我们用的还是同一个实例化的对象满足了单例模式那么为什么我们要写成静态代码块的样子呢就很好解释了就是想要在类加载的时候就加载这个对象这种与上面那种其实是一样的只是写法不太一样第二种相对比较动态优缺点这种方式和上面的方式其实类似只不过将类实例化的过程放在了静态代码块中也是在类装载的时候就执行静态代码块中的代码初始化类的实例优缺点和上面是一样的结论这种单例模式可用但是可能造成内存浪费懒汉式线程不安全李阳懒汉式线程不安全本类内部创建单例对象防止提供一个静态的工友方法当使用到该方法时候才去创建即懒汉式如果没有创建则就创建嘿嘿嘿有没有突然明白懒汉与饿汉的区别呢懒汉很懒饿的时候再吃饭饿汉饿怕了先把饭做好还不饿我就已经准备吃饭了优缺点起到了的效果但是只能在单线程下使用如果在多线程下一个线程进入了判断语句块还未来得及往下执行另一个线程也通过了这个判断语句这时便会产生多个实例所以在多线程环境下不可使用这种方式结论在实际开发中不要使用这种方式懒汉式线程安全同步方法李阳懒汉式线程安全同步方法本类内部创建单例对象防止提供一个静态的工友方法加入同步处理方法即懒汉式如果没有创建则就创建优缺点解决了线程不安全问题效率太低了每个线程在想获得类的实例时候执行方法都要进行同步而其实这个方法只执行一次实例化代码就够了后面的想获得该类实例直接就行了方法进行同步效率太低结论在实际开发中不推荐使用这种方式懒汉式线程安全同步代码块优缺点这种方式本意是想对第四种实现方式的改进因为前面同步方法效率太低改为同步产生实例化的的代码块但是这种同步并不能起到线程同步的作用跟第种实现方式遇到的情形一致假如一个线程进入了判断语句块还未来得及往下执行另一个线程也通过了这个判断语句这时便会产生多个实例结论在实际开发中不能使用这种方式双重检查推荐保证一个线程在执行我好累有点不太想说话了凑合着看代码吧李阳双重检查推荐本类内部创建单例对象共享可见性禁止指令重排防止提供一个静态的工友方法加入双重检查代码解决懒加载与线程安全即懒汉式如果没有创建则就创建我们来看一下代码吧首先我们先解释一下两个关键字可以保证方法或者代码块在运行时同一时刻只有一个方法可以进入到临界区同时它还可以保证共享变量的内存可见性中每一个对象都可以作为锁这是实现同步的基础理解为把实例化的对象共享即可假设我们有两个线程进入了第一个语句这时候就只能再门口等着执行第二个语句实例化了对象就退出了进入第二个循环语句被告知不为空了所以就不用执行那一个实例化语句了往后面及时有再多的线程也进不去第二个循环了优缺点概念是多线程开发中常使用到的如代码中所示我们进行了两次检查这样就可以保证线程安全了这样实例化代码只用执行一次后面再次访问时判断直接实例化对象也避免的反复进行方法同步线程安全延迟加载效率较高结论在实际开发中推荐使用这种单例设计模式静态内部类推荐当我们的被装载时我们的静态内部类不会被装载当我们去调用的方法的时候用到了这个静态变量的时候我们的静态静态内会被装载当我们类被装载的时候线程是安全的李阳使用静态内部类完成单例模式本类内部创建单例对象防止写一个静态内部类该类中有个静态属性提供一个静态的工友方法直接返回这代码感觉好有质量我来编一下代码逻辑这个静态内部类他在我们装载的时候并不会马上执行保障了我们的单例和懒加载都是可以满足的当我们调用的时候他会取这个静态内部类里的属性这个时候我们的就可以加载了因为我们的静态内在装载的过程中是线程安全的优缺点这种方式采用了类装载的机制来保证初始化实例时只有一个线程静态内部类方式在类被装载时并不会立即实例化而是在需要实例化时调用方法牙会装载类从而完成的实例化类的静态属性只会在第一次加载类的时候初始化所以在这里帮助我们保证了线程的安全性在类进行初始化时别的线程是无法进入的优点避免了线程不安全利用静态内部类特点实现延迟加载效率高结论推荐使用枚举最完美李阳枚举使用枚举完成单例一个属性保证了单例优缺点这借助中添加的枚举来实现单例模式不仅能避免多线程同步问题而且还能防止反序列化重新创建新的对象这种方式是作者提倡的方式结论推荐使用单例模式的注意事项和细节说明单例模式保证了系统内存中该类只存在一个对象节省了系统资源对于一些需要频繁创建销毁的对象使用单例模式可以提高系绞性能当想实例化一个单例类的时候必须要记住使用相应的获取对象的方法而不是使用单例模式使用的场景需要频繁的进行创建和销毁的对象创建对象时耗时过多或耗费资源过多即重量级对象但又经常用到的对象工具类对象频繁访问数据库或文件的对象比如数据源工厂等又是一年冬至简单工厂模式案例应用第一步建一个抽象方法什么你问我为什么建一个抽象方法抽象方法相当于标准我们很多披萨只要实现这个方法就好了避免大量操作第二步其他披萨去继承这个披萨抽象类就可以了然后再子类中重写就可以啦传统代码没有使用工厂方法的注意超多方法来袭抽象类李阳抽象披萨披萨名字准备原材料不同披萨不一样因此作出抽象类希腊披萨李阳希腊披萨希腊劈杀啥味的没吃过奶酪披萨李阳奶酪披萨准备原材料我没吃过奶酪披萨我喜欢达美乐订购披萨的功能李阳订购披萨因为他会使用到我们前面的方法所以定义构造器订购的类型希腊劈杀耐劳劈杀输出制作构成请输入要订购的劈杀实现类李阳实现类假设我们现在增加一个新品种胡椒披萨呼叫劈杀李阳新增胡椒劈杀给胡椒披萨准备材料需要修改里面的内容希腊劈杀耐劳劈杀呼叫劈杀哎哎哎等等新增功能会修改源代码怎么这么熟悉你能联想到什么原则呢对对对就是那个那个那个那个嘛我知道的开闭原则对啦太聪明啦我就知道你会想起来的传统方式优缺点优点是比较好理解简单易操作缺点是违反了设计模式的原则即对扩展开放对修改关闭即当我们给类增加新功能的时候尽量不修改代码或者尽可能少修改代码比如我们这时要新增加一个的种类披萨我们需要做源代码修改改进思路分析修改代码可以接受但是如果我们在其它的地方也有创建的代码就意味着也需要修改而创建的代码往往有多处思路把创建对象封装到一个类中这样我们有新的种类时只需要修改该类就可其它有创建到对象的代码就不需要修改了简单工厂模式简单工厂模式简单工厂模式是属于创建型模式是工厂模式的一种简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例简单工厂模式是工厂模式家族中最简单实用的模式简单工厂模式定义了一个创建对象的类由这个类来封装实例化对象的行为代码在软件开发中当我们会用到大量的创建某种某类或者某批对象时就会使用到工厂模式我们现在定义了一个工厂类似黑中介代购想买披萨是吧先来找我我帮你去买",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2025-03-02 17:31:44",postMainColor:"#c0e0e0"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:(e,t,a)=>{if(0===a)return;const o={value:t,expiry:Date.now()+864e5*a};localStorage.setItem(e,JSON.stringify(o))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const a=JSON.parse(t);if(!(Date.now()>a.expiry))return a.value;localStorage.removeItem(e)}},e.getScript=(e,t={})=>new Promise(((a,o)=>{const c=document.createElement("script");c.src=e,c.async=!0,c.onerror=o,c.onload=c.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(c.onload=c.onreadystatechange=null,a())},Object.keys(t).forEach((e=>{c.setAttribute(e,t[e])})),document.head.appendChild(c)})),e.getCSS=(e,t=!1)=>new Promise(((a,o)=>{const c=document.createElement("link");c.rel="stylesheet",c.href=e,t&&(c.id=t),c.onerror=o,c.onload=c.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(c.onload=c.onreadystatechange=null,a())},document.head.appendChild(c)})),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#18171d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#f7f9fe")};const t=saveToLocal.get("theme"),a=window.matchMedia("(prefers-color-scheme: dark)").matches,o=window.matchMedia("(prefers-color-scheme: light)").matches,c=window.matchMedia("(prefers-color-scheme: no-preference)").matches,n=!a&&!o&&!c;if(void 0===t){if(o)activateLightMode();else if(a)activateDarkMode();else if(c||n){const e=(new Date).getHours();e<=6||e>=18?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener((e=>{void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())}))}else"light"===t?activateLightMode():activateDarkMode();const d=saveToLocal.get("aside-status");void 0!==d&&("hide"===d?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="https://jsd-proxy.ygxz.in/npm/js-heo@1.0.11/poem/poem.min.css"><link rel="stylesheet" href="https://jsd-proxy.ygxz.in/npm/js-heo@1.0.11/mainColor/heoMainColor.min.css"><link rel="stylesheet" href="https://jsd-proxy.ygxz.in/gh/lyay23/blogstatic@v1.0.0/static/essay-style.min.css"><link rel="stylesheet" href="https://jsd-proxy.ygxz.in/gh/lyay23/blogstatic@v1.0.0/static/todolist.min.css"><link rel="stylesheet" href="https://jsd-proxy.ygxz.in/gh/lyay23/blogstatic@v1.0.1/static/custom-me.min.css"><link rel="stylesheet" href="https://jsd-proxy.ygxz.in/gh/lyay23/blogstatic@v1.0.0/static/imgloaded.min.css"><link rel="stylesheet" href="https://jsd-proxy.ygxz.in/gh/lyay23/blogstatic@v1.0.0/static/twikoo.min.css"><script async defer src="https://umami.baskly.fun/script.js" data-website-id="83445f1f-eab2-4423-b52a-d98fcec8638f"></script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://bu.dusays.com/2025/03/01/67c2609b7c10b.jpg"><div class="loading-image-dot"></div></div></div><script>const preloader={endLoading:()=>{document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",(()=>{preloader.endLoading()})),setTimeout((function(){preloader.endLoading()}),1e4),document.addEventListener("pjax:send",(()=>{preloader.initLoading()})),document.addEventListener("pjax:complete",(()=>{preloader.endLoading()}))</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"><script async src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">李阳的秘密小屋</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size:.9em"></i> <span>隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size:.9em"></i> <span>分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size:.9em"></i> <span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/charts/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tongji1"></use></svg> <span>统计</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=12781955100&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size:.9em"></i> <span>耳机分你一半</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size:.9em"></i> <span>留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/todolist/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zuji"></use></svg> <span>脚步</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/essay/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-taiyang"></use></svg> <span>小太阳</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-a-xiaoyangyang_huaban1"></use></svg> <span>了解我</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i> <span>搜索</span></a></div><input id="center-console" type="checkbox"><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole()"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title">最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/408/" style="font-size:1.05rem">408<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size:1.05rem">C语言<sup>1</sup></a><a href="/tags/java/" style="font-size:1.05rem">java<sup>1</sup></a><a href="/tags/javaweb/" style="font-size:1.05rem">javaweb<sup>9</sup></a><a href="/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/" style="font-size:1.05rem">力扣刷题<sup>1</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size:1.05rem">操作系统<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size:1.05rem">数据结构<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size:1.05rem">计算机组成原理<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size:1.05rem">计算机网络<sup>2</sup></a><a href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" style="font-size:1.05rem">软件工程<sup>1</sup></a></div></div><hr></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多"><i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/09/"><span class="card-archive-list-date">九月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">八月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">三月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li></ul></div><hr></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" itemprop="url">软件工程</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" tabindex="-1" itemprop="url"><span><i class="anzhiyufont anzhiyu-icon-hashtag"></i> 软件工程</span></a></span></div></div><h1 class="post-title" itemprop="name headline">软件设计与体系结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-12-16T04:34:21.000Z" title="发表于 2024-12-16 12:34:21">2024-12-16</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-03-02T09:31:44.788Z" title="更新于 2025-03-02 17:31:44">2025-03-02</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">17.3k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>63分钟</span></span><span class="post-meta-separator"></span><span data-flag-title="软件设计与体系结构"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="twikoo_visitors" title="访问量"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator"></span><span class="post-meta-position" title="作者IP属地为武汉"><i class="anzhiyufont anzhiyu-icon-location-dot"></i> 武汉</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/e2e289e8/#post-comment" tabindex="-1"><span id="twikoo-count"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s58 18 88 18 58-18 88-18 58 18 88 18v44h-352Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://bu.dusays.com/2024/12/09/67566939ebf4b.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://blog.baskly.fun/posts/e2e289e8/"><header><a class="post-meta-categories" href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" itemprop="url">软件工程</a><a href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" tabindex="-1" itemprop="url">软件工程</a><h1 id="CrawlerTitle" itemprop="name headline">软件设计与体系结构</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">李阳</span><time itemprop="dateCreated datePublished" datetime="2024-12-16T04:34:21.000Z" title="发表于 2024-12-16 12:34:21">2024-12-16</time><time itemprop="dateCreated datePublished" datetime="2025-03-02T09:31:44.788Z" title="更新于 2025-03-02 17:31:44">2025-03-02</time></header><blockquote><p>期末考试78分完美上岸！</p><p>后序有时间再慢慢更新嘿嘿</p></blockquote><p>​</p><h1 id="软件设计与体系结构"><a href="#软件设计与体系结构" class="headerlink" title="软件设计与体系结构"></a>软件设计与体系结构</h1><blockquote><p><strong>逆水行舟用力撑，一篙松劲退千寻</strong></p><p>​ ——-董必武《题赠送中学生》</p></blockquote><p>这里暂时就不更新了，等我如果挂科了我在更新！</p><h1 id="第一章-软件设计模式相关内容介绍"><a href="#第一章-软件设计模式相关内容介绍" class="headerlink" title="第一章 软件设计模式相关内容介绍"></a>第一章 软件设计模式相关内容介绍</h1><h2 id="1-设计模式概述"><a href="#1-设计模式概述" class="headerlink" title="1.设计模式概述"></a>1.设计模式概述</h2><h3 id="1-1产生背景"><a href="#1-1产生背景" class="headerlink" title="1.1产生背景"></a>1.1产生背景</h3><p>1990年软件工程界开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。直到1995 年，艾瑞克·伽马(EichGamma).理查德·海尔姆(Richard Helm)、拉尔夫·约翰森(Ralph Johnson)、约翰·威利斯迪斯（John Vlissides)等4位作者合作出版了《设计模式:可复用面向对象软件的基础》一书，在此书中收录了23个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这4位作者在软件开发领域里也以他们的”四人组”(Gang of Four，GoF）著称。</p><h3 id="1-2软件设计模式概念"><a href="#1-2软件设计模式概念" class="headerlink" title="1.2软件设计模式概念"></a>1.2软件设计模式概念</h3><p>软件设计模式(Software Design Pattern)，又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。</p><h3 id="1-3学习软件设计的必要性"><a href="#1-3学习软件设计的必要性" class="headerlink" title="1.3学习软件设计的必要性"></a>1.3学习软件设计的必要性</h3><p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。</p><h4 id="1-4正确使用设计模式具有以下优点。"><a href="#1-4正确使用设计模式具有以下优点。" class="headerlink" title="1.4正确使用设计模式具有以下优点。"></a>1.4<strong>正确使用设计模式具有以下优点。</strong></h4><ul><li>·可以提高程序员的思维能力、编程能力和设计能力。</li><li>·使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。·</li><li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</li></ul><h3 id="1-5设计模式分类"><a href="#1-5设计模式分类" class="headerlink" title="1.5设计模式分类"></a>1.5设计模式分类</h3><ul><li><h4 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a><strong>创建型模式</strong></h4><p>用于描述”怎样创建对象”，它的主要特点是”将对象的创建与使用分离。GoF(四人组)书中提供了<strong>单例、原型、工厂方法、抽象工厂、建造者</strong>等5种创建型模式。</p></li><li><h4 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a><strong>结构型模式</strong></h4><p>用于描述如何将类或对象按某种布局组成更大的结构，GoF(四人组)书中提供了<strong>代理、适配器、桥接、装饰、外观、享元、组合</strong>等7种结构型模式。</p></li><li><h4 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a><strong>行为型模式</strong></h4><p>用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF(四人组)书中提供了<strong>模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等</strong> 11种行为型模式。</p></li></ul><h1 id="2-UML"><a href="#2-UML" class="headerlink" title="2.UML"></a>2.UML</h1><p>统一建模语言(Unified Modeling Language，UML)是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。</p><p>UML从目标系统的不同角度出发，定义了用<strong>例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图</strong>等9种图。</p><ul><li>2)静态结构图类图、对象图、包图、组件图、部署图</li><li>3)动态行为图:交互图（时序图与协作图)、状态图、活动图</li></ul><h2 id="2-1类图概述"><a href="#2-1类图概述" class="headerlink" title="2.1类图概述"></a>2.1类图概述</h2><p>类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。</p><h2 id="2-2类图作用"><a href="#2-2类图作用" class="headerlink" title="2.2类图作用"></a>2.2类图作用</h2><ul><li>·在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解;</li><li>·类图是系统分析和<strong>设计阶段</strong>的重要产物，是系统编码和测试的重要模型。</li></ul><h2 id="2-3类图表示法"><a href="#2-3类图表示法" class="headerlink" title="2.3类图表示法"></a>2.3类图表示法</h2><h3 id="2-3-1类图表示方式"><a href="#2-3-1类图表示方式" class="headerlink" title="2.3.1类图表示方式"></a>2.3.1类图表示方式</h3><p>属性/方法名称前加的加号和减号表示了这个属性/方法的见性，UML类图中表示可见性的符号有三种:。</p><ul><li>+:表示public</li><li>-:表示private。</li><li>#:表示protected</li></ul><p>属性的完整表示方式是:<strong>可见性 名称∶类型 [=缺省值]</strong><br>方法的完整表示方式是:<strong>可见性：名称(参数列表)[ ︰返回类型]</strong></p><h3 id="2-3-2类与类之间的表示方式"><a href="#2-3-2类与类之间的表示方式" class="headerlink" title="2.3.2类与类之间的表示方式"></a>2.3.2类与类之间的表示方式</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678787104b795.png" alt></p><h4 id="2-3-2-1关联联系"><a href="#2-3-2-1关联联系" class="headerlink" title="2.3.2.1关联联系"></a>2.3.2.1关联联系</h4><blockquote><p>关联关系实际上就是<strong>类与类之间的联系</strong>，他是<strong>依赖关系的特例</strong></p><p>关联具有<strong>导航性</strong>:即双向关系或单向姜系<br>关系具有多重性:如“1”(表示有且仅有一个)，“0…”(表示0个或者多个），“0，1”（表示0个或者一个),“n..m”(表示n到m个都可以),，”m.….*””(表示至少m个)。</p></blockquote><p>关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为<strong>一般关联关系、聚合关系和组合关系</strong>。</p><h5 id="2-3-2-1-1单向关联"><a href="#2-3-2-1-1单向关联" class="headerlink" title="2.3.2.1.1单向关联"></a>2.3.2.1.1单向关联</h5><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678786d1aac73.png" alt></p><p>在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让customer类持有一个类型为Address的成员变量类实现。(指向的是Address类型的)</p><p>小德莫😍</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.UML;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/20/11:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> IDCard1 idCard1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IDCard1</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>我们的Person1里面有IDCard1，但是我们的IDCard1没有Person1</p><h5 id="2-3-2-1-2双向关联"><a href="#2-3-2-1-2双向关联" class="headerlink" title="2.3.2.1.2双向关联"></a>2.3.2.1.2双向关联</h5><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678786d2b6162.png" alt></p><p>双方各持有对方类型的成员变量</p><p>（这里一个顾客可购买多个商品，一个商品也可以指定被哪个顾客购买）</p><p>在UML类图中，双向关联用一个不带箭头的直线表示。上图中在customer类中维护一个List\<product>，表示一个顾客可以购买多个商品;在Product类中维护一个customer类型的成员变量表示这个产品被哪个顾客所购买。</product></p><p>小德莫</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.UML;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/20/11:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> IDCard1 idCard1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IDCard1</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Person1 person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你中有我 我中有你</p><p>你我如同并蒂莲，共沐风雨心相连</p><h5 id="2-3-2-1-3自关联（链表）"><a href="#2-3-2-1-3自关联（链表）" class="headerlink" title="2.3.2.1.3自关联（链表）"></a>2.3.2.1.3自关联（链表）</h5><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678786d3a2733.png" alt="image-20241213105854430"></p><p>自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是”自己包含自己”。</p><h4 id="2-3-2-2聚合关系"><a href="#2-3-2-2聚合关系" class="headerlink" title="2.3.2.2聚合关系"></a>2.3.2.2聚合关系</h4><blockquote><p>聚合关系(Aggregation）表示的是整体和部分的关系，整体与部分可以分开。</p><p>聚合关系是关联关系的特例，所以他具有关联的导航性与多重性。</p><p>如:一台电脑由键盘(keyboard)、显示器(monitor)，’鼠标等组成;组成电脑的各个配件是可以从电脑上分离出来的，使用带空心菱形的实线来表示:</p><p>如果他们的关系可以分开就是聚合关系，不可分开就是组合关系</p></blockquote><p>聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。</p><p>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。（公司倒闭了，但是程序员还可以去其他公司找工作）</p><p>在UML类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678786d498e73.png" alt></p><p>大学是整体，老师是部分（成员对象是整体对象的一部分，但是成员变量可以脱离整体存在）</p><p>这里没有小德莫 我懒得写了</p><p>算辽算辽 以防我自己后面看不懂我还是写吧</p><p>李阳！你可不能做一个懒惰的人！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.UML;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/20/11:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Mouse mouse;</span><br><span class="line">    <span class="keyword">private</span> Monitor monitor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMouse</span><span class="params">(Mouse mouse)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mouse = mouse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMonitor</span><span class="params">(Monitor monitor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.monitor = monitor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mouse</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monitor</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787871a8addb.png" alt></p><p>over!</p><h4 id="2-3-2-3组合关系"><a href="#2-3-2-3组合关系" class="headerlink" title="2.3.2.3组合关系"></a>2.3.2.3组合关系</h4><p>组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。</p><p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，身体和头的关系，身体没了，头也不存在了。（皮之不存毛将附焉）</p><p>在UML类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678786d5a0e86.png" alt></p><p>小德莫</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.UML;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/20/11:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Mouse mouse=<span class="keyword">new</span> <span class="title class_">Mouse</span>();</span><br><span class="line">    <span class="keyword">private</span> Monitor monitor=<span class="keyword">new</span> <span class="title class_">Monitor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMouse</span><span class="params">(Mouse mouse)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mouse = mouse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMonitor</span><span class="params">(Monitor monitor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.monitor = monitor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mouse</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monitor</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Computer c=<span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787871b8ecbc.png" alt></p><p>当我们创建computer对象的时候，mouse和monitor都会自动new对象，他们是共生的</p><p>我泥中有尔，尔泥中有我【我侬词】</p><h4 id="2-3-2-4依赖关系"><a href="#2-3-2-4依赖关系" class="headerlink" title="2.3.2.4依赖关系"></a>2.3.2.4依赖关系</h4><p><strong>（耦合最小的）</strong></p><blockquote><p>只要是在类中用到了对方，那他们就存在依赖关系</p><ul><li>1)类中用到了对方</li><li>2)如果是类的成员属性</li><li>3)如果是方法的返回类型</li><li>4)是方法接收的参数类型</li><li>5)方法中使用到</li></ul></blockquote><p>依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类)中的某些方法来完成一些职责。</p><p>在UML类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678786d6a4c4e.png" alt></p><p>在一个方法中创建了另外一个对象，通过那个对象来调用方法</p><p>（这里的Driver创建了一个Car类型的形参，通过形参调用Car里面的方法）</p><p>我们来用非常非常简单的代码来演示吧！( •̀ ω •́ )✧</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.UML;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/20/10:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonServiceBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PerSonDao perSonDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Person person)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> IDCard <span class="title function_">getIDCard</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Department</span> <span class="variable">department</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Department</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PerSonDao</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IDCard</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Department</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>好啦！接下来聪明的你猜一猜哪里是有依赖的呢？</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67878711628a3.png" alt></p><p>答案是全都有哈哈，这几个都有用到哦</p><h4 id="2-3-2-5泛化-继承关系"><a href="#2-3-2-5泛化-继承关系" class="headerlink" title="2.3.2.5泛化/继承关系"></a>2.3.2.5泛化/继承关系</h4><p><strong>（耦合最大的）-泛化关系</strong></p><blockquote><p>泛化就是继承</p></blockquote><p>继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系工是一种继承关系。</p><p>在UML类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student类和Teacher类都是Person类的子类，其类图如下图所示:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678786fb0a164.png" alt></p><p>我们来看一个非常非常简单的小demo</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.UML;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/20/11:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">DaoSupport</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Object o)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Object o)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonServiceBean1</span> <span class="keyword">extends</span> <span class="title class_">DaoSupport</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787ad621ebee.png" alt="image-20241220111928040.png"></p><p>哇，这就是继承，不过是箭头表示，虽然很简单但是不要忘记哦</p><h4 id="2-3-2-6实现关系"><a href="#2-3-2-6实现关系" class="headerlink" title="2.3.2.6实现关系"></a>2.3.2.6实现关系</h4><blockquote><p>实际上就是A类实现B，他是依赖关系的特例（比如接口被类实现了 ）</p></blockquote><p>实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p><p>在UML类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678786fc086cb.png" alt></p><p>实现了接口</p><p>小小的德莫</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.UML;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/20/11:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonServiceBean2</span> <span class="keyword">implements</span> <span class="title class_">PersonService</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787ad9de9ea1.png" alt="image-20241220112759125.png"></p><p>很简单吧嘻嘻</p><h1 id="3-软件设计原则"><a href="#3-软件设计原则" class="headerlink" title="3.软件设计原则"></a>3.软件设计原则</h1><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则采开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p><h2 id="3-1设计模式目的"><a href="#3-1设计模式目的" class="headerlink" title="3.1设计模式目的"></a>3.1设计模式目的</h2><p>编写软件过程中，程序员面临着来(耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的挑战，设计模式是为了让程序(软件)，具有更好</p><p>1)代码重用性(即相同功能的代码不用多次编写)</p><p>2)可读性</p><p>3)可扩展性</p><p>4)可靠性</p><p>5)使程序呈现高内聚，低耦合的特性</p><hr><h2 id="3-2七大原则"><a href="#3-2七大原则" class="headerlink" title="3.2七大原则"></a>3.2<strong>七大原则</strong></h2><p>单一职责原则 SRP</p><p>接口隔离原则 ISP</p><p>依赖倒转原则 DIP</p><p>里氏替换原则 LSP</p><p>开闭原则 OCP</p><p>迪米特法则 （最少知道原则） LoD</p><p>合成复用原则CARP</p><hr><h3 id="3-2-1单一职责-SRP—一个类一个方法"><a href="#3-2-1单一职责-SRP—一个类一个方法" class="headerlink" title="3.2.1单一职责 SRP—一个类一个方法"></a>3.2.1单一职责 SRP—一个类一个方法</h3><p>一个类一个方法</p><p>对类来说的，即一个类应该只负责一项职责。如类A负责两个不同职责:职责1，职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1，A2</p><p>eg：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.class1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">vehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vehicle</span>();</span><br><span class="line">        vehicle.run(<span class="string">&quot;摩托车&quot;</span>);</span><br><span class="line">        vehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        vehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String vehicle)</span>&#123;</span><br><span class="line">        System.out.println(vehicle+<span class="string">&quot;在公路上运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中违反了单一设计原则，这个类既要负责公路上的车辆还要负责天上飞的（飞机）</p><p>我们可以根据交通工具运行的方法不同，分解为不同的类即可</p><hr><p>解决办法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.class1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RoadVehicle</span> <span class="variable">vehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoadVehicle</span>();</span><br><span class="line">        vehicle.run(<span class="string">&quot;摩托车&quot;</span>);</span><br><span class="line">        vehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        <span class="type">AirVehicle</span> <span class="variable">airVehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AirVehicle</span>();</span><br><span class="line">        airVehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoadVehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String vehicle)</span>&#123;</span><br><span class="line">        System.out.println(vehicle+<span class="string">&quot;在公路上运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AirVehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String vehicle)</span>&#123;</span><br><span class="line">        System.out.println(vehicle+<span class="string">&quot;在天上上运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaterVehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String vehicle)</span>&#123;</span><br><span class="line">        System.out.println(vehicle+<span class="string">&quot;在水里上运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遵守了单一原则</p><p>但是这样做改动太大了，即要将代码修改，还需要修改客户端</p><hr><p>改进：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.class1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">vehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vehicle</span>();</span><br><span class="line">        vehicle.run(<span class="string">&quot;摩托车&quot;</span>);</span><br><span class="line">        vehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        vehicle.runAir(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String vehicle)</span>&#123;</span><br><span class="line">        System.out.println(vehicle+<span class="string">&quot;在公路上运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runAir</span><span class="params">(String vehicle)</span>&#123;</span><br><span class="line">        System.out.println(vehicle+<span class="string">&quot;在天上上运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runWater</span><span class="params">(String vehicle)</span>&#123;</span><br><span class="line">        System.out.println(vehicle+<span class="string">&quot;在水里上运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里虽然没有在类上遵循单一设计原则，但是在方法级别上任然是遵守单一设计原则</p><p>（这不就是加方法嘛，小小单一设计原则拿下拿下）</p><h4 id="单一设计原则注意事项和细节"><a href="#单一设计原则注意事项和细节" class="headerlink" title="单一设计原则注意事项和细节"></a>单一设计原则注意事项和细节</h4><ul><li>1)降低类的复杂度，一个类只负责一项职责。</li><li>2)提高类的可读性，可维护性</li><li>3)降低变更引起的风险</li><li>4)通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则;只有类中方法数量足够少，可以在方法级别保持单一职责原则</li></ul><h3 id="3-2-2接口隔离原则ISP—最小接口"><a href="#3-2-2接口隔离原则ISP—最小接口" class="headerlink" title="3.2.2接口隔离原则ISP—最小接口"></a>3.2.2接口隔离原则ISP—最小接口</h3><p>最小接口</p><p>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678787029114d.png" alt></p><p>A通过接口会使用到B，但是他只会使用到123的方法，但是b实现了接口，所以他必须要实现接口的所有的功能，照成结果方法使用不了导致浪费（我瞎编的，不过大概可能就是这个意思）</p><p>我们来看代码吧，可能会好理解一点！</p><hr><p>一个接口里面5个方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.class2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interface1</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">opeartion1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">opeartion2</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">opeartion3</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">opeartion4</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">opeartion5</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>B实现了接口里的5个功能</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.class2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">Interface1</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">opeartion1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;这是B方法1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">opeartion2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;这是B方法2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">opeartion3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;这是B方法3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">opeartion4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;这是B方法4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">opeartion5</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;这是B方法5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>D也实现了接口的5个功能</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.class2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">implements</span> <span class="title class_">Interface1</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">opeartion1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;这是D的方法1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">opeartion2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;这是D的方法2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">opeartion3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;这是D的方法3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">opeartion4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;这是D的方法4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">opeartion5</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;这是D的方法5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在我们的A依赖B但是只需要1 2 3个方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.class2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用A类通过接口Interface1使用了B类123的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend1</span><span class="params">(Interface1 i)</span>&#123;</span><br><span class="line">        i.opeartion1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend2</span><span class="params">(Interface1 i)</span>&#123;</span><br><span class="line">        i.opeartion2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend3</span><span class="params">(Interface1 i)</span>&#123;</span><br><span class="line">        i.opeartion3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那劳资的B里面的剩下俩方法不就白写了，rnm退钱</p><p>现在我们的C依赖D但是只需要14 5方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.class2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend1</span><span class="params">(Interface1 i)</span>&#123;</span><br><span class="line">        i.opeartion1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend4</span><span class="params">(Interface1 i)</span>&#123;</span><br><span class="line">        i.opeartion4();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend5</span><span class="params">(Interface1 i)</span>&#123;</span><br><span class="line">        i.opeartion5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>啊你玩我呢，那我D还写这么多干嘛</p><p>没错，这样我们就很好的解释了为什么需要接口隔离原则，你明白了吗(●’◡’●)</p><p>（这里还有一个小小的疑问，我们的A和C是怎么依赖B和D的呢？Interface1 i 这里的i可以经行替换为我们的B和D）</p><ul><li><p>类A通过接lnterface1依赖类B,类c通过接口Interface1依赖类D，如果接口lnterface1对于类A和类c来说不是最小接口那么类B和类D必须去实现他们不需要的方法。</p></li><li><p>按隔离原则应当这样处理:</p><p>将接口Interface1拆分为独立的几个接口，类A和类c分别衔他们需要的接口建立依赖关系。也就是采用接口隔离原则</p></li></ul><p>所以这些接口要以最小接口原则经行拆分</p><hr><p>现在我们要经行改进，变得爸爸妈妈都不认识你</p><ol><li><p>将接口lnterface1拆分为独立的几个接口，类A和类c分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则</p></li><li><p>接口Interface1中出现的方法，根据实际情况拆分为三个接口</p><p>代码实现</p></li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67878703b3507.png" alt></p><p>这就是接口隔离（感觉代码量变好高）</p><p>我们来看看代码</p><p>首先是3个接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.class2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interface1</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">opeartion1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.class2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interface2</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">opeartion2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">opeartion3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.class2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interface3</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">opeartion4</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">opeartion5</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>B和D两个实现类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.class2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">Interface1</span>,Interface2 &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">opeartion1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;这是B方法1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">opeartion2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;这是B方法2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">opeartion3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;这是B方法3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.class2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">implements</span> <span class="title class_">Interface1</span>,Interface3&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">opeartion1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;这是D的方法1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">opeartion4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;这是D的方法4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">opeartion5</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;这是D的方法5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>A和C两个依赖类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.class2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用A类通过接口Interface1使用了B类123的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend1</span><span class="params">(Interface1 i)</span>&#123;</span><br><span class="line">        i.opeartion1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend2</span><span class="params">(Interface2 i)</span>&#123;</span><br><span class="line">        i.opeartion2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend3</span><span class="params">(Interface2 i)</span>&#123;</span><br><span class="line">        i.opeartion3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.class2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend1</span><span class="params">(Interface1 i)</span>&#123;</span><br><span class="line">        i.opeartion1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend4</span><span class="params">(Interface3 i)</span>&#123;</span><br><span class="line">        i.opeartion4();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend5</span><span class="params">(Interface3 i)</span>&#123;</span><br><span class="line">        i.opeartion5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>嘿嘿嘿嘿嘿… 这样我们就避免了资源浪费，不过感觉程序会很庞大</p><p>测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.class2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a.depend1(<span class="keyword">new</span> <span class="title class_">B</span>());<span class="comment">//a类通过接口依赖B类</span></span><br><span class="line">        a.depend2(<span class="keyword">new</span> <span class="title class_">B</span>());</span><br><span class="line">        a.depend3(<span class="keyword">new</span> <span class="title class_">B</span>());</span><br><span class="line">        <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">        c.depend1(<span class="keyword">new</span> <span class="title class_">D</span>());</span><br><span class="line">        c.depend4(<span class="keyword">new</span> <span class="title class_">D</span>());</span><br><span class="line">        c.depend5(<span class="keyword">new</span> <span class="title class_">D</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787ade12eb89.png" alt="image-20241218090500296.png"></p><p>安全下车 咕噜拜</p><h3 id="3-2-3依赖倒转原则-DIP—依赖接口和抽象"><a href="#3-2-3依赖倒转原则-DIP—依赖接口和抽象" class="headerlink" title="3.2.3依赖倒转原则 DIP—依赖接口和抽象"></a>3.2.3依赖倒转原则 DIP—依赖接口和抽象</h3><p>依赖接口和抽象</p><ul><li><p>1)高层模块不应该依赖低层模块，二者都应该依赖其抽象</p></li><li><p>2)抽象不应该依赖细节，细节应该依颗抽象</p></li><li><p>3)依赖倒转(倒置)的中心思想是面向接口编程</p></li><li><p>4)依赖倒转原则是基于这样的设计理念:相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类</p></li><li><p>5)使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</p></li></ul><p>…你有没有一点点蒙 反正我先蒙了</p><p>那么我们一起来看一个小案例吧(●’◡’●)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.class3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/18/09:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:依赖倒置演示案例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependecyInversion</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.receive(<span class="keyword">new</span> <span class="title class_">Email</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//电子邮件类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Email</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;电子邮件信息：hello liyang&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完成Person接收信息的功能</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(Email email)</span>&#123;</span><br><span class="line">    System.out.println(email.getInfo());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种比较简单且容易实现</p><p>但是如果我们需要获取其他途径的信息，比如微信…等，则新增加类Perons也要增加相应的接收方法</p><p>哎你别说 你还真别说 好像是感觉不太好，那我们一起来看看怎么修改的吧</p><hr><p>解决思路：</p><ol><li>引用抽象的接口IReceive，表示接收者，这样Person类与接口IRceive发生依赖</li><li>因为Email，Weixing等等都属于接收范围，他们各自实现IReceive接口就ok了，这样我们就符合了依赖倒转原则了</li></ol><p>废话不多说我们直接上代码！干就完了</p><p>首先定义一个接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.class3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/18/09:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:定义接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IReceiver</span> &#123;</span><br><span class="line">    String <span class="title function_">getInfo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再来一个Email</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.class3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/18/09:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:电子邮件类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Email</span> <span class="keyword">implements</span> <span class="title class_">IReceiver</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;电子邮件信息:hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一个人员去实现方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.class3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/18/09:50</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:人员类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Persion</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(IReceiver receiver)</span> &#123;</span><br><span class="line">        <span class="comment">//这里面你传给我的是谁我就依赖谁</span></span><br><span class="line">        System.out.println(receiver.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后再来一个测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.class3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/18/09:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:依赖倒置演示案例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependecyInversion</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Persion</span> <span class="variable">persion</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Persion</span>();</span><br><span class="line">       persion.receive(<span class="keyword">new</span> <span class="title class_">Email</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>神奇的事情发生了</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787ae0ecdca4.png" alt="image-20241218095449738.png"></p><p>结果居然和之前是一样的</p><p>太奇妙了神奇</p><p>我们在仔细的看一下人员类的方法，因为就这个改变最大</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(IReceiver receiver)</span> &#123;</span><br><span class="line">        <span class="comment">//这里面你传给我的是谁我就依赖谁</span></span><br><span class="line">                  System.out.println(receiver.getInfo());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先我们创建了一个Person的对象，然后传入了一个Email的对象 然后调用</p><p>这样，如果我们在加一个微信类，只需要在主方法里面new就可以了</p><p>好像明白了依赖倒置原则了，之前需要在Persion里面重新写实例化方法，现在都不需要变更了</p><h4 id="依赖关系传递的三种方式（看懂即可）"><a href="#依赖关系传递的三种方式（看懂即可）" class="headerlink" title="依赖关系传递的三种方式（看懂即可）"></a>依赖关系传递的三种方式（看懂即可）</h4><p>这里微微有点绕（我又迷糊了）</p><ol><li>接口传递</li><li>构造方法传递</li><li>setter传递</li></ol><hr><h5 id="方式一-接口传递"><a href="#方式一-接口传递" class="headerlink" title="方式一 接口传递"></a>方式一 接口传递</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.class3.DemoTest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/18/10:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:方式1，通过接口实现依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HarErTV</span> <span class="variable">harErTV</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HarErTV</span>();</span><br><span class="line">        <span class="type">OpenAndClose</span> <span class="variable">openAndClose</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OpenAndClose</span>();</span><br><span class="line">        openAndClose.open(harErTV);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IOpenAndClose</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(ITV tv)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ITV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HarErTV</span> <span class="keyword">implements</span> <span class="title class_">ITV</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;海尔电视TV就是吊&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenAndClose</span> <span class="keyword">implements</span> <span class="title class_">IOpenAndClose</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(ITV tv)</span> &#123;</span><br><span class="line">        tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看不懂看不懂完全看不懂-这种耦合度还是有点高的，下面两种方式更好</p><p>哦哦我看明白了，先别着急放弃，我给你慢慢讲：</p><ul><li>首先呢我们创建了两个接口一个电视接口ITV，一个关闭某个电视的接口IOpenAndClose（关键字某个）我们要关闭哪个电视就往里面传入哪个接口就可以了，</li><li>然后呢我们定义了一个海尔电视去实现这个接口，</li><li>重点来啦OpenAndClose类去实现上面的IOpenAndClose接口 当我们创建这个对象的时候，我们只需要往里面传入我们的接口类型的，我们就能调用哪个play方法。ITV是一个接口，所以我们传入的是接口</li><li>然后我们实例化HarErTV harErTV = new HarErTV();重点是后面的 OpenAndClose openAndClose = new OpenAndClose();openAndClose.open(harErTV);</li><li>这里我们实例化之后，openAndClose里面有一个open方法，open方法里面是一个接口类型，因为我们传入的是harErTV，所以我们会调用HarErTV里面的play方法</li><li>我懵懵懂懂不知道什么是爱，也不知道该该如何表达，不过大概是这个意思，不太明白的可以补一下面向对象的知识，相信会有更大收获</li></ul><hr><h5 id="方式二-构造方法传递"><a href="#方式二-构造方法传递" class="headerlink" title="方式二 构造方法传递"></a>方式二 构造方法传递</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.class3.DemoTest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/18/10:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:方式二 构造方法传递</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ChangHong</span> <span class="variable">changHong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChangHong</span>();</span><br><span class="line"></span><br><span class="line">        OpenAndClose2 openAndClose2=<span class="keyword">new</span> <span class="title class_">OpenAndClose2</span>(changHong);</span><br><span class="line">        openAndClose2.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IOpenAndClose2</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ITV2</span>&#123;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenAndClose2</span> <span class="keyword">implements</span> <span class="title class_">IOpenAndClose2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ITV2 itv2;</span><br><span class="line">    <span class="keyword">public</span>  <span class="title function_">OpenAndClose2</span><span class="params">(ITV2 itv2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.itv2 = itv2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.itv2.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChangHong</span> <span class="keyword">implements</span> <span class="title class_">ITV2</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;长虹电视不太吊&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我又来啦，我们一起来看下这段代码吧，别放弃别放弃别放弃求求你了！</p><ul><li>首先还是两个接口(先不要看main方法)</li><li>然后呢我们的OpenAndClose2 实现了IOpenAndClose2那么我们是不是要实现接口里面的方法，定义了一个接口类型变量，然后传入一个带参数的构造器，将我们传入的变量给了这个临时变量，然后定义一个方法open通过临时变量来获取这个play方法（很巧妙，但是我写不出来）</li><li>然后下面的changhong实现接口里面有一个play方法</li><li>最后我们经行调用：我们的是一个带参数的构造器，然后这个传入的类里面有一个play方法，这时候我们调用open方法就会自动执行this.itv2.play();也就是相当于调用changhong.play();</li><li>不过大致是这个意思</li></ul><p>妙妙妙🐱🐱</p><hr><h5 id="方法三-setter传递"><a href="#方法三-setter传递" class="headerlink" title="方法三 setter传递"></a>方法三 setter传递</h5><p>这个比较常用 我见过这个代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.class3.DemoTest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/18/11:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Geli</span> <span class="variable">geli</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Geli</span>();</span><br><span class="line">        <span class="comment">//通过setter方法经行依赖传递</span></span><br><span class="line">        <span class="type">OpenAndClose3</span> <span class="variable">openAndClose3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OpenAndClose3</span>();</span><br><span class="line">        openAndClose3.setTv(geli);</span><br><span class="line">        openAndClose3.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IOpenAndClose3</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setTv</span><span class="params">(ITV3 tv)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ITV3</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenAndClose3</span> <span class="keyword">implements</span> <span class="title class_">IOpenAndClose3</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ITV3 tv;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTv</span><span class="params">(ITV3 tv)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Geli</span> <span class="keyword">implements</span> <span class="title class_">ITV3</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;格力电视我没见过&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>enn…我该怎么编给你听，不对是讲给你听</p><p>我看明白了，这个就和上面方法二差不多，就多了一个设置方法</p><ul><li>首先接口的定义IOpenAndClose3 open()：表示开启某个设备（如电视）。setTv(ITV3 tv)：这个方法用于依赖注入，将一个实现了 ITV3 接口的对象（即电视）传递给当前类。接口 ITV3就不重复了</li><li><p>类 OpenAndClose3实现了 IOpenAndClose3 接口它有一个字段 tv，类型是 ITV3，用于存储一个具体的电视实例。setTv(ITV3 tv) 方法是一个 setter 方法，通过它可以将一个实现了 ITV3 接口的对象（例如 Geli 类的实例）注入到 OpenAndClose3 类中。open() 方法调用了 tv.play()，启动电视播放内容。</p></li><li><p>主程序逻辑 ：使用 openAndClose3.setTv(geli) 方法将 Geli 对象（电视）注入到 OpenAndClose3 类中。也就是说，OpenAndClose3 类现在持有了 Geli 类的引用。最后，调用 openAndClose3.open()，它会调用 Geli 的 play() 方法，输出 “格力电视我没见过”。</p></li><li>总结：依赖注入（Dependency Injection）：OpenAndClose3 类通过 setTv() 方法依赖注入了一个 ITV3 类型的对象（这里是 Geli），实现了类之间的松耦合。这使得 OpenAndClose3 类不需要关心具体的电视类型，只要是实现了 ITV3 接口的类，它都能正常工作。<br>接口的作用：IOpenAndClose3 和 ITV3 接口分别定义了开关操作和电视播放的行为。通过接口，程序的各个部分可以独立开发和扩展，比如你可以轻松添加新的电视品牌（例如 Sony），只需要让新的品牌类实现 ITV3 接口，而不需要修改 OpenAndClose3 类。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好.</li><li>变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化</li><li>继承时遵循里氏替换原则</li></ul><p>有点类似需要第三方的感觉，比如说我是小学生我喜欢玩王者荣耀，但是我每天只能玩一个小时的游戏，我想上最强王者，那么我可以联系代练，让代练去操控我的号，解决防沉迷顺便帮我上最强王者比我自己玩要好的多，我损失了钱（大量类）但是我成功上了王者（方便了功能操作）总体来说利大于弊。因此需要一个缓冲</p><hr><h3 id="3-2-4里氏替换原则LSP—继承"><a href="#3-2-4里氏替换原则LSP—继承" class="headerlink" title="3.2.4里氏替换原则LSP—继承"></a>3.2.4里氏替换原则LSP—继承</h3><p>继承</p><h4 id="oo中的基础性的思考和说明"><a href="#oo中的基础性的思考和说明" class="headerlink" title="oo中的基础性的思考和说明"></a>oo中的基础性的思考和说明</h4><ul><li>1)继承包含这样一层含义:父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</li><li>2)继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，<strong>如果一个类被其他的类所继承,则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障</strong></li><li>3)问题提出:在编程中，如何正确的使用继承?=&gt;里氏替换原则</li></ul><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>1)里氏替换原则(Liskov Substitution Principle)在1988年，由麻省理工学院的以为姓里的女士提出的。</li><li>2)如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。</li><li>3)在使用继承时，遵循里氏替换原则，<strong>在子类中尽量不要重写父类的方法</strong>（迫不得已也不可以，那你可以用聚合,组合,依赖来解决问题。）</li><li>4)里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过<strong>聚合,组合,依赖</strong>来解决问题。.</li></ul><p>突突突说一堆，不过说白了就是子类替换父类对之前的父类的地方没有影响，子类可以扩展父类功能但不能改变父类原有功能</p><h4 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h4><p>这里例子不太好—建议参考一下正方形不是长方形，以及鸵鸟不是鸟等案例</p><h5 id="我决定要做一个违背祖宗的决定！"><a href="#我决定要做一个违背祖宗的决定！" class="headerlink" title="我决定要做一个违背祖宗的决定！"></a>我决定要做一个违背祖宗的决定！</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.class4;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/18/14:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Liskov1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;11-3 = &quot;</span>+a.func1(<span class="number">11</span>,<span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;1-8 = &quot;</span>+a.func1(<span class="number">1</span>,<span class="number">8</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;11-3 = &quot;</span>+b.func1(<span class="number">11</span>,<span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;1-8 = &quot;</span>+b.func1(<span class="number">1</span>,<span class="number">8</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;11+3+9 = &quot;</span>+b.func2(<span class="number">11</span>,<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回两个数的差</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1-num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完成两个数相加，然后和9求和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;<span class="comment">//这里重写了父类方法</span></span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func1(a,b)+<span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787ae442d51f.png" alt="image-20241218141144793.png"></p><p>这里因为重写了父类的方法，所以结果会不一样，子类重写了父类，但是造成了影响—-重写违反了里氏替换原则</p><p>所以到底是故意的还是不小心的</p><ul><li><p>1)我们发现原来运行正常的相减功能发生了错误。原因就是类B无意中重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候</p></li><li><p>2)通用的做法是:<strong>原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉,采用依赖，聚合，组合等关系代替</strong>.</p></li></ul><h5 id="改写案例"><a href="#改写案例" class="headerlink" title="改写案例"></a>改写案例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.class4;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/18/14:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Liskov1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;11-3 = &quot;</span>+a.func1(<span class="number">11</span>,<span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;1-8 = &quot;</span>+a.func1(<span class="number">1</span>,<span class="number">8</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;11+3 = &quot;</span>+b.func1(<span class="number">11</span>,<span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;1+8 = &quot;</span>+b.func1(<span class="number">1</span>,<span class="number">8</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;11+3+9 = &quot;</span>+b.func2(<span class="number">11</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用组合任然可以使用到A类相关方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;11-3 = &quot;</span>+b.func3(<span class="number">11</span>,<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个更加基础的基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="comment">//把更基础的方法和成员写到Base里面</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回两个数的差</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1-num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完成两个数相加，然后和9求和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果B需要使用A类的方法，使用组合关系</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里我们重写了A类的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;<span class="comment">//这里重写了父类方法</span></span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func1(a,b)+<span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func3</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.a.func1(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-2-5-开闭原则OCP（特别重要）"><a href="#3-2-5-开闭原则OCP（特别重要）" class="headerlink" title="3.2.5 开闭原则OCP（特别重要）"></a>3.2.5 开闭原则OCP（特别重要）</h3><p>不能修改源代码，只能进行功能增加</p><ul><li><p>1)开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则</p></li><li><p>2)一个软件实体如类，模块和函数应该<strong>对扩展开放，对修改关闭</strong>。(对提供方扩展开放，对使用方修改关闭)用抽象构建框架，用实现扩展细节。</p></li><li><p>3)当软件需要变化时，尽量<strong>通过扩展</strong>软件实体的行为来实现变化，而<strong>不是</strong>通过修改已有的代码来实现变化。</p></li><li><p>4)）编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</p><p>就是比方我们在玩王者荣耀的时候，我们可以打开王者荣耀快乐的玩游戏，腾讯公司(提供商)可以对王者荣耀里面的功能扩充，但是呢我们玩家(使用方)不能经行修改(比如开挂等等)</p></li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><h5 id="我决定…"><a href="#我决定…" class="headerlink" title="我决定…"></a>我决定…</h5><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787ae8a9cf41.png" alt="image-20241218150537200.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.principle.OCP;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/18/15:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GraphicEditor</span> <span class="variable">graphicEditor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GraphicEditor</span>();</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Rectangle</span>());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Circle</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个绘图类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicEditor</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收shape对象，然后根据type，来绘制不同的图形</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shape</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawShape</span><span class="params">(Shape shape)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(shape.m_type==<span class="number">1</span>)</span><br><span class="line">            drawRectangle(shape);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(shape.m_type==<span class="number">2</span>)</span><br><span class="line">                drawCircle(shape);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(Shape r)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;画矩形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(Shape r)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;画圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shape类，基类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="type">int</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    Rectangle()&#123;</span><br><span class="line">        <span class="built_in">super</span>.m_type=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    Circle()&#123;</span><br><span class="line">        <span class="built_in">super</span>.m_type=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1)优点是比较好理解，简单易操作。</li><li>2)缺点是违反了设计模式的ocp原则，即对扩展开放()。对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.</li><li>3)比如我们这时要新增加一个图形种类，我们需要做如下修改，修改的地方较多</li><li>比如新加三角形，需要创建类，然后修改GraphicEditor（使用方）代码添加三角形的功能</li></ul><p>好像有点道理，改动地方确实比较多</p><h5 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h5><p>思路:把创建Shape类做成抽象类，并提供一个抽象的draw方法，让子类去实现即可，这样我们有新的图形种类时，只需要让新的图形类继承Shape，并实现draw方法即可</p><p>使用方代码就不需要修-&gt;满足了开闭原则</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.principle.OCP;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/18/15:40</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GraphicEditor</span> <span class="variable">graphicEditor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GraphicEditor</span>();</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Rectangle</span>());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Circle</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个绘图类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicEditor</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收shape对象，然后根据type，来绘制不同的图形</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shape</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawShape</span><span class="params">(Shape shape)</span> &#123;</span><br><span class="line">        shape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shape类，基类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"> <span class="comment">//一个抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制矩形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>啊他是怎么运行的啊</p><p>好像有点点头绪了，这是抽象的知识</p><p>定义一个抽象方法，然后实现，再用一个类传一个方法类型的方法</p><p>emmm… 假设我们再新建一个类，只需要创建类，不需要修改实现类GraphicEditor里面的东西</p><p>妙妙喵🐱🐱</p><hr><h3 id="3-2-6迪米特法则LoD"><a href="#3-2-6迪米特法则LoD" class="headerlink" title="3.2.6迪米特法则LoD"></a>3.2.6迪米特法则LoD</h3><p>米莱迪法则 (•_•)</p><p>陌生的类不要以局部变量的形式出现在类的内部</p><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>1)一个对象应该对其他对象保持最少的了解</li><li>2)类与类关系越密切，耦合度越大</li><li>3)迪米特法则(Demeter Principle)又叫<strong>最少知道原则</strong>，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外泄露任何信息</li><li>4)迪米特法则还有个更简单的定义:<strong>只与直接的朋友通信</strong></li><li>5)<strong>直接的朋友</strong>:每个对象都会与其他对象由耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</li></ul><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><h5 id="旧版"><a href="#旧版" class="headerlink" title="旧版"></a>旧版</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.principle.LoD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/18/16:20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:迪米特法则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">dmt</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SChoolManner</span> <span class="variable">sChoolManner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SChoolManner</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出学院员工ID，和学院总部id</span></span><br><span class="line">        sChoolManner.printALlEmployee(<span class="keyword">new</span> <span class="title class_">CollegeManner</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校总部员工</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院员工</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeEmployee</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeManner</span>&#123;</span><br><span class="line">    <span class="comment">//返回学院所以员工</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title function_">getCollegeEmployee</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;CollegeEmployee&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;<span class="comment">//创建10个员工，</span></span><br><span class="line">            <span class="type">CollegeEmployee</span> <span class="variable">collegeEmployee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CollegeEmployee</span>();</span><br><span class="line">            collegeEmployee.setId(<span class="string">&quot;学院ID： &quot;</span>+String.valueOf(i));</span><br><span class="line">            list.add(collegeEmployee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SChoolManner</span>&#123;</span><br><span class="line">    <span class="comment">//返回学校总部所以员工</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getCollegeEmployee</span><span class="params">()</span>&#123;</span><br><span class="line">       List&lt;Employee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">           <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">           employee.setId(<span class="string">&quot;学校总部员工： &quot;</span>+String.valueOf(i));</span><br><span class="line">           list.add(employee);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printALlEmployee</span><span class="params">(CollegeManner sub)</span>&#123;</span><br><span class="line">       <span class="comment">//获取学院员工</span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list1=sub.getCollegeEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------分公司--------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee collegeEmployee : list1) &#123;</span><br><span class="line">            System.out.println(collegeEmployee.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//学校总部员工</span></span><br><span class="line">        List&lt;Employee&gt; list2=<span class="built_in">this</span>.getCollegeEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------总部--------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Employee employee : list2) &#123;</span><br><span class="line">            System.out.println(employee.getId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787ae8a9cf41.png" alt="image-20241218150537200.png"></p><p>我有点累了有点不太想说话了</p><p>不许累！！！！！！！！！！！！！</p><p>哎学吧学吧 不学干嘛呢</p><p>我们来分析一下直接朋友间接朋友吧！</p><p>以SchoolManager为例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SChoolManner</span>&#123;</span><br><span class="line">    <span class="comment">//返回学校总部所以员工</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getCollegeEmployee</span><span class="params">()</span>&#123;</span><br><span class="line">       List&lt;Employee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">           <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">           employee.setId(<span class="string">&quot;学校总部员工： &quot;</span>+String.valueOf(i));</span><br><span class="line">           list.add(employee);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printALlEmployee</span><span class="params">(CollegeManner sub)</span>&#123;</span><br><span class="line">       <span class="comment">//获取学院员工</span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list1=sub.getCollegeEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------分公司--------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee collegeEmployee : list1) &#123;</span><br><span class="line">            System.out.println(collegeEmployee.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//学校总部员工</span></span><br><span class="line">        List&lt;Employee&gt; list2=<span class="built_in">this</span>.getCollegeEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------总部--------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Employee employee : list2) &#123;</span><br><span class="line">            System.out.println(employee.getId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>首先Employee是直接朋友（出现在成员变量，方法参数，方法返回值中的类为直接朋友）这里是方法参数</li><li>CollegeManager也是直接朋友，他是方法参数</li><li>CollegeEmployee 对应for循环的，他不是成员变量，方法参数，方法返回值中的类，所以是间接朋友，违背了迪米特法则，以局部变量的形式出现的</li></ul><h6 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h6><p>比如说你天天用你室友的水卡洗澡（在学校总部类中打印学院人数），虽然洗干净澡的目的都达到了（结果正确输出了），不过水卡毕竟是人家的（类是学校总部类），人情比钱更加难以偿还，为了避免这种情况，我们要使用自己的水卡（在学院类中打印输出）我是天才🐱</p><p>这里我们打印学院人员的代码出现在了管理学校总部人员的类之中了，因此需要改进</p><h5 id="改版"><a href="#改版" class="headerlink" title="改版"></a>改版</h5><ul><li>1)前面设计的问题在于SchoolManager中，CollegeEmployee类并不是SchoolManager类的直接朋友(分析)</li><li>2)按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.principle.LoD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/18/16:20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:迪米特法则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">dmt</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SChoolManner</span> <span class="variable">sChoolManner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SChoolManner</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出学院员工ID，和学院总部id</span></span><br><span class="line">        sChoolManner.printALlEmployee(<span class="keyword">new</span> <span class="title class_">CollegeManner</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校总部员工</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院员工</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeEmployee</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeManner</span>&#123;</span><br><span class="line">    <span class="comment">//返回学院所以员工</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title function_">getCollegeEmployee</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;CollegeEmployee&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;<span class="comment">//创建10个员工，</span></span><br><span class="line">            <span class="type">CollegeEmployee</span> <span class="variable">collegeEmployee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CollegeEmployee</span>();</span><br><span class="line">            collegeEmployee.setId(<span class="string">&quot;学院ID： &quot;</span>+String.valueOf(i));</span><br><span class="line">            list.add(collegeEmployee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEmployee</span><span class="params">( )</span>&#123;</span><br><span class="line">        <span class="comment">//获取学院员工</span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list1=getCollegeEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------分公司--------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee collegeEmployee : list1) &#123;</span><br><span class="line">            System.out.println(collegeEmployee.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SChoolManner</span>&#123;</span><br><span class="line">    <span class="comment">//返回学校总部所以员工</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getCollegeEmployee</span><span class="params">()</span>&#123;</span><br><span class="line">       List&lt;Employee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">           <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">           employee.setId(<span class="string">&quot;学校总部员工： &quot;</span>+String.valueOf(i));</span><br><span class="line">           list.add(employee);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printALlEmployee</span><span class="params">(CollegeManner sub)</span>&#123;</span><br><span class="line">         sub.printEmployee();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//学校总部员工</span></span><br><span class="line">        List&lt;Employee&gt; list2=<span class="built_in">this</span>.getCollegeEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------总部--------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Employee employee : list2) &#123;</span><br><span class="line">            System.out.println(employee.getId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>卧槽，好厉害，原来这就是软件设计</p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul><li>1)迪米特法则的核心是降低类之间的耦合</li><li>2)但是注意:由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系，并不是要求完全没有依赖天系</li></ul><hr><h3 id="3-2-7-合成复用原则-CARP"><a href="#3-2-7-合成复用原则-CARP" class="headerlink" title="3.2.7 合成复用原则 CARP"></a>3.2.7 合成复用原则 CARP</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>原则是尽量使用合成/聚合的方式，而不是继承</p><h4 id="案例引用"><a href="#案例引用" class="headerlink" title="案例引用"></a>案例引用</h4><p>我们假设有一个什么呢我想想…假设我们村里有一个乒乓球室（一个类A），我想去里面打乒乓球(一个类B想要实现A里面的方法)，然后我就直接去那里天天打乒乓球（最简单的方法就是我们直接继承），可是有一天乒乓球馆扩建了（A类添加了很多B类不需要的功能，所以耦合性就变高了很多），里面建了篮球场，羽毛球，排球…，突然间体育馆人变多了很多，可我只想要打乒乓球，我还是喜欢安静一点的地方</p><p>那么我们该如何解决呢？(⊙_⊙)？</p><p>对啦聪明的你肯定想到了，我们前面有讲依赖传递的三种方式，这里无论用那种都可以将A与B的关系分开来</p><hr><h2 id="3-3设计原则的核心思想"><a href="#3-3设计原则的核心思想" class="headerlink" title="3.3设计原则的核心思想"></a>3.3设计原则的核心思想</h2><ul><li>1)找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li><li>2)针对<strong>接口编程</strong>，而不是针对实现编程。</li><li>3)为了交互对象之间的松耦合设计而努力</li></ul><p>我们的七大设计原则就到这里啦，要及时复习哦还是很容易混的，加油加油加油你一定可以的！( •̀ ω •́ )✧</p><hr><h1 id="4-23种设计模式"><a href="#4-23种设计模式" class="headerlink" title="4. 23种设计模式"></a>4. 23种设计模式</h1><p>woc！</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>1)设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，模式不是代码，而是某类问题的<strong>通用解决方案</strong>，设计模式(Design pattern)代表了<strong>最佳的实践</strong>。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</li><li>2)设计模式的本质提高软件的维护性，通用性和扩展性，并降低软件的复杂</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li>创建型模式:<strong>单例摸式</strong>、抽象工厂模式、原型模式、建造者模式、<strong>工厂模式</strong>。</li><li>结构型模式:适配器模式、桥接模式、<strong>装饰模式</strong>、组合模式、外观模式、享元模式、代理模式。</li><li>行为型模式:模版方法模式、命令模式、访问者模式、迭代器模式、<strong>观察者模式</strong>、中介者模式、备忘录模式、解释器模式(Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)。</li></ol><p>反正我是先爆炸了</p><hr><h2 id="创建型模式-1"><a href="#创建型模式-1" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h3><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类<strong>只能存在一个对象实例</strong>，并且该类只提供一个取得其对象实例的方法。</p><h4 id="单例模式的八种方式"><a href="#单例模式的八种方式" class="headerlink" title="单例模式的八种方式"></a>单例模式的八种方式</h4><ul><li>1)<strong>饿汉式(静态常量)</strong></li><li>2<strong>)饿汉式（静态代码块)</strong></li><li>3)懒汉式(线程不安全)</li><li>4)懒汉式(线程安全，同步方法)</li><li>5)懒汉式(线程安全，同步代码块)</li><li><strong>6)双重检查</strong></li><li><strong>7)静态内部类</strong></li><li><strong>8枚举</strong></li></ul><p>woc太多了不学了</p><h5 id="1-饿汉式-静态常量"><a href="#1-饿汉式-静态常量" class="headerlink" title="1.饿汉式(静态常量)"></a>1.饿汉式(静态常量)</h5><ol><li>构造器私有化（防止通过new创建实例）</li><li>类的内部创建对象</li><li>向外暴露一个静态的公共方法。getInstance（返回实例）</li><li>代码实现</li></ol><h6 id="小测试"><a href="#小测试" class="headerlink" title="小测试"></a>小测试</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.design.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/20/13:20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:饿汉式(静态常量)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">type1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        System.out.println(instance.hashCode() == instance2.hashCode());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这两个实例是同一个实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态变量饿汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化 外部不能new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//本类内部创建实例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>嗨嗨嗨，准备好要听李师傅瞎编了没呢，我们来一起解释一下代码吧</p></li><li><p>首先我们先来看Singleton类，这里将构造器私有化，也就是我们不能在外部写：</p></li><li><p>```java<br>Singleton singleton = new Singleton();</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 然后呢我们在本类中创建一个实例， private final static 私有，不可更改，且唯一的实例化（static）</span><br><span class="line"></span><br><span class="line">- 欸，我们现在将这个实例给私有了，那别人怎么用呢，我们再给他一个静态方法，让外部只能调用这个方法才能有返回</span><br><span class="line"></span><br><span class="line">- 同时呢，我们的单例模式的宗旨就是一个类只能存在一个对象实例，所以我们要使用静态来修饰</span><br><span class="line"></span><br><span class="line">###### 优缺点</span><br><span class="line"></span><br><span class="line">优缺点说明:</span><br><span class="line"></span><br><span class="line">- 1)优点:这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</span><br><span class="line">- 2)缺点:在类装载的时候就完成实例化，没有达到Lazy Loading（满加载）的效果。**如果从始至终从未使用过这个实例，则会造成内存的浪费**</span><br><span class="line">- 3)这种方式基于classloder（类装载）机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用getInstance方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance就没有达到lazy loading的效果</span><br><span class="line">- 4)结论:这种单例模式可用，**可能造成内存浪费**</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">##### 2.饿汉式（静态代码块)</span><br><span class="line"></span><br><span class="line">我们来看代码吧☀️</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">package com.sgg.design.singleton;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created with IntelliJ IDEA.</span><br><span class="line"> *</span><br><span class="line"> * @Author: 李阳</span><br><span class="line"> * @Date: 2024/12/20/13:47</span><br><span class="line"> * @Description: 饿汉式（静态代码块）</span><br><span class="line"> */</span><br><span class="line">public class type2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton2 instance3 = Singleton2.getInstance();</span><br><span class="line">        Singleton2 instance4 = Singleton2.getInstance();</span><br><span class="line"></span><br><span class="line">        // 检查两个实例是否相等，结果应为true</span><br><span class="line">        System.out.println(instance3 == instance4);  // true</span><br><span class="line"></span><br><span class="line">        // 检查两个实例的 hashCode 是否相等，结果应为true</span><br><span class="line">        System.out.println(instance3.hashCode() == instance4.hashCode());  // true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Singleton2 &#123;</span><br><span class="line">    // 构造器私有化，外部不能直接 new</span><br><span class="line">    private Singleton2() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 本类内部创建单例对象</span><br><span class="line">    private static Singleton2 INSTANCE;</span><br><span class="line"></span><br><span class="line">    // 在静态代码块中创建单例对象</span><br><span class="line">    static &#123;</span><br><span class="line">        INSTANCE = new Singleton2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 提供一个公有的静态方法，返回实例对象</span><br><span class="line">    public static Singleton2 getInstance() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>准备好了吗，我又要开始瞎编啦</p><ul><li>还是一样的我们私有化构造器 (单例类的构造器被私有化，意味着外部无法直接通过 <code>new</code> 关键字创建该类的实例。这是为了防止在外部代码中实例化多个 <code>Singleton2</code> 对象，从而违反单例模式的原则。)</li><li><code>INSTANCE</code>是一个 <code>private static</code> 类型的变量。它用来存储单例对象。<code>static</code> 表示这个变量属于类本身，而不是某个实例，也就是说，类加载时这个变量就会被分配内存空间。</li><li><code>static</code> 静态代码块用于在类加载时初始化 <code>INSTANCE</code> 对象。静态代码块在类被加载到 JVM 中时只执行一次，因此这里创建的 <code>INSTANCE</code> 对象也只会存在一个实例。这样就实现了单例模式的特性，保证了 <code>Singleton2</code> 只有一个实例。</li><li>由于 <code>INSTANCE</code> 是 <code>static</code> 的，所以即使 <code>Singleton2</code> 类没有被实例化，<code>INSTANCE</code> 仍然可以通过类名直接访问。</li></ul><p>什么？你还是听不懂?听不懂就对了，这是ai写的不是我说的，我也还没看懂</p><p>emm 不过这是一个因为我们先创建了一个私有变量<code>instace</code> 会在内存中开辟一段空间，这个空间是在类加载中就加载，我们传统的是实例化的时候加载，所以我们用的还是同一个实例化的对象满足了单例模式。</p><p>那么为什么我们要写成静态代码块的样子呢就很好解释了，就是想要在类加载的时候就加载这个对象，这种与上面那种其实是一样的只是写法不太一样。第二种相对比较动态</p><h6 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h6><ul><li>1）这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。</li><li>2)结论:这种单例模式可用，但是可能造成内存浪费</li></ul><h5 id="3-懒汉式-线程不安全"><a href="#3-懒汉式-线程不安全" class="headerlink" title="3.懒汉式(线程不安全)"></a>3.懒汉式(线程不安全)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.design.singleton.Type03;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/20/14:27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:懒汉式(线程不安全)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">type03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        System.out.println(instance.hashCode() == instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">// 本类内部创建单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">//防止new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的工友方法，当使用到该方法时候才去创建instance</span></span><br><span class="line">    <span class="comment">//即懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="comment">//如果没有创建，则就创建</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">              instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嘿嘿嘿，有没有突然明白懒汉与饿汉的区别呢</p><p>懒汉很懒，饿的时候再吃饭</p><p>饿汉饿怕了，先把饭做好，还不饿我就已经准备吃饭了</p><h6 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h6><ul><li>1)起到了Lazy Loading的效果，但是只能在单线程下使用。</li><li>2）如果在多线程下，一个线程进入_了if (singleton ==null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式</li><li>3）结论:<strong>在实际开发中，不要使用这种方式.</strong></li></ul><h5 id="4-懒汉式-线程安全，同步方法"><a href="#4-懒汉式-线程安全，同步方法" class="headerlink" title="4.懒汉式(线程安全，同步方法)"></a>4.懒汉式(线程安全，同步方法)</h5><p><code>synchronized</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.design.singleton.Type04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/20/15:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:懒汉式(线程安全 ， 同步方法)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">type04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        System.out.println(instance.hashCode() == instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">// 本类内部创建单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">//防止new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的工友方法，加入同步处理方法</span></span><br><span class="line">    <span class="comment">//即懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//如果没有创建，则就创建</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h6><ul><li>1)解决了线程不安全问题</li><li>2)效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低</li><li>3)结论:<strong>在实际开发中，不推荐使用这种方式</strong></li></ul><h5 id="5-懒汉式-线程安全，同步代码块"><a href="#5-懒汉式-线程安全，同步代码块" class="headerlink" title="5.懒汉式(线程安全，同步代码块)"></a>5.懒汉式(线程安全，同步代码块)</h5><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787af3cb1214.png" alt="image-20241220150913821.png">、</p><h6 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h6><ul><li>1）这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低，改为同步产生实例化的的代码块</li><li>2)但是这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (singleton+== null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例</li><li>3）结论:在实际开发中，不能使用这种方式</li></ul><h5 id="6-双重检查（推荐）"><a href="#6-双重检查（推荐）" class="headerlink" title="6.双重检查（推荐）"></a>6.双重检查（推荐）</h5><p>保证一个线程在执行</p><p>我好累有点不太想说话了</p><p>凑合着看代码吧</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.design.singleton.Type06;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/20/15:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 双重检查（推荐）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">type06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        System.out.println(instance.hashCode() == instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">// 本类内部创建单例对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * volatile 共享，可见性，禁止指令重排</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="comment">//防止new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的工友方法，加入双重检查代码，解决懒加载与线程安全</span></span><br><span class="line">    <span class="comment">//即懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//如果没有创建，则就创建</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下代码吧<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678786cf29597.gif" alt></p><p>首先我们先解释一下两个关键字</p><ul><li>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性，Java中每一个对象都可以作为锁，这是synchronized实现同步的基础。</li><li>volatile 理解为把实例化的对象共享即可</li><li>假设我们有A，B两个线程，A进入了第一个if语句，这时候（synchronized）B就只能再门口等着，A执行第二个if语句实例化了对象就退出了（volatile），B进入第二个循环语句被告知instance不为空了，所以就不用执行那一个实例化语句了</li><li>往后面及时有再多的线程也进不去第二个循环了</li></ul><h6 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h6><ul><li>Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两次if (singleton ==null）检查．这样就可以保证线程安全了。</li><li>这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象，也避免的反复进行方法同步.</li><li>线程安全;延迟加载;效率较高</li><li>结论:在实际开发中，推荐使用这种单例设计模式</li></ul><h5 id="7-静态内部类（推荐）"><a href="#7-静态内部类（推荐）" class="headerlink" title="7.静态内部类（推荐）"></a>7.静态内部类（推荐）</h5><p>当我们的Singleton被装载时，我们的静态内部类不会被装载</p><p>当我们去调用Singleton 的get方法的时候，用到了这个静态变量的时候，我们的静态静态内会被装载，当我们类被装载的时候线程是安全的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.design.singleton.Type7;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/20/15:39</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:使用静态内部类完成单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">type07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        System.out.println(instance.hashCode() == instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">// 本类内部创建单例对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="comment">//防止new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个静态内部类该类中有个静态属性Singleton</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的工友方法，直接返回return SingletonInstance.instance;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这代码感觉好有质量</p><p>我来编一下代码逻辑</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678786d0132f7.gif" alt></p><p>这个静态内部类他在我们Singleton装载的时候并不会马上执行（保障了我们的单例和懒加载都是可以满足的）</p><p>当我们调用getInstance的时候，他会取这个静态内部类SingletonInstance里的instance属性，这个时候我们的SingletonInstance就可以加载了，因为我们的静态内在装载的过程中是线程安全的</p><h6 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h6><ul><li>1)这种方式采用了类装载的机制来保证初始化实例时只有一个线程。</li><li>2）静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，牙会装载SingletonInstance类，从而完成singleton的实例化。</li><li>3)类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</li><li>4)优点:避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</li><li>5)结论:推荐使用.</li></ul><h5 id="8-枚举（最完美）"><a href="#8-枚举（最完美）" class="headerlink" title="8.枚举（最完美）"></a>8.枚举（最完美）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.design.singleton.Type8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/20/16:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">type8</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        System.out.println(instance == instance2);</span><br><span class="line"></span><br><span class="line">        System.out.println(instance.hashCode() == instance2.hashCode());</span><br><span class="line"></span><br><span class="line">        instance.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用枚举完成单例</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;<span class="comment">//一个属性保证了单例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h6><ul><li>1)这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象</li><li>2)这种方式是tffective Java作者Josh Bloch提倡的方式</li><li>3)结论(推荐使用</li></ul><h4 id="单例模式的注意事项和细节说明"><a href="#单例模式的注意事项和细节说明" class="headerlink" title="单例模式的注意事项和细节说明"></a>单例模式的注意事项和细节说明</h4><ul><li>1)）单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系绞性能</li><li>2)当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new</li><li>3)单例模式使用的场景:需要频繁的进行创建和销毁的对象创建对象时耗时过多或耗费资源过多(即:重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、session工厂等)</li></ul><hr><p>又是一年冬至</p><hr><h3 id="2-简单工厂模式"><a href="#2-简单工厂模式" class="headerlink" title="2.简单工厂模式"></a>2.简单工厂模式</h3><h4 id="案例应用"><a href="#案例应用" class="headerlink" title="案例应用"></a>案例应用</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787af6ed8cb0.png" alt="image-20241220173718576.png"></p><ul><li><p>第一步：建一个抽象方法</p><ul><li><p>（什么？你问我为什么建一个抽象方法）</p></li><li><p>抽象方法相当于标准，我们很多披萨只要实现这个方法就好了，避免大量操作</p></li></ul></li><li><p>第二步：其他披萨去继承这个披萨抽象类就可以了，然后再子类中重写就可以啦</p></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787afd178a21.png" alt="image-20241220174631577-1734687992811-1.png"></p><h4 id="传统代码"><a href="#传统代码" class="headerlink" title="传统代码"></a>传统代码</h4><p>没有使用工厂方法的</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787afd179665.png" alt="image-20241220183120815.png"></p><p>注意：超多方法来袭</p><p>pizza抽象类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.design.Factory.simplefactory.pizzastore.Pizza;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/20/17:47</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:抽象披萨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;<span class="comment">//披萨名字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备原材料 不同披萨不一样，因此作出抽象类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bake</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bake on &quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">public</span>   <span class="keyword">void</span> <span class="title function_">cut</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cut on &quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">box</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Box on &quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>希腊披萨</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.design.Factory.simplefactory.pizzastore.Pizza;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/20/17:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:希腊披萨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreekPizza</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;希腊劈杀啥味的没吃过&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>奶酪披萨</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.design.Factory.simplefactory.pizzastore.Pizza;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/20/17:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:奶酪披萨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheessPizza</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//准备原材料</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我没吃过奶酪披萨，我喜欢达美乐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>订购披萨的功能</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.design.Factory.simplefactory.pizzastore.order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sgg.design.Factory.simplefactory.pizzastore.Pizza.CheessPizza;</span><br><span class="line"><span class="keyword">import</span> com.sgg.design.Factory.simplefactory.pizzastore.Pizza.GreekPizza;</span><br><span class="line"><span class="keyword">import</span> com.sgg.design.Factory.simplefactory.pizzastore.Pizza.Pizza;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * &amp;#064;Date:  2024/12/20/17:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:订购披萨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为他会使用到我们前面的方法，所以定义构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        String orderType;<span class="comment">//订购pizza的类型</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            orderType = getType();</span><br><span class="line">            <span class="keyword">if</span> (orderType .equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>();</span><br><span class="line">               pizza.name = <span class="string">&quot;希腊劈杀&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType .equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">                pizza=<span class="keyword">new</span> <span class="title class_">CheessPizza</span>();</span><br><span class="line">                pizza.name=<span class="string">&quot;耐劳劈杀&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//输出pizza制作构成</span></span><br><span class="line">            pizza.prepare();</span><br><span class="line">            pizza.bake();</span><br><span class="line">            pizza.cut();</span><br><span class="line">            pizza.box();</span><br><span class="line">        &#125;<span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入要订购的劈杀&quot;</span>);</span><br><span class="line">            String str=bufferedReader.readLine();</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.design.Factory.simplefactory.pizzastore.order;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/20/18:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PizzaStore</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">OrderPizza</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787afd18da20.png" alt="image-20241220182941372.png"></p><hr><p>假设我们现在增加一个新品种—胡椒披萨</p><p>呼叫劈杀</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sgg.design.Factory.simplefactory.pizzastore.Pizza;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 李阳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/12/20/18:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:新增胡椒劈杀</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PepperPizza</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;给胡椒披萨准备材料&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要修改OrderPizza里面的内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (orderType .equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>();</span><br><span class="line">               pizza.name = <span class="string">&quot;希腊劈杀&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType .equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">                pizza=<span class="keyword">new</span> <span class="title class_">CheessPizza</span>();</span><br><span class="line">                pizza.name=<span class="string">&quot;耐劳劈杀&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType .equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">                pizza=<span class="keyword">new</span> <span class="title class_">PepperPizza</span>();</span><br><span class="line">                pizza.name=<span class="string">&quot;呼叫劈杀&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>哎哎哎等等，新增功能会修改源代码怎么这么熟悉，你能联想到什么原则呢</p><p>对对对，就是那个那个那个那个嘛，我知道的👀</p><p>《开闭原则》</p><p>对啦，太聪明啦，我就知道你会想起来的</p><h5 id="传统方式优缺点"><a href="#传统方式优缺点" class="headerlink" title="传统方式优缺点"></a>传统方式优缺点</h5><ol><li>优点是比较好理解，简单易操作。</li><li>缺点是违反了设计模式的ocp原则，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.</li><li>比如我们这时要新增加一个Pizza的种类(Pepper披萨)，我们需要做源代码修改.</li></ol><h6 id="改进思路"><a href="#改进思路" class="headerlink" title="改进思路"></a>改进思路</h6><p><strong>分析</strong>:修改代码可以接受，但是如果我们在其它的地方也有创建Pizza的代码，就意味着，也需要修改，而创建Pizza的代码，往往有多处。</p><p><strong>思路</strong>:<strong>把创建Pizza对象封装到一个类中</strong>，这样我们有新的Pizza种类时，只需要修改该类就可，<strong>其它有创建到Pizza对象的代码就不需要修改了-</strong>—&gt;简单工厂模式</p><hr><h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><ul><li>1)简单工厂模式是属于创建型模式，是工厂模式的一种。<strong>简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例</strong>。简单工厂模式是工厂模式家族中最简单实用的模式</li><li>2)简单工厂模式:定义了一个创建对象的类，由这个类来封装实例化对象的行为(代码)</li><li>3）在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式.</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787afd19babb.png" alt="image-20241225144054449.png"></p><p>我们现在定义了一个工厂（类似黑中介，代购）想买披萨是吧？先来找我，我帮你去买</p></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/03/01/67c2609b7c10b.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/03/01/67c2609b7c10b.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">李阳</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://blog.baskly.fun/posts/e2e289e8/">原创</a><a class="post-copyright-title"><span onclick='rm.copyPageUrl("https://blog.baskly.fun/posts/e2e289e8/")'>软件设计与体系结构</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://blog.baskly.fun/posts/e2e289e8/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=软件设计与体系结构&amp;url=https://blog.baskly.fun/posts/e2e289e8/&amp;pic=https://bu.dusays.com/2024/12/09/67566939ebf4b.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl(){var e=window.location.href,t=document.createElement("input");t.setAttribute("value",e),document.body.appendChild(t),t.select(),t.setSelectionRange(0,99999),document.execCommand("copy"),document.body.removeChild(t)}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.baskly.fun" target="_blank">李阳的秘密小屋</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"><span class="categoryes-punctuation"><i class="anzhiyufont anzhiyu-icon-inbox"></i></span> 软件工程<span class="categoryesPageCount">1</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"><span class="tags-punctuation"><i class="anzhiyufont anzhiyu-icon-tag"></i></span> 软件工程<span class="tagsPageCount">1</span></a></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2024/12/24/676a8d8bc7d9f.png?_r_=b766501c-375f-d622-6ca5-bfbc65ab58d7" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/e255a10a/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="/" onerror='onerror=null,src="https://bu.dusays.com/2025/05/30/68398ca86a127.gif"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机网络</div></div></a></div><div class="next-post pull-right"><a href="/posts/28799/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2024/11/24/674340e1191e4.png?_r_=c48932a0-ede0-2d0b-c9d3-e08de483d64d" onerror='onerror=null,src="https://bu.dusays.com/2025/05/30/68398ca86a127.gif"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">日记本</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i> <span>评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left:4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/03/01/67c2609b7c10b.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"><div class="author-status"><img class="g-status" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2021/01/15/805daa7195f2c.gif" alt="status"></div></div><div class="author-info__description"><div style="line-height:1.38;margin:.6rem 0;text-align:justify;color:rgba(255,255,255,.8)">这有描绘<b style="color:#fff">我的痕迹</b></div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about"><h1 class="author-info__name">李阳</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/lyay23" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">软件设计与体系结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.</span> <span class="toc-text">第一章 软件设计模式相关内容介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">1.设计模式概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E4%BA%A7%E7%94%9F%E8%83%8C%E6%99%AF"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1产生背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2软件设计模式概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E5%AD%A6%E4%B9%A0%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.3学习软件设计的必要性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%B7%E6%9C%89%E4%BB%A5%E4%B8%8B%E4%BC%98%E7%82%B9%E3%80%82"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">1.4正确使用设计模式具有以下优点。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.4.</span> <span class="toc-text">1.5设计模式分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">创建型模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">结构型模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.4.3.</span> <span class="toc-text">行为型模式</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-UML"><span class="toc-number">3.</span> <span class="toc-text">2.UML</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E7%B1%BB%E5%9B%BE%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">2.1类图概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E7%B1%BB%E5%9B%BE%E4%BD%9C%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">2.2类图作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E7%B1%BB%E5%9B%BE%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">2.3类图表示法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1%E7%B1%BB%E5%9B%BE%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.1.</span> <span class="toc-text">2.3.1类图表示方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2%E7%B1%BB%E4%B8%8E%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.2.</span> <span class="toc-text">2.3.2类与类之间的表示方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-1%E5%85%B3%E8%81%94%E8%81%94%E7%B3%BB"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">2.3.2.1关联联系</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2-1-1%E5%8D%95%E5%90%91%E5%85%B3%E8%81%94"><span class="toc-number">3.3.2.1.1.</span> <span class="toc-text">2.3.2.1.1单向关联</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2-1-2%E5%8F%8C%E5%90%91%E5%85%B3%E8%81%94"><span class="toc-number">3.3.2.1.2.</span> <span class="toc-text">2.3.2.1.2双向关联</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2-1-3%E8%87%AA%E5%85%B3%E8%81%94%EF%BC%88%E9%93%BE%E8%A1%A8%EF%BC%89"><span class="toc-number">3.3.2.1.3.</span> <span class="toc-text">2.3.2.1.3自关联（链表）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-2%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">2.3.2.2聚合关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-3%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">2.3.2.3组合关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-4%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">3.3.2.4.</span> <span class="toc-text">2.3.2.4依赖关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-5%E6%B3%9B%E5%8C%96-%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">3.3.2.5.</span> <span class="toc-text">2.3.2.5泛化&#x2F;继承关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-6%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB"><span class="toc-number">3.3.2.6.</span> <span class="toc-text">2.3.2.6实现关系</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">4.</span> <span class="toc-text">3.软件设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9B%AE%E7%9A%84"><span class="toc-number">4.1.</span> <span class="toc-text">3.1设计模式目的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-number">4.2.</span> <span class="toc-text">3.2七大原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3-SRP%E2%80%94%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.1.</span> <span class="toc-text">3.2.1单一职责 SRP—一个类一个方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">单一设计原则注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99ISP%E2%80%94%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.2.2.</span> <span class="toc-text">3.2.2接口隔离原则ISP—最小接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99-DIP%E2%80%94%E4%BE%9D%E8%B5%96%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1"><span class="toc-number">4.2.3.</span> <span class="toc-text">3.2.3依赖倒转原则 DIP—依赖接口和抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E4%BC%A0%E9%80%92%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%88%E7%9C%8B%E6%87%82%E5%8D%B3%E5%8F%AF%EF%BC%89"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">依赖关系传递的三种方式（看懂即可）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80-%E6%8E%A5%E5%8F%A3%E4%BC%A0%E9%80%92"><span class="toc-number">4.2.3.1.1.</span> <span class="toc-text">方式一 接口传递</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%BC%A0%E9%80%92"><span class="toc-number">4.2.3.1.2.</span> <span class="toc-text">方式二 构造方法传递</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89-setter%E4%BC%A0%E9%80%92"><span class="toc-number">4.2.3.1.3.</span> <span class="toc-text">方法三 setter传递</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.2.3.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99LSP%E2%80%94%E7%BB%A7%E6%89%BF"><span class="toc-number">4.2.4.</span> <span class="toc-text">3.2.4里氏替换原则LSP—继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#oo%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%A1%80%E6%80%A7%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E8%AF%B4%E6%98%8E"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">oo中的基础性的思考和说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.2.4.2.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B"><span class="toc-number">4.2.4.3.</span> <span class="toc-text">代码案例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%91%E5%86%B3%E5%AE%9A%E8%A6%81%E5%81%9A%E4%B8%80%E4%B8%AA%E8%BF%9D%E8%83%8C%E7%A5%96%E5%AE%97%E7%9A%84%E5%86%B3%E5%AE%9A%EF%BC%81"><span class="toc-number">4.2.4.3.1.</span> <span class="toc-text">我决定要做一个违背祖宗的决定！</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%B9%E5%86%99%E6%A1%88%E4%BE%8B"><span class="toc-number">4.2.4.3.2.</span> <span class="toc-text">改写案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-5-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99OCP%EF%BC%88%E7%89%B9%E5%88%AB%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">4.2.5.</span> <span class="toc-text">3.2.5 开闭原则OCP（特别重要）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">4.2.5.1.</span> <span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%91%E5%86%B3%E5%AE%9A%E2%80%A6"><span class="toc-number">4.2.5.1.1.</span> <span class="toc-text">我决定…</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B"><span class="toc-number">4.2.5.1.2.</span> <span class="toc-text">改进</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-6%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99LoD"><span class="toc-number">4.2.6.</span> <span class="toc-text">3.2.6迪米特法则LoD</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">4.2.6.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-1"><span class="toc-number">4.2.6.2.</span> <span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A7%E7%89%88"><span class="toc-number">4.2.6.2.1.</span> <span class="toc-text">旧版</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%8E%9F%E5%9B%A0"><span class="toc-number">4.2.6.2.1.1.</span> <span class="toc-text">错误原因</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%B9%E7%89%88"><span class="toc-number">4.2.6.2.2.</span> <span class="toc-text">改版</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">4.2.6.2.3.</span> <span class="toc-text">注意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-7-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99-CARP"><span class="toc-number">4.2.7.</span> <span class="toc-text">3.2.7 合成复用原则 CARP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">4.2.7.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%BC%95%E7%94%A8"><span class="toc-number">4.2.7.2.</span> <span class="toc-text">案例引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">4.3.</span> <span class="toc-text">3.3设计原则的核心思想</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">4. 23种设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">5.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">5.2.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-1"><span class="toc-number">5.3.</span> <span class="toc-text">创建型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.3.1.</span> <span class="toc-text">1.单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AB%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">单例模式的八种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%A5%BF%E6%B1%89%E5%BC%8F-%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F"><span class="toc-number">5.3.1.1.1.</span> <span class="toc-text">1.饿汉式(静态常量)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B0%8F%E6%B5%8B%E8%AF%95"><span class="toc-number">5.3.1.1.1.1.</span> <span class="toc-text">小测试</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">5.3.1.1.1.2.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%87%92%E6%B1%89%E5%BC%8F-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="toc-number">5.3.1.1.2.</span> <span class="toc-text">3.懒汉式(线程不安全)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="toc-number">5.3.1.1.2.1.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%87%92%E6%B1%89%E5%BC%8F-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%8C%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.1.1.3.</span> <span class="toc-text">4.懒汉式(线程安全，同步方法)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-2"><span class="toc-number">5.3.1.1.3.1.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E6%87%92%E6%B1%89%E5%BC%8F-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%8C%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">5.3.1.1.4.</span> <span class="toc-text">5.懒汉式(线程安全，同步代码块)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-3"><span class="toc-number">5.3.1.1.4.1.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">5.3.1.1.5.</span> <span class="toc-text">6.双重检查（推荐）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-4"><span class="toc-number">5.3.1.1.5.1.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">5.3.1.1.6.</span> <span class="toc-text">7.静态内部类（推荐）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-5"><span class="toc-number">5.3.1.1.6.1.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E6%9E%9A%E4%B8%BE%EF%BC%88%E6%9C%80%E5%AE%8C%E7%BE%8E%EF%BC%89"><span class="toc-number">5.3.1.1.7.</span> <span class="toc-text">8.枚举（最完美）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-6"><span class="toc-number">5.3.1.1.7.1.</span> <span class="toc-text">优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82%E8%AF%B4%E6%98%8E"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">单例模式的注意事项和细节说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.3.2.</span> <span class="toc-text">2.简单工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%BA%94%E7%94%A8"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">案例应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E4%BB%A3%E7%A0%81"><span class="toc-number">5.3.2.2.</span> <span class="toc-text">传统代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">5.3.2.2.1.</span> <span class="toc-text">传统方式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E6%80%9D%E8%B7%AF"><span class="toc-number">5.3.2.2.1.1.</span> <span class="toc-text">改进思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.3.2.3.</span> <span class="toc-text">简单工厂模式</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/11096/" title="Redis黑马版"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2024/12/24/676a8d8bc7d9f.png?_r_=b766501c-375f-d622-6ca5-bfbc65ab58d7" onerror='this.onerror=null,this.src="https://bu.dusays.com/2025/05/30/68398ca86a127.gif"' alt="Redis黑马版"></a><div class="content"><a class="title" href="/posts/11096/" title="Redis黑马版">Redis黑马版</a><time datetime="2025-09-08T02:34:21.000Z" title="发表于 2025-09-08 10:34:21">2025-09-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/45509/" title="java面试黑马版"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2024/11/24/674340e0cd15e.png?_r_=54121082-7858-1ae0-0779-d198fadeba65" onerror='this.onerror=null,this.src="https://bu.dusays.com/2025/05/30/68398ca86a127.gif"' alt="java面试黑马版"></a><div class="content"><a class="title" href="/posts/45509/" title="java面试黑马版">java面试黑马版</a><time datetime="2025-09-07T02:34:21.000Z" title="发表于 2025-09-07 10:34:21">2025-09-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3860/" title="黑马学成在线"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2024/11/24/674340e0cd15e.png?_r_=456351c6-24ef-054b-2585-a57c1677c6ef" onerror='this.onerror=null,this.src="https://bu.dusays.com/2025/05/30/68398ca86a127.gif"' alt="黑马学成在线"></a><div class="content"><a class="title" href="/posts/3860/" title="黑马学成在线">黑马学成在线</a><time datetime="2025-08-04T02:34:21.000Z" title="发表于 2025-08-04 10:34:21">2025-08-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/42622/" title="SpringCloud"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2024/11/24/674340e0cd15e.png?_r_=320ac6a6-3bf5-9cc8-180a-c9c4b73ea680" onerror='this.onerror=null,this.src="https://bu.dusays.com/2025/05/30/68398ca86a127.gif"' alt="SpringCloud"></a><div class="content"><a class="title" href="/posts/42622/" title="SpringCloud">SpringCloud</a><time datetime="2025-07-13T00:34:21.000Z" title="发表于 2025-07-13 08:34:21">2025-07-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/49515/" title="前端学习（tlias为例）"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2024/11/24/674340e151d6a.png?_r_=90fa1921-0a69-b602-3178-9ee5211c46f1" onerror='this.onerror=null,this.src="https://bu.dusays.com/2025/05/30/68398ca86a127.gif"' alt="前端学习（tlias为例）"></a><div class="content"><a class="title" href="/posts/49515/" title="前端学习（tlias为例）">前端学习（tlias为例）</a><time datetime="2025-05-25T03:34:21.000Z" title="发表于 2025-05-25 11:34:21">2025-05-25</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By 李阳</div><div class="footer_custom_text">下次再见！</div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">5</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size:.9em"></i> <span>隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size:.9em"></i> <span>分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size:.9em"></i> <span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/charts/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tongji1"></use></svg> <span>统计</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=12781955100&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size:.9em"></i> <span>耳机分你一半</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size:.9em"></i> <span>留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/todolist/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zuji"></use></svg> <span>脚步</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/essay/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-taiyang"></use></svg> <span>小太阳</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-a-xiaoyangyang_huaban1"></use></svg> <span>了解我</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/408/" style="font-size:.88rem">408<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size:.88rem">C语言<sup>1</sup></a><a href="/tags/java/" style="font-size:.88rem;font-weight:500;color:var(--anzhiyu-lighttext)">java<sup>1</sup></a><a href="/tags/javaweb/" style="font-size:.88rem">javaweb<sup>9</sup></a><a href="/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/" style="font-size:.88rem">力扣刷题<sup>1</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size:.88rem">操作系统<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size:.88rem">数据结构<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size:.88rem">计算机组成原理<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size:.88rem">计算机网络<sup>2</sup></a><a href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" style="font-size:.88rem">软件工程<sup>1</sup></a></div></div><hr></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="anzhiyu.scrollToDest(document.body.scrollHeight,500)"><i class="anzhiyufont anzhiyu-icon-arrow-down"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="12781955100" server="netease" type="playlist" mutex="true" preload="none" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size:1rem"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/playlist?id=12781955100&quot;, &quot;_blank&quot;);" style="display:none"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>var HoldLog=console.log;console.log=function(){};let now1=new Date;queueMicrotask((()=>{const o=function(){HoldLog.apply(console,arguments)},n=new Date("04/01/2021 00:00:00");now1.setTime(now1.getTime()+250);const c=(now1-n)/1e3/60/60/24,e=["欢迎使用安知鱼!","生活明朗, 万物可爱","\n        \n       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗\n      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║\n      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║\n      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║\n      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝\n      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝\n        \n        ","已上线",Math.floor(c),"天","©2024 By 安知鱼 V1.6.14"],t=["NCC2-036","调用前置摄像头拍照成功，识别为【小笨蛋】.","Photo captured: ","🤪"];setTimeout(o.bind(console,`\n%c${e[0]} %c ${e[1]} %c ${e[2]} %c${e[3]}%c ${e[4]}%c ${e[5]}\n\n%c ${e[6]}\n`,"color:#425AEF","","color:#425AEF","color:#425AEF","","color:#425AEF","")),setTimeout(o.bind(console,`%c ${t[0]} %c ${t[1]} %c \n${t[2]} %c\n${t[3]}\n`,"color:white; background-color:#4fd953","","",'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%')),setTimeout(o.bind(console,"%c WELCOME %c 你好，小笨蛋.","color:white; background-color:#4f90d9","")),setTimeout(console.warn.bind(console,"%c ⚡ Powered by 安知鱼 %c 你正在访问 李阳 的博客.","color:white; background-color:#f0ad4e","")),setTimeout(o.bind(console,"%c W23-12 %c 你已打开控制台.","color:white; background-color:#4f90d9","")),setTimeout(console.warn.bind(console,"%c S013-782 %c 你现在正处于监控中.","color:white; background-color:#d9534f",""))}))</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" href="https://cdn.cbd.int/katex@0.16.0/dist/katex.min.css"><script src="https://cdn.cbd.int/katex@0.16.0/dist/contrib/copy-tex.min.js"></script><script>document.querySelectorAll("#article-container span.katex-display").forEach((a=>{anzhiyu.wrap(a,"div",{class:"katex-wrap"})}))</script><script>(()=>{const e=document.querySelectorAll("#article-container .mermaid-wrap");if(0===e.length)return;const t=()=>{window.loadMermaid=!0;const t="dark"===document.documentElement.getAttribute("data-theme")?"dark":"default";Array.from(e).forEach(((e,n)=>{const d=e.firstElementChild,r="mermaid-"+n,a="%%{init:{ 'theme':'"+t+"'}}%%\n"+d.textContent,i=mermaid.render(r,a);var m;"string"==typeof i?(m=i,d.insertAdjacentHTML("afterend",m)):i.then((({svg:e})=>{d.insertAdjacentHTML("afterend",e)}))}))},n=()=>{window.loadMermaid?t():getScript("https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js").then(t)};anzhiyu.addGlobalFn("themeChange",t,"mermaid"),window.pjax?n():document.addEventListener("DOMContentLoaded",n)})()</script><script>(()=>{const t=()=>{"object"==typeof twikoo?setTimeout(o,0):getScript("https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js").then(o)},o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo.baskly.fun",region:"",onCommentLoaded:()=>{anzhiyu.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const t=document.getElementById("twikoo-count");t&&twikoo.getCommentsCount({envId:"https://twikoo.baskly.fun",region:"",urls:[window.location.pathname],includeReply:!1}).then((o=>{t.textContent=o[0].count})).catch((t=>{console.error(t)}))})()};t()})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener("load",(()=>{const e=e=>{let t="";if(e.length)for(let n=0;n<e.length;n++){t+="<div class='aside-list-item'>";{const a="data-lazy-src";t+=`<a href='${e[n].url}' class='thumbnail'><img ${a}='${e[n].avatar}' alt='${e[n].nick}'><div class='name'><span>${e[n].nick} </span></div></a>`}t+=`<div class='content'>\n        <a class='comment' href='${e[n].url}' title='${e[n].content}'>${e[n].content}</a>\n        <time datetime="${e[n].date}">${anzhiyu.diffDate(e[n].date,!0)}</time></div>\n        </div>`}else t+="没有评论";let n=document.querySelector("#card-newest-comments .aside-list");n&&(n.innerHTML=t),window.lazyLoadInstance&&window.lazyLoadInstance.update(),window.pjax&&window.pjax.refresh(n)},t=()=>{if(document.querySelector("#card-newest-comments .aside-list")){const t=saveToLocal.get("twikoo-newest-comments");t?e(JSON.parse(t)):(()=>{const t=()=>{twikoo.getRecentComments({envId:"https://twikoo.baskly.fun",region:"",pageSize:6,includeReply:!0}).then((function(t){const n=t.map((e=>{return{content:(t=e.comment,""===t||(t=(t=(t=(t=t.replace(/<img.*?src="(.*?)"?[^\>]+>/gi,"[图片]")).replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi,"[链接]")).replace(/<pre><code>.*?<\/pre>/gi,"[代码]")).replace(/<[^>]+>/g,"")).length>150&&(t=t.substring(0,150)+"..."),t),avatar:e.avatar,nick:e.nick,url:e.url+"#"+e.id,date:new Date(e.created).toISOString()};var t}));saveToLocal.set("twikoo-newest-comments",JSON.stringify(n),10/1440),e(n)})).catch((function(e){document.querySelector("#card-newest-comments .aside-list").textContent="无法获取评论，请确认相关配置是否正确"}))};"object"==typeof twikoo?t():getScript("https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js").then(t)})()}};t(),document.addEventListener("pjax:complete",t)}))</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail="yang@li.com"</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script async src="//at.alicdn.com/t/c/font_4782341_g014uvnbwk6.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/echarts/4.9.0-rc.1/echarts.min.js"></script><script src="https://lib.baomitu.com/echarts/4.9.0-rc.1/echarts.min.js"></script><script src="https://jsd-proxy.ygxz.in/gh/lyay23/blogstatic@v1.0.0/static/imgloaded.min.js"></script><script src="https://jsd-proxy.ygxz.in/gh/lyay23/blogstatic@v1.0.0/static/countdown.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors=['meta[property="og:image"]','meta[property="og:title"]','meta[property="og:url"]','meta[property="og:type"]','meta[property="og:site_name"]','meta[property="og:description"]',"head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"]):not([href="/music/"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(anzhiyu.removeGlobalFnEvent("pjax"),anzhiyu.removeGlobalFnEvent("themeChange"),document.getElementById("rightside").classList.remove("rightside-show"),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>