<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>java面试黑马版 | 李阳的秘密小屋</title><meta name="keywords" content="面试"><meta name="author" content="李阳"><meta name="copyright" content="李阳"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="java面试黑马版"><meta name="application-name" content="java面试黑马版"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="java面试黑马版"><meta property="og:url" content="https://blog.baskly.fun/posts/45509/index.html"><meta property="og:site_name" content="李阳的秘密小屋"><meta property="og:description" content="面试考题"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://bu.dusays.com/2024/12/24/676a8d8bc7d9f.png?_r_=3b9fde37-24bc-0474-7dd1-4a5586f05907"><meta property="article:author" content="李阳"><meta property="article:tag" content="bask,李阳"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2024/12/24/676a8d8bc7d9f.png?_r_=3b9fde37-24bc-0474-7dd1-4a5586f05907"><meta name="description" content="面试考题"><link rel="shortcut icon" href="/img/flow-32x32.ico"><link rel="canonical" href="https://blog.baskly.fun/posts/45509/"><link rel="preconnect" href="//cdn.cbd.int"><meta name="google-site-verification" content="xxx"><meta name="baidu-site-verification" content="code-xxx"><meta name="msvalidate.01" content="xxx"><link rel="manifest" href="/manifest.json"><meta name="msapplication-TileColor" content="var(--anzhiyu-main)"><link rel="mask-icon" href="/img/siteicon/yang180.png" color="#5bbad5"><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/yang180.png"><link rel="apple-touch-icon-precomposed" sizes="180x180" href="/img/siteicon/yang180.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/yang32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/yang16.png"><link rel="bookmark" href="/img/siteicon/yang180.png"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-2732.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2732-2048.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2388.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2388-1668.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1536-2048.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-1536.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2224.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2224-1668.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1620-2160.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2160-1620.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1290-2796.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2796-1290.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1179-2556.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2556-1179.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1284-2778.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2778-1284.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1170-2532.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2532-1170.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1125-2436.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2436-1125.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2688.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2688-1242.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-828-1792.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1792-828.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2208.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2208-1242.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-750-1334.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1334-750.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-640-1136.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1136-640.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={linkPageTop:void 0,peoplecanvas:void 0,postHeadAiDescription:{enable:!0,gptName:"Liyang",mode:"local",switchBtn:!1,btnLink:"https://afdian.net/item/886a79d4db6711eda42a52540025c377",randomNum:3,basicWordCount:1e3,key:"xxxx",Referer:"https://xx.xx/"},diytitle:{enable:!0,leaveTitle:"不要走",backTitle:"不要离开我     -"},LA51:void 0,greetingBox:{enable:!0,default:"晚上好👋",list:[{greeting:"晚安😴",startTime:0,endTime:5},{greeting:"早上好鸭👋, 祝你一天好心情！",startTime:6,endTime:9},{greeting:"上午好👋, 状态很好，鼓励一下～",startTime:10,endTime:10},{greeting:"11点多啦, 在坚持一下就吃饭啦～",startTime:11,endTime:11},{greeting:"午安👋, 要睡觉喽",startTime:12,endTime:14},{greeting:"🌈充实的一天辛苦啦！",startTime:14,endTime:18},{greeting:"19点喽, 奖励一顿丰盛的大餐吧🍔。",startTime:19,endTime:19},{greeting:"晚上好👋, 在属于自己的时间好好放松😌~",startTime:20,endTime:24}]},twikooEnvId:"https://twikoo.baskly.fun",commentBarrageConfig:void 0,music_page_default:"nav_music",root:"/",preloader:{source:3},friends_vue_info:void 0,navMusic:!0,mainTone:{mode:"both",api:null,cover_change:!0},authorStatus:{skills:["东隅已逝 桑榆非晚","集中精神 攻克难关"]},algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简",rightMenuMsgToTraditionalChinese:"转为繁体",rightMenuMsgToSimplifiedChinese:"转为简体"},noticeOutdate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:330},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,simplehomepage:!0,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{copy:!0,copyrightEbable:!1,limitCount:50,languages:{author:"作者: 李阳",link:"链接: ",source:"来源: 李阳的秘密小屋",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",copySuccess:"复制成功，复制和转载请标注本文地址"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#425AEF",bgDark:"#1f1f1f",position:"top-center"},source:{justifiedGallery:{js:"https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js",css:"https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1,shortcutKey:void 0,autoDarkmode:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={configTitle:"李阳的秘密小屋",title:"java面试黑马版",postAI:"",pageFillDescription:"一 、Redis, 1. 我看你在项目中使用了Redis你最近在哪些场景中使用了Redis呢？, Redis的缓存在项目中的使用？, 为什么使用Redisson分布式锁？, 2. 那么你是怎么解决缓存穿透的问题呢？, 3. 你能介绍一下布隆过滤器吗？, 4. 什么是缓存击穿？怎么解决, 5. 什么是缓存雪崩怎么解决？, 6. Redis作为缓存Mysql与Redis数据如何进行同步呢（双写一致）, 7. Redis作为缓存数据持久化是怎么做的, 8. 这两种持久化方式有什么区别呢？, 9. 这两种方式哪种恢复的比较快呢？, 10. Redis的过期策略有哪些, 11. 数据淘汰策略有哪些, 12. 数据库有1000万数据Redis只能缓存20w数据。如何保证Redis中的数据都是热点数据？, 13. Redis的内存用完了会发生什么？, 14. Redis的分布式锁是如何实现的呢, 15. Redis实现分布式锁如何合理控制锁的时长, 16. Redisson实现分布式锁是可重用的吗, 17. Redisson可以解决主从一致的问题吗, 18. 如果业务非要保证数据的强一致性这个该怎么解决呢？, 19. Redis集群有哪些方案知道吗？, 20. 那你来介绍一下主从同步, 21. 能说一下主从同步数据的流程吗？, 22. 怎么保证Redis的高并发高可用？, 23. 你们使用Redis是单点还是集群哪种集群？, 24. Redis集群脑裂该怎么解决呢？, 25. Redis的分片集群有什么作用, 26. Redis分片集群中数据是怎么存储和读取的？, 27. Redis是单线程的但是为什么还那么快？, 28. 能解释一下I/O多路复用模型？（简历还我）, 二、MySQL, 1. 在MySQL中如何定位慢查询呢？, 2. 那这个SQL语句执行很慢如何分析呢？, 3. 那你了解过索引吗？什么是索引, 4. 索引的底层数据结构了解过吗？, 5. B+树与B树的区别是什么？, 6. 什么是聚簇索引什么是非聚簇索引, 7. 什么是回表查询呢, 8. 知道什么是覆盖索引吗？, 9. MySQL超大分页怎么处理, 10. 索引的创建原则有哪些, 11. 什么情况下索引会失效, 12. 谈一谈你对SQL优化的经验？（面试常见）, 13. 创建表的时候你们是如何优化的呢？, 14. 在使用索引的时候是如何优化呢？, 15. 你平时对SQL语句做了哪些优化呢？, 16. 事务的特征是什么可以详细说一下吗, 17 . 并发事务带来哪些问题？, 18. 怎么解决这些问题呢？ MySQL的默认隔离级别是, 19. undo log和redo log 的区别, 20. 事务中的隔离性是如何保障的呢？（请你解释一下MVCC）[面试常考], 21. 主从复制的原理是什么, 22. 你们项目用过MySQL的分库分表吗？, 23. 那你之前使用过水平分库吗？, 三、 框架篇, 1. Spring框架中的单例bean是线程安全的吗？, 2. 什么是AOP？, 3. 你们项目中有没有使用到AOP, 4. Spring的事务是如何实现的, 5. Spring的事务失效的场景有哪些, 6. Spring的bean的生命周期（易考）, 7. Spring中的循环引用问题, 8. 你能说一说具体流程吗, 9. 构造方法出现了循环依赖怎么解决, 10. SpringMVC的执行流程知道吗, 11. SpringBoot的自动装配原理（易考）, 12. spring框架常见注解, 13. SpringMVC的常见注解, 14. Springboot的常见注解, 15.Spring和SpringBoot之间有什么区别？, 16. 请你描述一下Spring的DI和IOC、, 17.JDK动态代理和CGLIB动态代理有什么区别？, 18.拦截器和过滤器有什么区别, 19. @Autowired 和 @Resource 有什么不同, 20. MyBatis的执行流程是什么, 21. Mybatis是否支持延迟加载？, 22. 延迟加载的底层原理知道吗？, 23. Mybatis的一级、二级缓存用过吗？, 四、微服务, 1. SpringCloud的五大组件是什么, 2. 服务注册和发现是什么意思？Spring Cloud 如何实现服务注册发现？, 3. 我看你之前也用过nacos你能说下nacos与eureka的区别？, 4. 你们项目负载均衡如何实现的？, 6. nacos/Spring Cloud LoadBalancer 的负载均衡策略, 7. 如果想自定义负载均衡的策略如何实现呢, 8. 什么是服务雪崩怎么解决这个问题, 9. 你们的微服务是怎么监控的呢, 10. 你们项目中有没有做过限流？怎么做的？, 11. 限流常见的算法有哪些？, 12. 什么是CAP理论？, 13. 什么是BASE理论, 14. 为什么分布式系统中无法同时保证一致性和可用性？, 15. 你们采用哪种分布式事务解决方案？, 16. 分布式服务的接口幂等性如何设计？, 17. xxl-job路由策略有哪些？, 18. xxl-job任务执行失败怎么解决？, 19. 如果有大数据量的任务同时都需要执行怎么解决？, 五、 消息中间件, 1. RabbitMQ如何保证消息不丢失, 2. RabbitMQ消息的重复消费问题如何解决？, 3. 那你还知道其他的解决方案吗？, 4. RabbitMQ中死信交换机了解吗？（RabbitMQ延迟队列有了解过吗？）, 5. 如果有100万消息堆积在MQ如何解决？（消息堆积该如何解决）, 6. RabbitMQ的高可用机制了解吗？, 7. 如果出现数据丢失怎么解决呢, 8. Kafka怎么保证消息不丢失的呢, 9. Kafka中消息的重复消费问题如何解决？, 10. Kafka是如何保证消费的顺序性的呢, 11. Kafka的高可用机制了解吗？, 12. 解释一下复制机制中的ISR？, 13. Kafka的数据清理机制了解吗, 14. Kafka中实现高性能的设计有了解过吗？, 六、集合篇, 1. ArrayList的底层原理是什么, 2. 面试题-ArrayList list=new ArrayList(10)中的list扩容几次(少考), 3. 如何实现数组和List之间的转换（少考）, 4. 用Arrays.asList转List后如果修改了数组内容list受影响吗, 5. List用toArray转数组后如果修改了List内容数组受影响吗, 6. 面试题-ArrayList和LinkedList的区别是什么？(常考), 嗯好的刚才你说了ArrayList 和 LinkedList 不是线程安全的你们在项目中是如何解决这个的线程安全问题的？, 7. 说一下HashMap的实现原理（易考）, 8. 面试题-HashMap的put方法的具体流程, 9. 讲一讲HashMap的扩容机制, 10. HashMap的寻址方法, 11. 为什么HashMap的数组长度一定是2的次幂, 12. hashmap在1.7情况下的多线程死循环问题, 13. HashSet与HashMap的区别, 15. 说一说Java提供的常见集合？, 16. ArrayList底层是如何实现的？, 17. HashTable与HashMap的区别, 七、多线程篇（易考）, 1. 进程和线程区别, 2. 并行和并发有什么区别？, 3. 创建线程的方式有哪些（易考）, 4. runnable 和 callable 有什么区别, 5. 线程的 run()和 start()有什么区别？, 6. 线程包括了哪些状态状态之间是如何变化的, 7. 新建 T1、T2、T3 三个线程如何保证它们按顺序执行？, 8. notify()和 notifyAll()有什么区别？, 9. 在 java 中 wait 和 sleep 方法的不同？, 10. 如何停止一个正在运行的线程, 11. 讲一下synchronized关键字的底层原理？, 12. synchronized关键字的底层原理-进阶, 13. 你谈谈 JMM（Java 内存模型）, 14. 谈谈你对CAS的理解, 15. 谈谈你对volatile的理解, 16. 什么是AQS, 17. ReentrantLock的实现原理, 18. synchronized和Lock有什么区别 ? （易考）, 19. 死锁产生的条件是什么？, 20. 如何进行死锁诊断？, 21. 聊一下ConcurrentHashMap (易考), 22. 导致并发程序出现问题的根本原因是什么, 23. 项目中有没有用到线程池以及线程数是怎么设置的和拒绝策略是怎么设置的, 24. 说一下线程池的核心参数（线程池的执行原理知道嘛）（易考）, 25. 线程池中有哪些常见的阻塞队列, 26. 如何确定核心线程数, 27. 线程池的种类有哪些, 28. 为什么不建议用Executors创建线程池, 29. 线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）, 30. 如何控制某个方法允许并发访问线程的数量？, 31.谈谈你对ThreadLocal的理解（易考）, 32. 好的那你知道ThreadLocal的底层原理实现吗？, 33. 好的那关于ThreadLocal会导致内存溢出这个事情了解吗？, 34. 我看你的项目中有使用ThreadLocal谈谈你对他的理解, 八、JVM, 1. JVM由那些部分组成运行流程是什么？（易考）, 2. 什么是程序计数器？（易考）, 3. 介绍一下Java的堆, 4.  什么是虚拟机栈, 5. 垃圾回收是否涉及栈内存？, 6. 栈内存分配越大越好吗？, 7. 方法内的局部变量是否线程安全？, 8. 栈内存溢出情况, 9. 栈和堆的区别呢, 10. 能不能解释一下方法区, 11. 解释一下运行常量池, 12. 说一下 JVM 运行时数据区, 13. 你听过直接内存吗？, 14. 什么是类加载器类加载器有哪些?, 15. 什么是双亲委派模型（易考）, 16. JVM为什么采用双亲委派机制, 17. 说一下类装载的执行过程, 18. 简述Java垃圾回收机制？（GC是什么？为什么要GC）, 19. 对象什么时候可以被垃圾器回收（易考）, 20. JVM的垃圾清除算法有哪些（易考）, 21. 说一下JVM的分代回收, 22. 说一说讲一下新生代、老年代、永久代 区别相关, 23. 说一下JVM有哪些垃圾回收器（易考）, 24. 详细说一下什么是G1垃圾回收器, 25. 强引用软引用弱引用虚引用的区别, 26. JVM的调优参数可以在哪里设置, 27. JVM的调优参数都有哪些（少考）, 28. 说一下JVM的调优工具（少考）, 29. java内存泄漏的排查思路（易考）, 30. CPU飙高的排查方案与思路（易考）, 九、常见技术场景, 1. 你的单点登录模块怎么实现的呢（什么是SSO）, 2. 你的项目中权限认证如何实现的, 3. 你负责的项目中遇到哪些棘手的问题？怎么解决的, 4. 你们项目中的日志是怎么采集的求其上得其中求其中得其下求其下必败孙子兵法一我看你在项目中使用了你最近在哪些场景中使用了呢我在项目中使用缓存医生排班药品库存等热点数据通过分布式锁解决挂号并发问题确保号源分配的原子性操作的缓存在项目中的使用医生排班信息缓存将医生的排班表可预约时间段剩余号源数量等数据缓存到中设置合理的过期时间如小时当挂号员查询医生排班时优先从获取数据避免频繁查询数据库提升响应速度用户登录状态管理使用存储用户的和会话信息设置过期时间与保持一致当用户访问需要认证的接口时从中验证有效性实现快速的身份验证药品库存信息缓存将常用药品的库存数量价格规格等信息缓存到挂号员和医生查询药品信息时直接从缓存获取减少数据库压力患者挂号记录缓存将当天的挂号记录已预约号源等信息缓存到方便快速查询和更新挂号状态为什么使用分布式锁挂号并发问题当多个挂号员同时为同一医生同一时间段挂号时可能出现超卖问题比如某医生上午点只有个号源但个挂号员同时操作可能导致个患者都成功挂号造成号源超卖分布式锁的必要性使用分布式锁在挂号操作前先获取锁确保同一时间只有一个挂号员能操作该医生的号源操作完成后释放锁保证号源分配的原子性那么你是怎么解决缓存穿透的问题呢嗯我想一下缓存穿透是指查询一个一定不存在的数据由于存储层查不到数据因此不写入缓存这将导致这个不存在的数据每次请求都要到数据库去查询可能导致数据库挂掉这种情况大概率是遭到了攻击解决方案的话一般有两种方式方案一呢是采用缓存空数据的方式方案二就是采用布隆过滤器我们通常都会用布隆过滤器来解决它你能介绍一下布隆过滤器吗嗯是这样的布隆过滤器主要是用于检索一个元素是否在一个集合中我们当时使用的是实现的布隆过滤器它的底层原理是先初始化一个比较大的数组里面存放的是二进制或一开始都是当一个来了之后经过次计算模数组长度找到数据的下标然后把数组中原来的改为这样三个数组的位置就能标明一个的存在查找的过程也是一样的当然布隆过滤器有可能会产生一定的误判我们一般可以设置这个误判率大概不会超过其实这个误判是必然存在的要不就得增加数组的长度以内的误判率一般的项目也能接受不至于高并发下压倒数据库什么是缓存击穿怎么解决嗯缓存击穿的意思是对于设置了过期时间的缓存在某个时间点过期的时候恰好这个时间点对这个有大量的并发请求过来这些请求发现缓存过期一般都会从后端加载数据并回设到缓存这个时候大并发的请求可能会瞬间把压垮解决方案有两种方式第一可以使用互斥锁当缓存失效时不立即去先使用如的去设置一个互斥锁当操作成功返回时再进行的操作并回设缓存否则重试缓存的方法第二种方案是设置当前逻辑过期大概思路如下在设置的时候设置一个过期时间字段一块存入缓存中不给当前设置过期时间当查询的时候从取出数据后判断时间是否过期如果过期则开通另外一个线程进行数据同步当前线程正常返回数据这个数据可能不是最新的两种方案各有利弊如果选择数据的强一致性建议使用分布式锁的方案但性能上可能没那么高且有可能产生死锁的问题如果选择的逻辑删除则优先考虑高可用性性能比较高但数据同步这块做不到强一致什么是缓存雪崩怎么解决嗯缓存雪崩意思是设置缓存时采用了相同的过期时间导致缓存在某一时刻同时失效请求全部转发到瞬时压力过重而雪崩与缓存击穿的区别是雪崩是很多而击穿是某一个缓存解决方案主要是可以将缓存失效时间分散开比如可以在原有的失效时间基础上增加一个随机值比如分钟随机这样每一个缓存的过期时间的重复率就会降低就很难引发集体失效的事件作为缓存与数据如何进行同步呢双写一致我们当时是将医生排班信息用户的一些信息缓存到数据库这些数据实时要求性并没有这么高所以我们当时采用的是异步的方案同步数据我们当时采用的阿里的组件实现数据同步不需要更改业务代码部署一个服务服务把自己伪装成的一个从节点当数据更新以后会读取数据然后在通过的客户端获取到数据更新缓存即可作为缓存数据持久化是怎么做的在中提供了两种数据持久化的方式这两种持久化方式有什么区别呢是一个快照文件它是把内存存储的数据写到磁盘上当实例宕机恢复数据的时候可以从的快照文件中恢复数据的含义是追加文件当执行写命令的时候都会存储到这个文件中当实例宕机恢复数据的时候会从这个文件中再次执行一遍命令来恢复数据这两种方式哪种恢复的比较快呢因为是二进制文件保存时体积也比较小所以它恢复得比较快但它有可能会丢数据我们通常在项目中也会使用来恢复数据虽然恢复的速度慢一些但它丢数据的风险要小很多在文件中可以设置刷盘策略我们当时设置的就是每秒批量写入一次命令的过期策略有哪些嗯在中提供了两种数据过期删除策略第一种是惰性删除在设置该过期时间后我们不去管它当需要该时我们检查其是否过期如果过期我们就删掉它反之返回该第二种是定期删除就是说每隔一段时间我们就对一些进行检查并删除里面过期的定期清理的两种模式是模式是定时任务执行频率默认为每次不超过可以通过修改配置文件的选项来调整这个次数模式执行频率不固定每次事件循环会尝试执行但两次间隔不低于每次耗时不超过的过期删除策略是惰性删除定期删除两种策略配合使用数据淘汰策略有哪些嗯这个在中提供了很多种默认是不删除任何数据内部不足时直接报错这个可以在的配置文件中进行设置里面有两个非常重要的概念一个是另外一个是的意思就是最少最近使用它会用当前时间减去最后一次访问时间这个值越大则淘汰优先级越高的意思是最少频率使用它会统计每个的访问频率值越小淘汰优先级越高我们在项目中设置的是它会挑选最近最少使用的数据进行淘汰把一些经常访问的留在中数据库有万数据只能缓存数据如何保证中的数据都是热点数据嗯我想一下可以使用挑选最近最少使用的数据淘汰淘汰策略那留下来的都是经常访问的热点数据的内存用完了会发生什么嗯这个要看的数据淘汰策略是什么如果是默认的配置内存用完以后则直接报错我们当时设置的是策略把最近最常访问的数据留在缓存中的分布式锁是如何实现的呢我们当时使用的是来实现分布式锁在挂号业务中当多个挂号员同时为同一医生同一时间段挂号时可能会出现号源超卖的问题底层使用的是和脚本来保证原子性实现分布式锁如何合理控制锁的时长嗯的确的指令不好控制这个问题我们当时采用的是的一个框架实现的在中需要手动加锁并且可以控制锁的失效时间和等待时间当锁住的一个业务还没有执行完成的时候会引入一个看门狗机制就是说每隔一段时间就检查当前业务是否还持有锁如果持有就增加加锁的持有时间当业务执行完成之后需要使用释放锁就可以了还有一个好处就是在高并发下一个业务有可能会执行很快客户持有锁的时候客户来了以后并不会马上被拒绝它会自旋不断尝试获取锁如果客户释放之后客户就可以马上持有锁性能也得到了提升实现分布式锁是可重用的吗嗯是可以重入的这样做是为了避免死锁的产生这个重入其实在内部就是判断是否是当前线程持有的锁如果是当前线程持有的锁就会计数如果释放锁就会在计数上减一在存储数据的时候采用的结构大可以按照自己的业务进行定制其中小是当前线程的唯一标识是当前线程重入的次数可以解决主从一致的问题吗这个是不能的比如当线程加锁成功后节点数据会异步复制到节点此时如果当前持有锁的节点宕机节点被提升为新的节点假如现在来了一个线程再次加锁会在新的节点上加锁成功这个时候就会出现两个节点同时持有一把锁的问题我们可以利用提供的红锁来解决这个问题它的主要作用是不能只在一个实例上创建锁应该是在多个实例上创建锁并且要求在大多数节点上都成功创建锁红锁中要求是的节点数量要过半这样就能避免线程加锁成功后节点宕机导致线程成功加锁到新的节点上的问题了但是如果使用了红锁因为需要同时在多个节点上都添加锁性能就变得非常低并且运维维护成本也非常高所以我们一般在项目中也不会直接使用红锁并且官方也暂时废弃了这个红锁如果业务非要保证数据的强一致性这个该怎么解决呢嗯本身就是支持高可用的要做到强一致性就非常影响性能所以如果有强一致性要求高的业务建议使用实现的分布式锁它是可以保证强一致性的集群有哪些方案知道吗嗯在中提供的集群方案总共有三种主从复制哨兵模式分片集群那你来介绍一下主从同步嗯是这样的单节点的并发能力是有上限的要进一步提高的并发能力可以搭建主从集群实现读写分离一般都是一主多从主节点负责写数据从节点负责读数据主节点写入数据之后需要把数据同步到从节点中能说一下主从同步数据的流程吗嗯好主从同步分为了两个阶段一个是全量同步一个是增量同步全量同步是指从节点第一次与主节点建立连接的时候使用全量同步流程是这样的第一从节点请求主节点同步数据其中从节点会携带自己的和偏移量第二主节点判断是否是第一次请求主要判断的依据就是主节点与从节点是否是同一个如果不是就说明是第一次同步那主节点就会把自己的和发送给从节点让从节点与主节点的信息保持一致第三在同时主节点会执行生成文件后发送给从节点去执行从节点先把自己的数据清空然后执行主节点发送过来的文件这样就保持了一致当然如果在生成执行期间依然有请求到了主节点而主节点会以命令的方式记录到缓冲区缓冲区是一个日志文件最后把这个日志文件发送给从节点这样就能保证主节点与从节点完全一致了后期再同步数据的时候都是依赖于这个日志文件这个就是全量同步增量同步指的是当从节点服务重启之后数据就不一致了所以这个时候从节点会请求主节点同步数据主节点还是判断不是第一次请求不是第一次就获取从节点的值然后主节点从命令日志中获取值之后的数据发送给从节点进行数据同步怎么保证的高并发高可用首先可以搭建主从集群再加上使用中的哨兵模式哨兵模式可以实现主从集群的自动故障恢复里面就包含了对主从服务的监控自动故障恢复通知如果故障会将一个提升为当故障实例恢复后也以新的为主同时也充当客户端的服务发现来源当集群发生故障转移时会将最新信息推送给的客户端所以一般项目都会采用哨兵的模式来保证的高并发高可用你们使用是单点还是集群哪种集群嗯我们当时使用的是主从主从加哨兵一般单节点不超过内存如果内存不足则可以给不同服务分配独立的主从节点尽量不做分片集群因为集群维护起来比较麻烦并且集群之间的心跳检测和数据通信会消耗大量的网络带宽也没有办法使用脚本和事务集群脑裂该怎么解决呢嗯这个在项目中很少见不过脑裂的问题是这样的我们现在用的是的哨兵模式集群的有的时候由于网络等原因可能会出现脑裂的情况就是说由于节点和节点和处于不同的网络分区使得没有能够心跳感知到所以通过选举的方式提升了一个为这样就存在了两个就像大脑分裂了一样这样会导致客户端还在那里写入数据新节点无法同步数据当网络恢复后会将降为这时再从新同步数据这会导致中的大量数据丢失关于解决的话我记得在的配置中可以设置第一可以设置最少的节点个数比如设置至少要有一个从节点才能同步数据第二个可以设置主从数据复制和同步的延迟时间达不到要求就拒绝请求就可以避免大量的数据丢失的分片集群有什么作用分片集群主要解决的是海量数据存储的问题集群中有多个每个保存不同数据并且还可以给每个设置多个节点就可以继续增大集群的高并发能力同时每个之间通过监测彼此健康状态就类似于哨兵模式了当客户端请求可以访问集群任意节点最终都会被转发到正确节点分片集群中数据是怎么存储和读取的嗯在集群中是这样的集群引入了哈希槽的概念有个哈希槽集群中每个主节点绑定了一定范围的哈希槽范围通过校验后对取模来决定放置哪个槽通过槽找到对应的节点进行存储取值的逻辑是一样的是单线程的但是为什么还那么快嗯这个有几个原因吧完全基于内存的语言编写采用单线程避免不必要的上下文切换和竞争条件使用多路复用模型非阻塞例如和都是在后台执行操作不影响主线程的正常使用不会产生阻塞能解释一下多路复用模型简历还我嗯多路复用是指利用单个线程来同时监听多个并且在某个可读可写时得到通知从而避免无效的等待充分利用资源目前的多路复用都是采用的模式实现它会在通知用户进程就绪的同时把已就绪的写入用户空间不需要挨个遍历来判断是否就绪提升了性能其中的网络模型就是使用多路复用结合事件的处理器来应对多个请求比如提供了连接应答处理器命令回复处理器命令请求处理器在之后为了提升更好的性能在命令回复处理器使用了多线程来处理回复事件在命令请求处理器中将命令的转换使用了多线程增加命令转换速度在命令执行的时候依然是单线程二在中如何定位慢查询呢嗯我们当时在做压力测试时发现有些接口响应时间非常慢压测的结果大概是秒钟我们在中开启了慢日志查询设置的值就是秒一但的执行时间超过秒就会记录到日志中那这个语句执行很慢如何分析呢如果一条执行很慢我们通常会使用的命令来分析这条的执行情况通过和可以检查是否命中了索引如果已经添加了索引也可以判断索引是否有效通过字段可以查看是否有优化空间比如是否存在全索引扫描或全表扫描通过建议可以判断是否出现回表情况如果出现可以尝试添加索引或修改返回字段来优化那你了解过索引吗什么是索引嗯索引在项目中非常常见它是一种帮助高效获取数据的数据结构主要用来提高数据检索效率降低数据库的成本同时索引列可以对数据进行排序降低数据排序的成本也能减少的消耗索引的底层数据结构了解过吗的默认存储引擎使用的是树作为索引的存储结构选择树的原因包括节点可以有更多子节点路径更短磁盘读写代价更低非叶子节点只存储键值和指针叶子节点存储数据树适合范围查询和扫描因为叶子节点形成了一个双向链表树与树的区别是什么树的非叶子节点和叶子节点都存放数据而树的所有数据只出现在叶子节点这使得树在查询时效率更稳定树在进行范围查询时效率更高因为所有数据都在叶子节点并且叶子节点之间形成了双向链表什么是聚簇索引什么是非聚簇索引好的聚簇索引是指数据与索引放在一起树的叶子节点保存了整行数据通常只有一个聚簇索引一般是由主键构成非聚簇索引则是数据与索引分开存储树的叶子节点保存的是主键值可以有多个非聚簇索引通常我们自定义的索引都是非聚簇索引什么是回表查询呢嗯其实跟刚才介绍的聚簇索引和非聚簇索引是有关系的回表的意思就是通过二级索引找到对应的主键值然后再通过主键值找到聚集索引中所对应的整行数据这个过程就是回表备注如果面试官直接问回表则需要先介绍聚簇索引和非聚簇索引知道什么是覆盖索引吗嗯清楚的覆盖索引是指查询语句使用了索引在返回的列必须在索引中全部能够找到如果我们使用查询它会直接走聚集索引查询一次索引扫描直接返回数据性能高如果按照二级索引查询数据的时候返回的列中没有创建索引有可能会触发回表查询尽量避免使用尽量在返回的列中都包含添加索引的字段超大分页怎么处理嗯超大分页通常发生在数据量大的情况下使用分页查询且需要排序时效率较低可以通过覆盖索引和子查询来解决首先查询数据的字段进行分页然后根据列表用子查询来过滤只查询这些的数据因为查询时使用的是覆盖索引所以效率可以提升索引的创建原则有哪些嗯这个情况有很多不过都有一个大前提就是表中的数据要超过万以上我们才会创建索引并且添加索引的字段是查询比较频繁的字段一般也是像作为查询条件排序字段或分组的字段这些还有就是我们通常创建索引的时候都是使用复合索引来创建一条的返回值尽量使用覆盖索引如果字段的区分度不高的话我们也会把它放在组合索引后面的字段如果某一个字段的内容较长我们会考虑使用前缀索引来使用当然并不是所有的字段都要添加索引这个索引的数量也要控制因为添加索引也会导致新增改的速度变慢什么情况下索引会失效嗯这个情况比较多我说一些自己的经验以前遇到过的比如索引在使用的时候没有遵循最左匹配法则第二个是模糊查询如果号在前面也会导致索引失效如果在添加索引的字段上进行了运算操作或者类型转换也都会导致索引失效我们之前还遇到过一个就是如果使用了复合索引中间使用了范围查询右边的条件索引也会失效所以通常情况下想要判断出这条是否有索引失效的情况可以使用执行计划来分析谈一谈你对优化的经验面试常见候选人嗯这个在项目还是挺常见的当然如果直说优化的话我们会从这几方面考虑比如建表的时候使用索引语句的编写主从复制读写分离还有一个是如果量比较大的话可以考虑分库分表创建表的时候你们是如何优化的呢创建表时我们主要参考阿里云的开发手册选择字段类型时结合字段内容比如如果是数值的话像这些类型要根据实际情况选择如果是字符串类型也是结合存储的内容来选择和或者类型在使用索引的时候是如何优化呢在使用索引时我们遵循索引创建原则确保索引字段是查询频繁的使用复合索引覆盖返回值避免在索引字段上进行运算或类型转换以及控制索引数量你平时对语句做了哪些优化呢嗯这个也有很多比如语句务必指明字段名称不要直接使用还有就是要注意语句避免造成索引失效的写法如果是聚合查询尽量使用代替表关联时优先使用以及在必须使用或时确保小表作为驱动表事务的特征是什么可以详细说一下吗事务的特性是即原子性一致性隔离性持久性例如向转账元这个操作要么都成功要么都失败体现了原子性转账过程中数据要保持一致扣除了元必须增加元隔离性体现在向转账时不受其他事务干扰持久性体现在事务提交后数据要被持久化存储并发事务带来哪些问题并发事务可能导致脏读不可重复读和幻读脏读是指一个事务读到了另一个事务未提交的脏数据不可重复读是指在一个事务内多次读取同一数据由于其他事务的修改导致数据不一致幻读是指一个事务读取到了其他事务插入的幻行怎么解决这些问题呢的默认隔离级别是支持四种隔离级别分别有第一个是未提交读它解决不了刚才提出的所有问题一般项目中也不用这个第二个是读已提交它能解决脏读的问题的但是解决不了不可重复读和幻读第三个是可重复读它能解决脏读和不可重复读但是解决不了幻读这个也是默认的隔离级别第四个是串行化它可以解决刚才提出来的所有问题但是由于让是事务串行执行的性能比较低所以我们一般使用的都是默认的隔离级别可重复读和的区别好的其中日志记录的是数据页的物理变化服务宕机可用来同步数据而不同它主要记录的是逻辑日志当事务回滚时通过逆操作恢复原来的数据比如我们删除一条数据的时候就会在日志文件中新增一条语句如果发生回滚就执行逆操作保证了事务的持久性保证了事务的原子性和一致性事务中的隔离性是如何保障的呢请你解释一下面试常考事务的隔离性是由锁和实现的其中的意思是多版本并发控制指维护一个数据的多个版本使得读写操作没有冲突它的底层实现主要是分为了三个部分第一个是隐藏字段第二个是日志第三个是读视图隐藏字段是指在中给每个表都设置了隐藏字段有一个是事务记录每一次操作的事务是自增的另一个字段是回滚指针指向上一个版本的事务版本记录地址主要的作用是记录回滚日志存储老版本数据在内部会形成一个版本链在多个事务并行操作某一行记录记录不同事务修改数据的版本通过指针形成一个链表解决的是一个事务查询选择版本的问题在内部定义了一些匹配规则和当前的一些事务判断该访问那个版本的数据不同的隔离级别快照读是不一样的最终的访问的结果不一样如果是隔离级别每一次执行快照读时生成如果是隔离级别仅在事务中第一次执行快照读时生成后续复用简洁版事务的隔离性通过锁和多版本并发控制来保证通过维护数据的多个版本来避免读写冲突底层实现包括隐藏字段和隐藏字段包括和记录了不同版本的数据通过形成版本链定义了不同隔离级别下的快照读决定了事务访问哪个版本的数据主从复制的原理是什么主从复制的核心是二进制日志步骤如下主库在事务提交时记录数据变更到从库读取主库的并写入中继日志从库重做中继日志中的事件反映到自己的数据中你们项目用过的分库分表吗我们采用微服务架构每个微服务对应一个数据库是根据业务进行拆分的这个其实就是垂直拆分那你之前使用过水平分库吗使用过当时业务发展迅速某个表数据量超过万单库优化后性能仍然很慢因此采用了水平分库我们首先部署了台服务器和个数据库使用进行数据分片旧数据也按照取模规则迁移到了各个数据库中这样各个数据库可以分摊存储和读取压力解决了性能问题三框架篇框架中的单例是线程安全的吗不是线程安全的当多用户同时请求一个服务时容器会给每个请求分配一个线程这些线程会并发执行业务逻辑如果处理逻辑中包含对单例状态的修改比如修改单例的成员属性就必须考虑线程同步问题框架本身并不对单例进行线程安全封装线程安全和并发问题需要开发者自行处理通常在项目中使用的是不可变状态如类和类因此在某种程度上可以说的单例是线程安全的如果有多种状态如对象就需要自行保证线程安全最简单的解决办法是将单例的作用域由变更为什么是即面向切面编程在中用于将那些与业务无关但对多个对象产生影响的公共行为和逻辑抽取出来实现公共模块复用降低耦合常见的应用场景包括公共日志保存和事务处理你们项目中有没有使用到我们之前在后台管理系统中使用来记录系统操作日志主要思路是使用的环绕通知和切点表达式找到需要记录日志的方法然后通过环绕通知的参数获取请求方法的参数例如类信息方法信息注解请求方式等并将这些参数保存到数据库的事务是如何实现的实现事务的本质是利用完成的它对方法前后进行拦截在执行方法前开启事务在执行完目标方法后根据执行情况提交或回滚事务的事务失效的场景有哪些在项目中我遇到过几种导致事务失效的场景有一次我们在方法内部捕获并处理了异常没有将异常抛出会导致事务失效因此处理异常后应该确保异常能够被抛出如果方法抛出检查型异常并且没有在注解上配置属性为那么异常发生时事务可能不会回滚如果事务注解的方法不是公开修饰的也可能导致事务失效的的生命周期易考中的生命周期包括以下步骤通过获取的定义信息调用构造函数实例化进行的依赖注入例如通过方法或注解处理实现了接口的通过接口可以获取到的一些基本信息比如的名称的工厂和执行的前置处理器调用初始化方法如实现了接口或自定义的执行的后置处理器可能在这里产生代理对象最后是销毁中的循环引用问题循环依赖发生在两个或两个以上的互相持有对方形成闭环框架允许循环依赖存在并通过三级缓存解决大部分循环依赖问题一级缓存单例池缓存已完成初始化的对象二级缓存缓存尚未完成生命周期的早期对象三级缓存缓存用于创建对象你能说一说具体流程吗解决循环依赖的流程如下实例化对象并创建存入三级缓存在初始化时需要对象开始的创建逻辑实例化完成也创建存入三级缓存需要注入通过三级缓存获取生成对象存入二级缓存通过二级缓存获得对象后创建成功存入一级缓存对象初始化时由于已创建完成可以直接注入创建成功存入一级缓存清除二级缓存中的临时对象构造方法出现了循环依赖怎么解决由于构造函数是生命周期中最先执行的框架无法解决构造方法的循环依赖问题可以使用懒加载注解延迟的创建直到实际需要时的执行流程知道吗的执行流程包括以下步骤用户发送请求到前端控制器调用找到具体处理器返回处理器对象及拦截器如果有给调用处理器适配器适配并调用具体处理器在方法上添加了注解通过来返回结果转换为并且响应的自动装配原理易考的自动配置原理基于注解它封装了和是核心它通过导入配置选择器读取文件中的类名根据条件注解决定是否将配置类中的导入到容器中框架常见注解的常见注解包括声明的注解依赖注入相关注解设置作用域的注解配置相关注解相关注解的常见注解的常见注解有映射请求路径接收请求的数据指定请求参数名称从请求路径中获取参数将方法返回的对象转化为获取请求头数据等的常见注解的常见注解包括由和组成其他注解如等用于简化的配置和之间有什么区别和的区别在于它们的目标和用途不同是一个轻量级的开源框架它提供了一种简单的方式来构建企业级应用程序则是框架的延伸和扩展它提供了一种快速构建应用程序的方式开发人员可以通过使用来快速集成常用的第三方库和框架使得开发人员可以快速构建出一个可运行的应用程序请你描述一下的和和都是框架中的核心概念它们的区别在于控制反转它是一种思想主要解决程序设计中的对象依赖关系管理问题在思想中对象的创建权反转给第三方容器由容器进行对象的创建及依赖关系的管理依赖注入它是思想的具体实现方式之一用于实现在中依赖注入是指在对象创建时由容器自动将依赖对象注入到需要依赖的对象中简单来说它们的关系是是一种思想理念定义了对象创建和依赖关系处理的方式是思想的具体实现方式之一实际提供对象依赖关系的注入功能例如在框架中体现为容器承担了对象创建及依赖关系管理的控制权体现为容器通过构造方法注入方法注入等方式将依赖对象注入到需要依赖的对象中动态代理和动态代理有什么区别动态代理和动态代理都是常见的动态代理实现技术但它们有以下区别动态代理基于接口要求目标对象实现接口动态代理基于类可以代理没有实现接口的目标对象动态代理使用和来生成代理对象动态代理使用库来生成代理对象动态代理生成的代理对象是目标对象的接口实现动态代理生成的代理对象是目标对象的子类动态代理性能相对较高生成代理对象速度较快动态代理性能相对较低生成代理对象速度较慢动态代理无法代理类和方法动态代理可以代理任意类拦截器和过滤器有什么区别拦截器和过滤器的区别主要体现在以下点出身不同过滤器来自于而拦截器来自于框架触发时机不同请求的执行顺序是请求进入容器进入过滤器进入进入拦截器执行控制器所以过滤器和拦截器的执行时机是过滤器会先执行然后才会执行拦截器最后才会进入真正的要调用的方法底层实现不同过滤器是基于方法回调实现的拦截器是基于动态代理底层是反射实现的支持的项目类型不同过滤器是规范中定义的所以过滤器要依赖容器它只能用在项目中而拦截器是中的一个组件因此拦截器既可以用在项目中同时还可以用在或程序中使用的场景不同因为拦截器更接近业务系统所以拦截器主要用来实现项目中的业务判断的比如登录判断权限判断日志记录等业务而过滤器通常是用来实现通用功能过滤的比如敏感词过滤字符集编码设置响应数据压缩等功能和有什么不同和都是用来实现依赖注入的注解在项目中但二者却有着点不同来源不同来自框架而来自于依赖查找的顺序不同先根据类型再根据名称查询而先根据名称再根据类型查询支持的参数不同只支持设置个参数而支持设置个参数依赖注入的用法支持不同既支持构造方法注入又支持属性注入和注入而只支持属性注入和注入编译器的提示不同当注入对象时使用注解编译器会提示错误而使用注解则不会提示错误的执行流程是什么的执行流程如下读取配置文件构造会话工厂会话工厂创建对象操作数据库的接口执行器执行方法中的参数输入参数映射输出结果映射是否支持延迟加载支持延迟加载即在需要用到数据时才加载可以通过配置文件中的配置启用或禁用延迟加载延迟加载的底层原理知道吗延迟加载的底层原理主要使用动态代理实现使用创建目标对象的代理对象调用目标方法时如果发现是值则执行查询获取数据后设置属性值并继续查询目标方法的一级二级缓存用过吗的一级缓存是基于的本地缓存作用域为默认开启二级缓存需要单独开启作用域为或默认也是采用存储四微服务的五大组件是什么在早期的五大组件通常指的是服务注册中心客户端负载均衡器声明式的服务调用服务熔断器网关随着的兴起我们项目中也融入了一些阿里巴巴的技术组件服务注册与配置中心负载均衡服务调用服务保护网关服务注册和发现是什么意思如何实现服务注册发现服务注册与发现主要包含三个核心功能服务注册服务发现和服务状态监控我们项目中采用了作为服务注册中心它是一个集服务发现配置管理于一体的中间件服务注册服务提供者在启动时会将自己的信息如服务名称端口权重等注册到服务器服务发现服务消费者通过客户端从注册中心获取目标服务的可用实例列表并基于内置的负载均衡策略选择合适的服务实例进行调用服务监控服务提供者会定期向发送心跳以维持服务实例的健康状态通过心跳检测和健康检查机制实时感知服务实例的存活状态当实例异常时会及时将其从服务列表中移除确保服务调用的准确性我看你之前也用过你能说下与的区别在使用作为注册中心的项目中我注意到与的共同点和区别共同点两者都支持服务注册与发现以及心跳检测作为健康检查机制区别支持服务端主动检测服务提供者状态而依赖客户端心跳区分临时实例和非临时实例采用不同的健康检查策略支持服务列表变更的消息推送使服务更新更及时集群默认采用模式但在存在非临时实例时会采用模式而始终采用模式你们项目负载均衡如何实现的服务注册与元数据管理所有服务实例启动时会自动注册到注册中心同时上报自身的元数据包括端口权重健康状态等信息负载均衡组件集成服务消费者端集成了作为负载均衡客户端它会通过客户端实时获取目标服务的可用实例列表策略选择与调用默认采用轮询策略分发请求确保各实例负载相对均衡针对不同业务场景我们还做了策略扩展对性能差异较大的实例通过控制台配置权重策略让高性能实例承担更多流量对有会话保持需求的模块如用户中心采用哈希策略确保会话一致性核心业务服务启用了最少并发策略优先调用负载较低的实例动态调整机制当服务实例发生扩缩容权重变更或健康状态变化时会实时推送最新实例列表给客户端负载均衡组件会自动感知并调整路由决策无需人工干预的负载均衡策略轮询策略默认按照服务实例的顺序依次进行调用每个实例被调用的机会均等适用于各实例性能相近的场景权重策略可以为不同的服务实例设置不同的权重值权重越高的实例被选中的概率越大通过控制台可动态调整权重便于在实例性能有差异时进行流量分配如给性能好的实例分配更高权重随机策略从可用的服务实例中随机选择一个进行调用适用于对调用顺序无要求的场景最少并发策略优先选择当前并发量最低的服务实例可避免请求集中到负载较高的实例上提高系统整体吞吐量哈希策略根据请求来源的地址进行哈希计算将同一的请求固定路由到同一个服务实例适用于需要会话保持的场景如果想自定义负载均衡的策略如何实现呢全局策略实现接口在逻辑中通过客户端获取服务实例列表及元数据自定义选择规则后通过配置类将其注册为默认特定服务策略通过注解指定服务名和对应的配置类在配置类中定义该服务专属的负载均衡器同样可以结合的实例元数据如在控制台配置的权重扩展信息来实现策略这样只会对该服务生效什么是服务雪崩怎么解决这个问题服务雪崩是指一个服务的失败导致整个链路的服务相继失败我们通常通过服务降级和服务熔断来解决这个问题服务降级服务自我保护的一种方式或者保护下游服务的一种方式用于确保服务不会受请求突增影响变得不可用确保服务不会崩溃一般在实际开发中与接口整合编写降级逻辑服务熔断默认关闭需要手动打开如果检测到秒内请求的失败率超过就触发熔断机制之后每隔秒重新尝试请求微服务如果微服务不能响应继续走熔断机制如果微服务可达则关闭熔断机制恢复正常请求你们的微服务是怎么监控的呢我们项目中采用了进行微服务监控能够监控接口服务和物理实例的状态帮助我们识别和优化慢服务我们还设置了告警规则一旦检测到异常系统会通过短信或邮件通知相关负责人你们项目中有没有做过限流怎么做的在我们的项目中由于面临可能的突发流量我们采用了网关限流策略过滤器进行限流采用令牌桶算法可以基于或路径进行限流限流常见的算法有哪些漏桶算法漏桶算法的实现思路是有一个固定容量的漏桶水流请求可以按照任意速率先进入到漏桶里但漏桶总是以固定的速率匀速流出当流入量过大的时候超过桶的容量则多余水流请求直接溢出令牌桶算法令牌按固定的速率被放入令牌桶中桶中最多存放个令牌当桶装满时新添加的令牌被丢弃或拒绝当请求到达时将从桶中删除个令牌令牌桶中的令牌不仅可以被移除还可以往里添加所以为了保证接口随时有数据通过必须不停地往桶里加令牌由此可见往桶里加令牌的速度就决定了数据通过接口的速度我们通过控制往令牌桶里加令牌的速度从而控制接口的流量区别漏桶算法是按照常量固定速率流出请求的流入请求速率任意当流入的请求数累积到漏桶容量时新流入的请求被拒绝令牌桶算法是按照固定速率往桶中添加令牌的请求是否被处理需要看桶中的令牌是否足够当令牌数减为零时拒绝新的请求令牌桶算法允许突发请求只要有令牌就可以处理允许一定程度的突发流量漏桶算法限制的是常量流出速率从而使突发流入速率平滑比如服务器空闲时理论上使用漏桶算法服务器可以直接处理一次洪峰一次洪水过程的最大流量但是漏桶算法处理请求的速率是恒定的因此前期服务器资源只能根据恒定的漏水速度逐步处理请求无法直接处理这次洪峰而使用令牌桶算法就不存在这个问题因为它可以先把令牌桶一次性装满处理一次洪峰之后再走限流什么是理论理论是分布式系统设计的基础理论包含一致性可用性和分区容错性在网络分区发生时系统只能在一致性和可用性之间选择其一什么是理论理论是分布式系统设计中对理论中方案的延伸强调通过基本可用软状态和最终一致性来实现系统设计为什么分布式系统中无法同时保证一致性和可用性在分布式系统中为了保证分区容错性我们通常需要在一致性和可用性之间做出选择如果系统优先保证一致性可能需要牺牲可用性反之亦然你们采用哪种分布式事务解决方案我们项目中使用了的模式来解决分布式事务问题模式通过记录业务数据的变更日志来保证事务的最终一致性分布式服务的接口幂等性如何设计我们通过和来实现接口幂等性用户操作时系统生成一个并存储在中当用户提交操作时系统会验证的存在性并在验证通过后删除确保每个只被处理一次路由策略有哪些支持多种路由策略包括轮询故障转移和分片广播等任务执行失败怎么解决面对任务执行失败我们可以选择故障转移路由策略优先使用健康的实例执行任务设置任务重试次数通过日志记录和邮件告警通知相关负责人如果有大数据量的任务同时都需要执行怎么解决我们可以通过部署多个实例并使用分片广播路由策略来分散任务负载在任务执行代码中根据分片信息和总数对任务进行分配五消息中间件如何保证消息不丢失我们使用来确保和间数据双写的一致性这要求我们实现消息的高可用性具体措施包括开启生产者确认机制确保消息能被送达队列如有错误则记录日志并修复数据启用持久化功能保证消息在未消费前不会在队列中丢失需要对交换机队列和消息本身都进行持久化对消费者开启自动确认机制由确认消息处理成功后完成并设置重试次数例如我们设置了次重试若失败则将消息发送至异常交换机由人工处理消息的重复消费问题如何解决嗯这个我们还真遇到过是这样的我们当时消费者是设置了自动确认机制当服务还没来得及给确认的时候服务宕机了导致服务重启之后又消费了一次消息这样就重复消费了因为我们当时处理的支付订单业务唯一标识它有一个业务的唯一标识我们再处理消息时先到数据库查询一下这个数据是否存在如果不存在说明没有处理过这个时候就可以正常处理这个消息了如果已经存在这个数据了就说明消息重复消费了我们就不需要再消费了那你还知道其他的解决方案吗是的这属于幂等性问题可以通过以下方法解决使用分布式锁或数据库锁来确保操作的幂等性中死信交换机了解吗延迟队列有了解过吗嗯了解过我们当时的项目有一个业务需要用到延迟队列其中就是使用来实现的延迟队列就是用到了死信交换机和消息存活时间实现的如果消息超时未消费就会变成死信在中如果消息成为死信队列可以绑定一个死信交换机在死信交换机上可以绑定其他队列在我们发消息的时候可以按照需求指定的时间这样就实现了延迟队列的功能了入我记得还有一种方式可以实现延迟队列在中安装一个死信插件这样更方便一些我们只需要在声明交互机的时候指定这个就是死信交换机然后在发送消息的时候直接指定超时时间就行了相对于死信交换机要省略了一些步骤如果有万消息堆积在如何解决消息堆积该如何解决我在实际的开发中没遇到过这种情况不过如果发生了堆积的问题解决方案也所有很多的第一提高消费者的消费能力可以使用多线程消费任务第二增加更多消费者提高消费速度使用工作队列模式设置多个消费者消费消费同一个队列中的消息第三扩大队列容积提高堆积上限可以使用惰性队列惰性队列的好处主要是接收到消息后直接存入磁盘而非内存消费者要消费消息时才会从磁盘中读取并加载到内存支持数百万条的消息存储的高可用机制了解吗嗯熟悉的我们当时项目在生产环境下使用的集群当时搭建是镜像模式集群使用了台机器镜像队列结构是一主多从所有操作都是主节点完成然后同步给镜像节点如果主节点宕机后镜像节点会替代成新的主节点不过在主从同步完成前主节点就已经宕机可能出现数据丢失如果出现数据丢失怎么解决呢我们可以采用仲裁队列与镜像队列一样都是主从模式支持主从数据同步主从同步基于协议强一致并且使用起来也非常简单不需要额外的配置在声明队列的时候只要指定这个是仲裁队列即可怎么保证消息不丢失的呢嗯这个保证机制很多在发送消息到消费者接收消息在每个阶段都有可能会丢失消息所以我们解决的话也是从多个方面考虑第一个是生产者发送消息的时候可以使用异步回调发送如果消息发送失败我们可以通过回调获取失败后的消息信息可以考虑重试或记录日志后边再做补偿都是可以的同时在生产者这边还可以设置消息重试有的时候是由于网络抖动的原因导致发送不成功就可以使用重试机制来解决第二个在中消息有可能会丢失我们可以通过的复制机制来确保消息不丢失在生产者发送消息的时候可以设置一个就是确认机制我们可以设置参数为这样的话当生产者发送消息到了分区之后不仅仅只在分区保存确认在分区也会保存确认只有当所有的副本都保存确认以后才算是成功发送了消息所以这样设置就很大程度了保证了消息不会在丢失第三个有可能是在消费者端丢失消息消费消息都是按照进行标记消费的消费者默认是自动按期提交已经消费的偏移量默认是每隔提交一次如果出现重平衡的情况可能会重复消费或丢失数据我们一般都会禁用掉自动提价偏移量改为手动提交当消费成功以后再报告给消费的位置这样就可以避免消息丢失和重复消费了中消息的重复消费问题如何解决消费消息都是按照进行标记消费的消费者默认是自动按期提交已经消费的偏移量默认是每隔提交一次如果出现重平衡的情况可能会重复消费或丢失数据我们一般都会禁用掉自动提价偏移量改为手动提交当消费成功以后再报告给消费的位置这样就可以避免消息丢失和重复消费了是如何保证消费的顺序性的呢默认存储和消费消息是不能保证顺序性的因为一个数据可能存储在不同的分区中每个分区都有一个按照顺序的存储的偏移量如果消费者关联了多个分区不能保证顺序性如果有这样的需求的话我们是可以解决的把消息都存储同一个分区下就行了有两种方式都可以进行设置第一个是发送消息时指定分区号第二个是发送消息时按照相同的业务设置相同的因为默认情况下分区也是通过的值来选择分区的值如果一样的话分区肯定也是一样的的高可用机制了解吗嗯主要是有两个层面第一个是集群第二个是提供了复制机制集群指的是由多个实例组成即使某一台宕机也不耽误其他继续对外提供服务复制机制是可以保证的高可用的一个有多个分区每个分区有多个副本有一个其余的是副本存储在不同的中所有的分区副本的内容是都是相同的如果发生故障时会自动将其中一个提升为保证了系统的容错性高可用性解释一下复制机制中的的意思是就是需要同步复制保存的其中分区副本有很多的分为了两类一个是与副本同步保存数据另外一个普通的副本是异步同步数据当挂掉之后会优先从副本列表中选取一个作为因为是同步保存数据数据更加的完整一些所以优先选择副本列表的数据清理机制了解吗嗯了解过中的数据存储在分区上分区如果文件过大会分段存储每个分段都在磁盘上以索引和日志文件的形式存储这样分段的好处是第一能够减少单个文件内容的大小查找数据方便第二方便进行日志清理在中提供了两个日志的清理策略第一根据消息的保留时间当消息保存的时间超过了指定的时间就会触发清理默认是小时天第二是根据存储的数据大小当所占的日志文件大小大于一定的阈值则开始删除最久的消息这个默认是关闭的这两个策略都可以通过的中的配置文件进行设置中实现高性能的设计有了解过吗高性能是多方面协同的结果包括宏观架构分布式存储数据同步以及高效的利用磁盘操作系统特性等主要体现有这么几点消息分区不受单台服务器的限制可以不受限的处理更多的数据顺序读写磁盘顺序读写提升读写效率页缓存把磁盘中的数据缓存到内存中把对磁盘的访问变为对内存的访问零拷贝减少上下文切换及数据拷贝消息压缩减少磁盘和网络分批发送将消息打包批量发送减少网络开销六集合篇的底层原理是什么底层是用动态的数组实现的初始容量为当第一次添加数据的时候才会初始化容量为在进行扩容的时候是原来容量的倍每次扩容都需要拷贝数组在添加数据的时候确保数组已使用长度加之后足够存下下一个数据计算数组的容量如果当前数组已使用长度后的大于当前的数组长度则调用方法扩容原来的倍确保新增的数据有地方存储之后则将新元素添加到位于的位置上返回添加成功布尔值面试题中的扩容几次少考该语句只是声明和实例了一个指定了容量为未扩容如何实现数组和之间的转换少考数组转使用中工具类的方法转数组使用的方法无参方法返回数组传入初始化长度的数组对象返回该对象数组用转后如果修改了数组内容受影响吗转换之后如果修改了数组的内容会受影响因为它的底层使用的类中的一个内部类来构造的集合在这个集合的构造器中把我们传入的这个数组进行了包装而已最终指向的都是同一个内存地址用转数组后如果修改了内容数组受影响吗用了转数组后如果修改了内容数组不会影响当调用了以后在底层是它是进行了数组的拷贝跟原来的元素就没啥关系了所以即使修改了以后数组也不受影响面试题和的区别是什么常考底层数据结构是动态数组的数据结构实现是双向链表的数据结构实现操作数据效率按照下标查询的时间复杂度内存是连续的根据寻址公式不支持下标查询查找未知索引需要遍历链表也需要遍历时间复杂度都是新增和删除尾部插入和删除时间复杂度是其他部分增删需要挪动数组时间复杂度是头尾节点增删时间复杂度是其他都需要遍历链表时间复杂度是内存空间占用底层是数组内存连续节省内存是双向链表需要存储数据和两个指针更占用内存线程安全和都不是线程安全的如果需要保证线程安全有两种方案在方法内使用局部变量则是线程安全的使用线程安全的和嗯好的刚才你说了和不是线程安全的你们在项目中是如何解决这个的线程安全问题的嗯是这样的主要有两种解决方案第一我们使用这个集合优先在方法内使用定义为局部变量这样的话就不会出现线程安全问题第二如果非要在成员变量中使用的话可以使用线程安全的集合来替代可以通过的方法将转换成线程安全的容器后再使用换成来使用说一下的实现原理易考的数据结构底层使用表数据结构即数组和链表或红黑树当我们往中元素时利用的重新计算出当前对象的元素在数组中的下标存储时如果出现值相同的此时有两种情况如果相同则覆盖原始值如果不同出现冲突则将当前的放入链表或红黑树中获取时直接找到值对应的下标在进一步判断是否相同从而找到对应值面试题的方法的具体流程判断键值对数组是否为空或为否则执行进行扩容初始化根据键值计算值得到数组索引判断条件成立直接新建节点添加如果不成立判断的首个元素是否和一样如果相同直接覆盖判断是否为即是否是红黑树如果是红黑树则直接在树中插入键值对遍历链表的尾部插入数据然后判断链表长度是否大于大于的话把链表转换为红黑树在红黑树中执行插入操作遍历过程中若发现已经存在直接覆盖插入成功后判断实际存在的键值对数量是否超多了最大容量数组长度如果超过进行扩容讲一讲的扩容机制在添加元素或初始化的时候需要调用方法进行扩容第一次添加数据初始化数组长度为以后每次每次扩容都是达到了扩容阈值数组长度每次扩容的时候都是扩容之前容量的倍扩容之后会新创建一个数组需要把老数组中的数据挪动到新的数组中没有冲突的节点则直接使用计算新数组的索引位置如果是红黑树走红黑树的添加如果是链表则需要遍历链表可能需要拆分链表判断是否为该元素的位置要么停留在原始位置要么移动到原始位置增加的数组大小这个位置上的寻址方法计算对象的再进行调用方法进行二次哈希值右移位再异或运算让哈希分布更为均匀最后得到索引为什么的数组长度一定是的次幂嗯好的这么设计主要有两个原因第一计算索引时效率更高如果是的次幂可以使用位与运算代替取模第二扩容时重新计算索引效率更高在进行扩容时会进行判断值按位与运算旧数组长租是否如果等于则把元素留在原来位置否则新位置是等于旧位置的下标旧数组长度在情况下的多线程死循环问题在的中在数组进行扩容的时候因为链表是头插法在进行数据迁移的过程中有可能导致死循环比如说现在有两个线程线程一读取到当前的数据数据中一个链表在准备扩容时线程二介入线程二也读取直接进行扩容因为是头插法链表的顺序会进行颠倒过来比如原来的顺序是扩容后的顺序是线程二执行结束线程一继续执行的时候就会出现死循环的问题线程一先将移入新的链表再将插入到链头由于另外一个线程的原因的指向了所以形成循环当然将扩容算法做了调整不再将元素加入链表头而是保持与扩容前一样的顺序尾插法就避免了中死循环的问题与的区别实现了接口仅存储对象实现了接口存储的是键值对底层其实是用实现存储的封装了一系列的方法依靠来存储元素值利用的键进行存储而值默认为对象所以也不允许出现重复值判断标准和判断标准相同两个元素的相等并且通过方法返回说一说提供的常见集合在中提供了两大类的集合框架主要分为两类第一个是属于单列集合第二个是属于双列集合在中有两个子接口和在我们平常开发的过程中用的比较多像接口中的实现类和在接口中有实现类和在接口中有很多的实现类平时比较常见的是还有一个线程安全的底层是如何实现的嗯我阅读过的源码我主要说一下方法吧第一确保数组已使用长度加之后足够存下下一个数据第二计算数组的容量如果当前数组已使用长度后的大于当前的数组长度则调用方法扩容原来的倍第三确保新增的数据有地方存储之后则将新元素添加到位于的位置上第四返回添加成功布尔值与的区别嗯他们的主要区别是有几个吧第一数据结构不一样是数组链表在之后改为了数组链表红黑树第二存储数据的时候都不能为而是可以的第三算法不同是用本地修饰的值而经常了二次第四扩容方式不同是当前容量翻倍是当前容量翻倍第五是线程安全的操作数据的时候加了锁不是线程安全的效率更高一些在实际开中不建议使用在多线程环境下可以使用类七多线程篇易考进程和线程区别进程是正在运行程序的实例进程中包含了线程每个线程执行不同的任务不同的进程使用不同的内存空间在当前进程下的所有线程可以共享内存空间线程更轻量线程上下文切换成本一般上要比进程上下文切换低上下文切换指的是从一个线程切换到另一个线程并行和并发有什么区别现在都是多核在多核下并发是同一时间应对多件事情的能力多个线程轮流使用一个或多个并行是同一时间动手做多件事情的能力核同时执行个线程创建线程的方式有哪些易考在中一共有四种常见的创建方式分别是继承类实现接口实现接口线程池创建线程通常情况下我们项目中都会采用线程池的方式创建线程和有什么区别接口方法没有返回值接口方法有返回值是个泛型和配合可以用来获取异步执行的结果接口支持返回执行结果需要调用得到此方法会阻塞主进程的继续往下执行如果不调用不会阻塞接口的方法允许抛出异常而接口的方法的异常只能在内部消化不能继续上抛线程的和有什么区别用来启动线程通过该线程调用方法执行方法中所定义的逻辑代码方法只能被调用一次封装了要被线程执行的代码可以被调用多次线程包括了哪些状态状态之间是如何变化的在中的类中的枚举里面定义了中线程的状态分别是新建可运行终结阻塞等待和有时限等待六种关于线程的状态切换情况比较多我分别介绍一下当一个线程对象被创建但还未调用方法时处于新建状态调用了方法就会由新建进入可运行状态如果线程内代码已经执行完毕由可运行进入终结状态当然这些是一个线程正常执行情况如果线程获取锁失败后由可运行进入的阻塞队列阻塞只有当持锁线程释放锁时会按照一定规则唤醒阻塞队列中的阻塞线程唤醒后的线程进入可运行状态如果线程获取锁成功后但由于条件不满足调用了方法此时从可运行状态释放锁等待状态当其它持锁线程调用或方法会恢复为可运行状态还有一种情况是调用方法也会从可运行状态进入有时限等待状态不需要主动唤醒超时时间到自然恢复为可运行状态新建三个线程如何保证它们按顺序执行嗯我思考一下适当的思考或想一下属于正常情况脱口而出反而太假背诵痕迹可以这么做在多线程中有多种方法让线程按特定顺序执行可以用线程类的方法在一个线程中启动另一个线程另外一个线程完成该线程继续执行比如说使用方法调用调用这样就能确保就会先完成而最后完成和有什么区别唤醒所有的线程只随机唤醒一个线程在中和方法的不同共同点和的效果都是让当前线程暂时放弃的使用权进入阻塞状态不同点方法归属不同是的静态方法而都是的成员方法每个对象都有醒来时机不同执行和的线程都会在等待相应毫秒后醒来和还可以被唤醒如果不唤醒就一直等下去它们都可以被打断唤醒锁特性不同重点方法的调用必须先获取对象的锁而则无此限制方法执行后会释放对象锁允许其它线程获得该对象锁我放弃但你们还可以用而如果在代码块中执行并不会释放对象锁我放弃你们也用不了如何停止一个正在运行的线程有三种方式可以停止线程使用退出标志使线程正常退出也就是当方法完成后线程终止使用方法强行终止不推荐方法已作废使用方法中断线程讲一下关键字的底层原理底层使用的级别中的来决定当前线程是否获得了锁如果某一个线程获得了锁在没有释放锁之前其他线程是不能或得到锁的属于悲观锁因为需要依赖于级别的相对性能也比较低对象存在于每个对象的对象头中锁便是通过这种方式获取锁的也是为什么中任意对象可以作为锁的原因内部维护了三个变量保存处于状态的线程保存处于状态的线程持有锁的线程只有一个线程获取到的标志就是在中设置成功了一个中只能有一个在上锁的过程中如果有其他线程也来抢锁则进入进行阻塞当获得锁的线程执行完了释放了锁就会唤醒中等待的线程竞争锁竞争的时候是非公平的关键字的底层原理进阶中的有偏向锁轻量级锁重量级锁三种形式分别对应了锁只被一个线程持有不同线程交替持有锁多线程竞争锁三种情况重量级锁底层使用的实现里面涉及到了用户态和内核态的切换进程的上下文切换成本较高性能比较低轻量级锁线程加锁的时间是错开的也就是没有竞争可以使用轻量级锁来优化轻量级修改了对象头的锁标志相对重量级锁性能提升很多每次修改都是操作保证原子性偏向锁一段很长的时间内都只被一个线程使用锁可以使用了偏向锁在第一次获得锁时会有一个操作之后该线程再获取锁只需要判断中是否是自己的线程即可而不是开销相对较大的命令一旦锁发生了竞争都会升级为重量级锁你谈谈内存模型内存模型是虚拟机规范中定义的一种非常重要的内存模型它的主要作用是描述程序中线程共享变量的访问规则以及这些变量在中是如何被存储和读取的涉及到一些底层的细节这个模型有几个核心的特点首先所有的共享变量包括实例变量和类变量都被存储在主内存中也就是计算机的需要注意的是局部变量并不包含在内因为它们是线程私有的所以不存在竞争问题其次每个线程都有自己的工作内存这里保留了线程所使用的变量的工作副本这意味着线程对变量的所有操作无论是读还是写都必须在自己的工作内存中完成而不能直接读写主内存中的变量最后不同线程之间不能直接访问对方工作内存中的变量如果线程间需要传递变量的值那么这个过程必须通过主内存来完成谈谈你对的理解的全称是比较再交换它体现的一种乐观锁的思想在无锁状态下保证线程操作数据的原子性使用到的地方很多框架类在操作共享变量的时候使用的自旋锁效率上更高一些的底层是调用的类中的方法都是操作系统提供的其他语言实现谈谈你对的理解是一个关键字可以修饰类的成员变量类的静态成员变量主要有两个功能第一保证了不同线程对这个变量进行操作时的可见性即一个线程修改了某个变量的值这新值对其他线程来说是立即可见的关键字会强制将修改的值立即写入主存第二禁止进行指令重排序可以保证代码执行有序性底层实现原理是添加了一个内存屏障通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化什么是的话其实就一个提供的类是阻塞式锁和相关的同步器工具的框架内部有一个属性属性来表示资源的状态默认等于表示没有获取锁等于的时候才标明获取到了锁通过机制设置状态在它的内部还提供了基于的等待队列是一个双向列表其中指向队列最后一个元素指向队列中最久的一个元素其中我们刚刚聊的底层的实现就是一个的实现原理是一个可重入锁调用方法获取了锁之后再次调用是不会再阻塞内部直接增加重入次数就行了标识这个线程已经重复获取一把锁而不需要等待锁的释放是属于报下的类属于层面的锁跟一样都是悲观锁通过用来获取锁释放锁它的底层实现原理主要利用队列来实现它支持公平锁和非公平锁两者的实现类似构造方法接受一个可选的公平参数默认非公平锁当设置为时表示公平锁否则为非公平锁公平锁的效率往往没有非公平锁的效率高和有什么区别易考第一语法层面是关键字源码在中用语言实现退出同步代码块锁会自动释放是接口源码由提供用语言实现需要手动调用方法释放锁第二功能层面二者均属于悲观锁都具备基本的互斥同步锁重入功能提供了许多不具备的功能例如获取等待状态公平锁可打断可超时多条件变量同时可以实现不同的场景如第三性能层面在没有竞争时做了很多优化如偏向锁轻量级锁性能不赖在竞争激烈时的实现通常会提供更好的性能统合来看需要根据不同的场景来选择不同的锁的使用死锁产生的条件是什么嗯是这样的一个线程需要同时获取多把锁这时就容易发生死锁举个例子来说线程获得对象锁接下来想获取对象的锁线程获得对象锁接下来想获取对象的锁这个时候线程和线程都在互相等待对方的锁就产生了死锁如何进行死锁诊断我们只需要通过自动的工具就能搞定我们可以先通过来查看当前程序运行的进程然后通过来查看这个进程就能展示出来死锁的问题并且可以定位代码的具体行号范围我们再去找到对应的代码进行排查就行了聊一下易考是一种线程安全的高效集合和也做了很多调整的底层采用是分段的数组链表实现采用的数据结构跟的结构一样数组链表红黑二叉树在中里包含一个数组的结构和类似是一种数组和链表结构一个包含一个数组每个是一个链表结构的元素每个守护着一个数组里的元素当对数组的数据进行修改时必须首先获得对应的的锁是一种可重入的锁每个守护一个数组里得元素当对数组的数据进行修改时必须首先获得对应的锁在中的做了较大的优化性能提升了不少首先是它的数据结构与的数据结构完全一致其次是放弃了臃肿的设计取而代之的是采用来保证并发安全进行实现只锁定当前链表或红黑二叉树的首节点这样只要不冲突就不会产生并发效率得到提升导致并发程序出现问题的根本原因是什么并发编程有三大核心特性分别是原子性可见性和有序性首先原子性指的是一个线程在中的操作是不可暂停也不可中断的要么执行完成要么不执行比如一些简单的操作如赋值可能是原子的但复合操作如自增就不是原子的为了保证原子性我们可以使用关键字或里面的来进行加锁其次可见性是指让一个线程对共享变量的修改对另一个线程可见由于线程可能在自己的工作内存中缓存共享变量的副本因此一个线程对共享变量的修改可能不会立即反映在其他线程的工作内存中为了解决这个问题我们可以使用关键字关键字或来确保可见性最后有序性是指处理器为了提高程序运行效率可能会对输入代码进行优化导致程序中各个语句的执行先后顺序与代码中的顺序不一致虽然处理器会保证程序最终执行结果与代码顺序执行的结果一致但在某些情况下我们可能需要确保特定的执行顺序为了解决这个问题我们可以使用关键字来禁止指令重排项目中有没有用到线程池以及线程数是怎么设置的和拒绝策略是怎么设置的线程池的使用场景我们当时在项目中确实使用了线程池主要用于异步处理大模型的请求因为接口的响应时间比较长如果使用同步调用会阻塞主线程所以我们使用线程池来处理这些异步任务线程池配置我们创建了一个自定义的线程池核心线程数设置为最大线程数设置为队列容量设置为这样配置是因为请求不是特别频繁但单个请求耗时较长所以需要足够的线程来处理并发请求线程数设置原则我们按照密集型任务来设置线程数因为请求主要是网络和计算密集型操作考虑到我们的服务器是核我们设置核心线程数为最大线程数为这样可以充分利用资源同时避免创建过多线程导致上下文切换开销拒绝策略设置我们使用了作为拒绝策略当线程池和队列都满了时新任务会由调用线程来执行这样虽然会阻塞调用线程但能保证任务不会丢失对于请求这种重要业务来说是比较合适的选择实际效果使用线程池后接口的响应时间从原来的秒降低到秒用户体验得到了显著提升同时系统的并发处理能力也得到了增强能够支持更多的用户同时使用功能说一下线程池的核心参数线程池的执行原理知道嘛易考在线程池中一共有个核心参数核心线程数目池中会保留的最多线程数最大线程数目核心线程救急线程的最大数目生存时间救急线程的生存时间生存时间内没有新任务此线程资源会释放时间单位救急线程的生存时间单位如秒毫秒等当没有空闲核心线程时新来任务会加入到此队列排队队列满会创建救急线程执行任务线程工厂可以定制线程对象的创建例如设置线程名字是否是守护线程等拒绝策略当所有线程都在繁忙也放满时会触发拒绝策略拒绝策略有种当线程数过多以后第一种是抛异常第二种是由调用者执行任务第三是丢弃当前的任务第四是丢弃最早排队任务默认是直接抛异常线程池中有哪些常见的阻塞队列中提供了很多阻塞队列开发中常见的有两个和和是中两种常见的阻塞队列它们在实现和使用上有一些关键的区别首先是一个有界队列它在创建时必须指定容量并且这个容量不能改变而默认是无界的但也可以在创建时指定最大容量使其变为有界队列其次它们在内部数据结构上也有所不同是基于数组实现的而则是基于链表实现的这意味着在访问元素时可能会更快因为它可以直接通过索引访问数组中的元素而则在添加和删除元素时可能更快因为它不需要移动其他元素来填充空间另外它们在加锁机制上也有所不同使用一把锁来控制对队列的访问这意味着读写操作都是互斥的而则使用两把锁一把用于控制读操作另一把用于控制写操作这样可以提高并发性能如何确定核心线程数高并发任务执行时间短核数减少线程上下文的切换并发不高任务执行时间长密集型的任务核数计算密集型任务核数并发高业务执行时间长解决这种类型任务的关键不在于线程池而在于整体架构的设计看看这些业务里面某些数据是否能做缓存是第一步增加服务器是第二步至于线程池的设置参考核数线程池的种类有哪些在中默认提供了中方式创建线程池第一个是创建一个可缓存线程池如果线程池长度超过处理需要可灵活回收空闲线程若无可回收则新建线程第二个是创建一个定长线程池可控制线程最大并发数超出的线程会在队列中等待第三个是创建一个定长线程池支持定时及周期性任务执行第四个是创建一个单线程化的线程池它只会用唯一的工作线程来执行任务保证所有任务按照指定顺序优先级执行为什么不建议用创建线程池其实这个事情在阿里提供的最新开发手册开发手册嵩山版中也提到了主要原因是如果使用创建线程池的话它允许的请求队列默认长度是这样的话有可能导致堆积大量的请求从而导致内存溢出所以我们一般推荐使用来创建线程池这样可以明确规定线程池的参数避免资源的耗尽线程池使用场景你们项目哪里用到了多线程我们当时在项目中主要在两个地方使用了多线程一个是大模型请求的异步处理另一个是批量数据导入的并行处理我们使用来处理请求的异步结果比如医生提交病历分析请求后我们返回一个对象前端可以轮询这个来获取处理结果当分析完成后我们会将结果存储到缓存中前端通过轮询获取到最终结果当管理员需要导入大量患者数据时我们会将数据分批处理每批数据使用一个线程来处理最后使用等待所有批次处理完成这样既提升了处理速度又保证了数据的一致性我们创建了一个异步服务类使用注解标记异步方法返回类型在调用时我们可以通过方法获取结果或者使用回调函数处理结果大大改善了用户体验感如何控制某个方法允许并发访问线程的数量嗯我想一下在中提供了一个类信号量它提供了两个方法请求信号量可以限制线程的个数是一个正数如果信号量是就代表已经用完了信号量其他线程需要阻塞了第二个方法是代表是释放一个信号量此时信号量的个数谈谈你对的理解易考嗯是这样的主要功能有两个第一个是可以实现资源对象的线程隔离让每个线程各用各的资源对象避免争用引发的线程安全问题第二个是实现了线程内的资源共享好的那你知道的底层原理实现吗嗯知道一些在内部维护了一个一个类型的成员变量用来存储资源对象当我们调用方法就是以自己作为资源对象作为放入当前线程的集合中当调用方法就是以自己作为到当前线程中查找关联的资源值当调用方法就是以自己作为移除当前线程关联的资源值好的那关于会导致内存溢出这个事情了解吗嗯我之前看过源码我想一下是因为中的被设计为弱引用它是被动的被调用释放不过关键的是只有可以得到内存释放而不会因为是一个强引用在使用时都把它作为静态变量即强引用因此无法被动依靠回收建议主动的释放这样就能避免内存溢出我看你的项目中有使用谈谈你对他的理解是提供的一个线程本地变量每个线程都有自己独立的变量副本线程之间互不干扰它通过来实现线程隔离每个线程都有自己的来存储变量我们当时在项目中主要用来存储当前登录用户的信息当用户登录后我们将用户信息存储到中这样在整个请求处理过程中任何地方都可以通过获取到当前用户信息而不需要每次都传递用户参数使用后我们不需要在每个方法中传递用户参数代码更加简洁同时由于每个线程都有独立的变量副本避免了线程安全问题不需要使用等同步机制在使用时我们需要注意内存泄漏问题如果变量没有及时清理可能会导致内存泄漏所以我们会在请求处理完成后主动清理确保资源的正确释放八由那些部分组成运行流程是什么易考嗯好的在中共有四大部分分别是类加载器运行时数据区内存分区执行引擎本地库接口它们的运行流程是第一类加载器把代码转换为字节码第二运行时数据区把字节码加载到内存中而字节码文件只是的一套指令集规范并不能直接交给底层系统去执行而是有执行引擎运行第三执行引擎将字节码翻译为底层系统指令再交由执行去执行此时需要调用其他语言的本地库接口来实现整个程序的功能什么是程序计数器易考嗯是这样虚拟机对于多线程是通过线程轮流切换并且分配线程执行时间在任何的一个时间点上一个处理器只会处理执行一个线程如果当前被执行的这个线程它所分配的执行时间用完了挂起处理器会切换到另外的一个线程上来进行执行并且这个线程的执行时间用完了接着处理器就会又来执行被挂起的这个线程这时候程序计数器就起到了关键作用程序计数器在来回切换的线程中记录他上一次执行的行号然后接着继续向下执行介绍一下的堆好的中的堆术语线程共享的区域主要用来保存对象实例数组等当堆中没有内存空间可分配给实例也无法再扩展时则抛出异常在中堆内会存在年轻代老年代区被划分为三部分区和两个大小严格相同的区其中区间中某一时刻只有其中一个是被使用的另外一个留做垃圾收集时复制对象用在区变满的时候就会将存活的对象移到空闲的区间中根据的策略在经过几次垃圾收集后任然存活于的对象将被移动到区间区主要保存生命周期长的对象一般是一些老的对象当一些对象在复制转移一定的次数以后对象就会被转移到区什么是虚拟机栈虚拟机栈是描述的是方法执行时的内存模型是线程私有的生命周期与线程相同每个方法被执行的同时会创建栈桢保存执行方法时的局部变量动态连接信息方法返回地址信息等等方法开始执行的时候会进栈方法执行完会出栈相当于清空了数据所以这块区域不需要进行垃圾回收是否涉及栈内存垃圾回收主要指就是堆内存当栈帧弹栈以后内存就会释放栈内存分配越大越好吗未必默认的栈内存通常为栈帧过大会导致线程数变少例如机器总内存为目前能活动的线程数则为个如果把栈内存改为那么能活动的栈帧就会减半方法内的局部变量是否线程安全如果方法内局部变量没有逃离方法的作用范围它是线程安全的如果是局部变量引用了对象并逃离方法的作用范围需要考虑线程安全栈内存溢出情况栈帧过多导致栈内存溢出典型问题递归调用栈帧过大导致栈内存溢出栈和堆的区别呢嗯好的有这几个区别第一栈内存一般会用来存储局部变量和方法调用但堆内存是用来存储对象和数组的的堆会垃圾回收而栈不会第二栈内存是线程私有的而堆内存是线程共有的第三两者异常错误不同但如果栈内存或者堆内存不足都会抛出异常栈空间不足堆空间不足能不能解释一下方法区好的与虚拟机栈类似本地方法栈是为虚拟机执行本地方法时提供服务的不需要进行本地方法一般是由其他语言编写解释一下运行常量池常量池可以看作是一张表虚拟机指令根据这张常量表找到要执行的类名方法名参数类型字面量等信息当类被加载它的常量池信息就会放入运行时常量池并把里面的符号地址变为真实地址说一下运行时数据区嗯好运行时数据区包含了堆方法区栈本地方法栈程序计数器这几部分每个功能作用不一样堆解决的是对象实例存储的问题垃圾回收器管理的主要区域方法区可以认为是堆的一部分用于存储已被虚拟机加载的信息常量静态变量即时编译器编译后的代码栈解决的是程序运行的问题栈里面存的是栈帧栈帧里面存的是局部变量表操作数栈动态链接方法出口等信息本地方法栈与栈功能相同本地方法栈执行的是本地方法一个调用非代码的接口程序计数器寄存器程序计数器中存放的是当前线程所执行的字节码的行数工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令你听过直接内存吗嗯它又叫做堆外内存线程共享的区域在之前有个永久代的概念实际上指的是虚拟机上的永久代它用永久代实现了规范定义的方法区功能主要存储类的信息常量静态变量即时编译器编译后代码等这部分由于是在堆中实现的受的管理不过由于永久代有的上限所以如果大量动态生成类将类信息放入永久代很容易造成有人说可以把永久代设置得足够大但很难确定一个合适的大小受类数量常量数量的多少影响很大所以在中就把方法区的实现移到了本地内存中的元空间中这样方法区就不受的控制了也就不会进行也因此提升了性能什么是类加载器类加载器有哪些嗯是这样的只会运行二进制文件而类加载器的主要作用就是将字节码文件加载到中从而让程序能够启动起来常见的类加载器有个第一个是启动类加载器其是由编写实现用于加载目录下的类库第二个是扩展类加载器该类是的子类主要加载目录中的类库第三个是应用类加载器该类是的子类主要用于加载下的类也就是加载开发者自己编写的类第四个是自定义类加载器开发者自定义类继承实现自定义类加载规则什么是双亲委派模型易考嗯它是是这样的如果一个类加载器收到了类加载的请求它首先不会自己尝试加载这个类而是把这请求委派给父类加载器去完成每一个层次的类加载器都是如此因此所有的加载请求最终都应该传说到顶层的启动类加载器中只有当父类加载器返回自己无法完成这个加载请求它的搜索返回中没有找到所需的类时子类加载器才会尝试自己去加载为什么采用双亲委派机制主要有两个原因第一通过双亲委派机制可以避免某一个类被重复加载当父类已经加载后则无需重复加载保证唯一性第二为了安全保证类库不会被修改说一下类装载的执行过程面试官您好类装载的执行过程主要分为以下几个步骤首先是加载阶段这一步会去查找并导入文件把字节码数据加载到的方法区中同时在堆区创建对应的对象作为程序访问方法区中类数据的入口接着是验证阶段目的是保证加载进来的类的准确性会对字节码的格式语义等进行校验防止恶意或者错误的类文件影响的正常运行然后是准备阶段要为类变量也就是静态变量分配内存并且设置类变量的初始值不过这里要注意初始值通常是该类型的默认值比如类型默认初始值是而不是代码中显式指定的初始值之后是解析阶段会把类中的符号引用转换为直接引用符号引用就像我们代码里用名字来指代其他类方法等直接引用则是实际能定位到目标的内存地址等具体引用方式再然后是初始化阶段这一步会对类的静态变量静态代码块执行初始化操作按照代码中定义的顺序去赋值或者执行代码逻辑这时候才会把准备阶段的默认初始值替换成我们期望的初始值当完成初始化后就到了使用阶段会从入口方法开始执行用户的程序代码最后是卸载阶段当用户程序代码执行完毕就会开始销毁创建的对象释放相关的资源简述垃圾回收机制是什么为什么要嗯是这样为了让程序员更专注于代码的实现而不用过多的考虑内存释放的问题所以在语言中有了自动的垃圾回收机制也就是我们熟悉的有了垃圾回收机制后程序员只需要关心内存的申请即可内存的释放由系统自动识别完成在进行垃圾回收时不同的对象引用类型会采用不同的回收时机对象什么时候可以被垃圾器回收易考思考一会如果一个或多个对象没有任何的引用指向它了那么这个对象现在就是垃圾如果定位了垃圾则有可能会被垃圾回收器回收如果要定位什么是垃圾有两种方式来确定第一个是引用计数法第二个是可达性分析算法通常都使用可达性分析算法来确定是不是垃圾的垃圾清除算法有哪些易考我记得一共有四种分别是标记清除算法复制算法标记整理算法分代回收说一下的分代回收关于分代回收是这样的在时堆被分为了两份新生代和老年代它们默认空间占用比例是对于新生代内部又被分为了三个区域区区区默认空间占用比例是具体的工作机制是有些情况当创建一个对象的时候那么这个对象会被分配在新生代的区当区要满了时候触发当进行后此时在区存活的对象被移动到区并且当前对象的年龄会加清空区当再一次触发的时候会把区中存活下来的对象和中的对象移动到区中这些对象的年龄会加清空区和区当再一次触发的时候会把区中存活下来的对象和中的对象移动到区中这些对象的年龄会加清空区和区对象的年龄达到了某一个限定的值默认岁那么这个对象就会进入到老年代中当然也有特殊情况如果进入区的是一个大对象在触发的时候会直接存放到老年代当老年代满了之后触发同时回收新生代和老年代当前只会存在一个的线程进行执行其他的线程全部会被挂起我们在程序中要尽量避免的出现说一说讲一下新生代老年代永久代区别相关嗯是这样的简单说就是新生代主要用来存放新生的对象老年代主要存放应用中生命周期长的内存对象永久代指的是永久保存区域主要存放和元数据的信息在中永久代已经被移除取而代之的是一个称之为元数据区元空间的区域元空间和永久代类似不过元空间与永久代之间最大的区别在于元空间并不在虚拟机中而是使用本地内存因此默认情况下元空间的大小仅受本地内存的限制说一下有哪些垃圾回收器易考在中实现了多种垃圾收集器包括串行垃圾收集器并行垃圾收集器默认并发垃圾收集器垃圾收集器默认详细说一下什么是垃圾回收器面试官您好垃圾回收器是里很重要的一款回收器我来详细和您聊聊首先它能同时处理新生代和老年代而且从之后就成为默认的垃圾回收器了把堆内存划分成多个区域每个区域可以灵活充当区区区还有专门为大对象准备的区在回收算法上采用的是复制算法它在性能方面做得不错能兼顾响应时间和吞吐量这对于很多应用场景来说是很友好的的工作主要分三个阶段第一阶段是新生代回收这个阶段会触发暂停所有应用线程第二阶段是并发标记不过其中重新标记的环节还是会第三阶段是混合收集另外如果出现并发失败的情况也就是垃圾回收的速度跟不上新对象创建的速度就会触发强引用软引用弱引用虚引用的区别嗯其实它们指的是不同代之间的垃圾回收发生在新生代的垃圾回收暂停时间短老年代区域的垃圾回收老年代空间不足时会先尝试触发之后空间还不足则会触发速度比较慢暂停时间长新生代老年代完整垃圾回收暂停时间长应尽力避免的调优参数可以在哪里设置我们当时的项目是项目可以在项目启动的时候中加入参数就行了的调优参数都有哪些少考嗯这些参数是比较多的我记得当时我们设置过堆的大小像和还有就是可以设置年轻代中区和两个区的大小比例还有就是可以设置使用哪种垃圾回收器等等具体的指令还真记不太清楚说一下的调优工具少考嗯我们一般都是使用自带的一些工具比如输出中运行的进程状态信息查看进程内线程的堆栈信息用于生成堆转存快照用于统计监测工具还有一些可视化工具像和等内存泄漏的排查思路易考嗯这个我在之前项目排查过第一呢可以通过指定打印他的内存快照文件不过有的情况打印不了我们会设置参数让程序自动生成文件第二可以通过工具去分析文件自带的就可以分析第三通过查看堆信息的情况可以大概定位内存溢出是哪行代码出了问题第四找到对应的代码通过阅读上下文的情况进行修复即可飙高的排查方案与思路易考嗯我思考一下可以这么做第一可以使用使用命令查看占用的情况第二通过命令查看后可以查看是哪一个进程占用较高记录这个进程第三可以通过查看当前进程中的线程信息看看哪个线程的占用较高第四可以命令打印进行的找到这个线程就可以进一步定位问题代码的行号九常见技术场景你的单点登录模块怎么实现的呢什么是我们当时在项目中实现了单点登录功能主要解决了用户在不同系统间切换时需要重复登录的问题我们采用了基于的方案结合缓存来实现单点登录当用户首次登录时系统会生成一个并将存储到中同时设置合理的过期时间用户访问其他系统时会携带这个系统通过验证的有效性来判断用户是否已登录如果无效会返回错误跳转到登录页面不同系统通过统一的认证中心来验证的有效性认证中心会检查的签名过期时间等信息同时查询确认是否仍然有效你的项目中权限认证如何实现的我们当时在项目中采用了基于基于角色的访问控制的权限模型我们设计了用户角色权限三个核心实体用户通过角色来获得权限角色通过权限来控制系统功能比如管理员角色拥有所有权限挂号员角色只能进行挂号相关操作医生角色只能进行诊疗相关操作我们使用作为安全框架通过配置类来实现权限控制我们自定义了来加载用户信息实现了基于数据库的用户认证同时我们配置了不同的路径对应不同的权限要求比如路径需要管理员权限路径需要医生权限我们创建了自定义的权限验证拦截器在用户访问受保护的资源时会检查用户是否具有相应的权限我们使用注解在方法级别进行权限控制来确保只有相对应的权限才能执行挂号操作你负责的项目中遇到哪些棘手的问题怎么解决的我们当时在项目中遇到了药品分页查询性能问题药品表有多万条数据当医生查询药品信息时使用传统的分页查询当查询第页以后的数据时查询时间从原来的几百毫秒飙升到几秒钟严重影响用户体验通过分析发现当使用查询时需要先扫描前条记录然后返回第条记录随着页码增加扫描的数据量呈线性增长导致查询性能急剧下降我们采用了基于主键的分页查询优化方案首先我们为药品表添加了合适的索引包括药品名称分类价格等常用查询字段的复合索引然后我们修改了分页查询逻辑使用主键作为游标进行分页比如查询大于某个值的记录这样避免了大量数据的扫描我们将传统的分页改为基于的分页前端传递上一页最后一条记录的后端查询大于该值的记录同时我们实现了查询条件的优化将常用的查询条件组合成复合索引比如药品名称分类价格的复合索引我们使用缓存了热门药品信息对于访问频率高的药品直接从缓存获取减少数据库查询压力同时我们实现了查询结果的缓存相同查询条件的结果会缓存分钟经过优化后药品分页查询的响应时间从原来的几秒钟降低到几十毫秒用户体验得到了显著提升同时通过缓存机制我们进一步减少了数据库的查询压力提升了系统的整体性能你们项目中的日志是怎么采集的我们当时在项目中采用了日志采集方案通过收集应用日志存储到中最后通过进行日志分析和可视化展示我们使用作为日志框架配置了不同的来输出不同类型的日志系统日志输出到系统日志文件业务日志输出到业务日志文件错误日志输出到错误日志文件通过文件监控的方式采集这些日志文件",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2025-09-25 19:33:45",postMainColor:""}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:(e,t,a)=>{if(0===a)return;const o={value:t,expiry:Date.now()+864e5*a};localStorage.setItem(e,JSON.stringify(o))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const a=JSON.parse(t);if(!(Date.now()>a.expiry))return a.value;localStorage.removeItem(e)}},e.getScript=(e,t={})=>new Promise(((a,o)=>{const c=document.createElement("script");c.src=e,c.async=!0,c.onerror=o,c.onload=c.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(c.onload=c.onreadystatechange=null,a())},Object.keys(t).forEach((e=>{c.setAttribute(e,t[e])})),document.head.appendChild(c)})),e.getCSS=(e,t=!1)=>new Promise(((a,o)=>{const c=document.createElement("link");c.rel="stylesheet",c.href=e,t&&(c.id=t),c.onerror=o,c.onload=c.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(c.onload=c.onreadystatechange=null,a())},document.head.appendChild(c)})),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#18171d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#f7f9fe")};const t=saveToLocal.get("theme"),a=window.matchMedia("(prefers-color-scheme: dark)").matches,o=window.matchMedia("(prefers-color-scheme: light)").matches,c=window.matchMedia("(prefers-color-scheme: no-preference)").matches,n=!a&&!o&&!c;if(void 0===t){if(o)activateLightMode();else if(a)activateDarkMode();else if(c||n){const e=(new Date).getHours();e<=6||e>=18?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener((e=>{void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())}))}else"light"===t?activateLightMode():activateDarkMode();const d=saveToLocal.get("aside-status");void 0!==d&&("hide"===d?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside")),/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="https://jsd-proxy.ygxz.in/npm/js-heo@1.0.11/poem/poem.min.css"><link rel="stylesheet" href="https://jsd-proxy.ygxz.in/npm/js-heo@1.0.11/mainColor/heoMainColor.min.css"><link rel="stylesheet" href="https://jsd-proxy.ygxz.in/gh/lyay23/blogstatic@v1.0.0/static/essay-style.min.css"><link rel="stylesheet" href="https://jsd-proxy.ygxz.in/gh/lyay23/blogstatic@v1.0.0/static/todolist.min.css"><link rel="stylesheet" href="https://jsd-proxy.ygxz.in/gh/lyay23/blogstatic@v1.0.1/static/custom-me.min.css"><link rel="stylesheet" href="https://jsd-proxy.ygxz.in/gh/lyay23/blogstatic@v1.0.0/static/imgloaded.min.css"><link rel="stylesheet" href="https://jsd-proxy.ygxz.in/gh/lyay23/blogstatic@v1.0.0/static/twikoo.min.css"><script async defer src="https://umami.baskly.fun/script.js" data-website-id="83445f1f-eab2-4423-b52a-d98fcec8638f"></script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://bu.dusays.com/2025/03/01/67c2609b7c10b.jpg"><div class="loading-image-dot"></div></div></div><script>const preloader={endLoading:()=>{document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",(()=>{preloader.endLoading()})),setTimeout((function(){preloader.endLoading()}),1e4),document.addEventListener("pjax:send",(()=>{preloader.initLoading()})),document.addEventListener("pjax:complete",(()=>{preloader.endLoading()}))</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"><script async src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">李阳的秘密小屋</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size:.9em"></i> <span>隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size:.9em"></i> <span>分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size:.9em"></i> <span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/charts/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tongji1"></use></svg> <span>统计</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=12781955100&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size:.9em"></i> <span>耳机分你一半</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size:.9em"></i> <span>留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/todolist/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zuji"></use></svg> <span>脚步</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/essay/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-taiyang"></use></svg> <span>小太阳</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-a-xiaoyangyang_huaban1"></use></svg> <span>了解我</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i> <span>搜索</span></a></div><input id="center-console" type="checkbox"><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole()"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title">最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/408/" style="font-size:1.05rem">408<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size:1.05rem">C语言<sup>1</sup></a><a href="/tags/java/" style="font-size:1.05rem">java<sup>1</sup></a><a href="/tags/javaweb/" style="font-size:1.05rem">javaweb<sup>9</sup></a><a href="/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/" style="font-size:1.05rem">力扣刷题<sup>1</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size:1.05rem">操作系统<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size:1.05rem">数据结构<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size:1.05rem">计算机组成原理<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size:1.05rem">计算机网络<sup>2</sup></a><a href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" style="font-size:1.05rem">软件工程<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size:1.05rem">面试<sup>4</sup></a></div></div><hr></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多"><i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/09/"><span class="card-archive-list-date">九月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">八月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">三月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li></ul></div><hr></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url">面试</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/" tabindex="-1" itemprop="url"><span><i class="anzhiyufont anzhiyu-icon-hashtag"></i> 面试</span></a></span></div></div><h1 class="post-title" itemprop="name headline">java面试黑马版</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-09-07T02:34:21.000Z" title="发表于 2025-09-07 10:34:21">2025-09-07</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-09-25T11:33:45.596Z" title="更新于 2025-09-25 19:33:45">2025-09-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">32.1k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>97分钟</span></span><span class="post-meta-separator"></span><span data-flag-title="java面试黑马版"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="twikoo_visitors" title="访问量"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator"></span><span class="post-meta-position" title="作者IP属地为武汉"><i class="anzhiyufont anzhiyu-icon-location-dot"></i> 武汉</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/45509/#post-comment" tabindex="-1"><span id="twikoo-count"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s58 18 88 18 58-18 88-18 58 18 88 18v44h-352Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://bu.dusays.com/2024/12/24/676a8d8bc7d9f.png?_r_=3b9fde37-24bc-0474-7dd1-4a5586f05907"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://blog.baskly.fun/posts/45509/"><header><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url">面试</a><a href="/tags/%E9%9D%A2%E8%AF%95/" tabindex="-1" itemprop="url">面试</a><h1 id="CrawlerTitle" itemprop="name headline">java面试黑马版</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">李阳</span><time itemprop="dateCreated datePublished" datetime="2025-09-07T02:34:21.000Z" title="发表于 2025-09-07 10:34:21">2025-09-07</time><time itemprop="dateCreated datePublished" datetime="2025-09-25T11:33:45.596Z" title="更新于 2025-09-25 19:33:45">2025-09-25</time></header><blockquote><p>求其上,得其中;求其中,得其下,求其下,必败</p><p><em>——《孙子兵法》</em></p></blockquote><h4 id="一-、Redis">一 、Redis</h4><h5 id="1-我看你在项目中使用了Redis，你最近在哪些场景中使用了Redis呢？">1. 我看你在项目中使用了Redis，你最近在哪些场景中使用了Redis呢？</h5><p>我在项目中使用Redis缓存医生排班、药品库存等热点数据，通过Redisson分布式锁解决挂号并发问题，确保号源分配的原子性操作。</p><h6 id="Redis的缓存在项目中的使用？">Redis的缓存在项目中的使用？</h6><ol><li><p>医生排班信息缓存</p><p>将医生的排班表、可预约时间段、剩余号源数量等数据缓存到Redis中，设置合理的过期时间（如1小时）。当挂号员查询医生排班时，优先从Redis获取数据，避免频繁查询数据库，提升响应速度。</p></li><li><p>用户登录状态管理</p><p>使用Redis存储用户的JWT Token和会话信息，设置Token过期时间与JWT保持一致。当用户访问需要认证的接口时，从Redis中验证Token有效性，实现快速的身份验证。</p></li><li><p>药品库存信息缓存</p><p>将常用药品的库存数量、价格、规格等信息缓存到Redis，挂号员和医生查询药品信息时直接从缓存获取，减少数据库压力。</p></li><li><p>患者挂号记录缓存</p><p>将当天的挂号记录、已预约号源等信息缓存到Redis，方便快速查询和更新挂号状态。</p></li></ol><h6 id="为什么使用Redisson分布式锁？">为什么使用Redisson分布式锁？</h6><ol><li><p>挂号并发问题</p><p>当多个挂号员同时为同一医生同一时间段挂号时，可能出现超卖问题。比如某医生上午10点只有5个号源，但6个挂号员同时操作，可能导致6个患者都成功挂号，造成号源超卖。</p></li><li><p>分布式锁的必要性</p><p>使用Redisson分布式锁，在挂号操作前先获取锁，确保同一时间只有一个挂号员能操作该医生的号源，操作完成后释放锁，保证号源分配的原子性。</p></li></ol><h5 id="2-那么你是怎么解决缓存穿透的问题呢？">2. 那么你是怎么解决缓存穿透的问题呢？</h5><p>嗯，我想一下。缓存穿透是指查询一个一定不存在的数据，由于存储层查不到数据因此不写入缓存，这将导致这个不存在的数据每次请求都要到 数据库去查询，可能导致 数据库 挂掉。这种情况大概率是遭到了攻击。解决方案的话一般有两种方式方案一呢是采用缓存空数据的方式，方案二就是采用布隆过滤器，我们通常都会用布隆过滤器来解决它。</p><h5 id="3-你能介绍一下布隆过滤器吗？">3. 你能介绍一下布隆过滤器吗？</h5><p>嗯，是这样的。布隆过滤器主要是用于检索一个元素是否在一个集合中。我们当时使用的是Redisson实现的布隆过滤器。它的底层原理是，先初始化一个比较大的数组，里面存放的是二进制0或1。一开始都是0，当一个key来了之后，经过3次hash计算，模数组长度找到数据的下标，然后把数组中原来的0改为1。这样，三个数组的位置就能标明一个key的存在。查找的过程也是一样的。当然，布隆过滤器有可能会产生一定的误判，我们一般可以设置这个误判率，大概不会超过5%。其实这个误判是必然存在的，要不就得增加数组的长度。5%以内的误判率一般的项目也能接受，不至于高并发下压倒数据库。</p><h5 id="4-什么是缓存击穿？怎么解决">4. 什么是缓存击穿？怎么解决</h5><p>嗯！缓存击穿的意思是，对于设置了过期时间的key，缓存在某个时间点过期的时候，恰好这个时间点对这个Key有大量的并发请求过来。这些请求发现缓存过期，一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把 DB 压垮。</p><p>解决方案有两种方式：第一，可以使用互斥锁：当缓存失效时，不立即去load db，先使用如 Redis 的 <code>SETNX</code> 去设置一个互斥锁。当操作成功返回时，再进行 load db的操作并回设缓存，否则重试get缓存的方法。第二种方案是设置当前key逻辑过期，大概思路如下：</p><ol><li>在设置key的时候，设置一个过期时间字段一块存入缓存中，不给当前key设置过期时间；</li><li>当查询的时候，从redis取出数据后判断时间是否过期；</li><li>如果过期，则开通另外一个线程进行数据同步，当前线程正常返回数据，这个数据可能不是最新的。</li></ol><p>两种方案各有利弊：</p><p>如果选择数据的强一致性，建议使用分布式锁的方案，但性能上可能没那么高，且有可能产生死锁的问题。</p><p>如果选择key的逻辑删除，则优先考虑高可用性，性能比较高，但数据同步这块做不到强一致。</p><h5 id="5-什么是缓存雪崩，怎么解决？">5. 什么是缓存雪崩，怎么解决？</h5><p>嗯！缓存雪崩意思是，设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重而雪崩。与缓存击穿的区别是：雪崩是很多key，而击穿是某一个key缓存。解决方案主要是，可以将缓存失效时间分散开。比如，可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机。这样，每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><h5 id="6-Redis作为缓存，Mysql与Redis数据如何进行同步呢（双写一致）">6. Redis作为缓存，Mysql与Redis数据如何进行同步呢（双写一致）</h5><p>我们当时是将医生排班信息，用户的一些信息缓存到数据库，这些数据实时要求性并没有这么高，所以我们当时采用的是异步的方案同步数据<br>我们当时采用的阿里的canal组件实现数据同步:不需要更改业务代码，部署一个canal服务。canal服务把自己伪装成mysql的一个从节点，当mysql数据更新以后，canal会读取binlog数据，然后在通过canal的客户端获取到数据，更新缓存即可。</p><h5 id="7-Redis作为缓存，数据持久化是怎么做的">7. Redis作为缓存，数据持久化是怎么做的</h5><p>在Redis中提供了两种数据持久化的方式：1) RDB；2) AOF。</p><h5 id="8-这两种持久化方式有什么区别呢？">8. 这两种持久化方式有什么区别呢？</h5><p>RDB是一个快照文件。它是把redis内存存储的数据写到磁盘上。当redis实例宕机恢复数据的时候，可以从RDB的快照文件中恢复数据。AOF的含义是追加文件。当redis执行写命令的时候，都会存储到这个文件中。当redis实例宕机恢复数据的时候，会从这个文件中再次执行一遍命令来恢复数据。</p><h5 id="9-这两种方式，哪种恢复的比较快呢？">9. 这两种方式，哪种恢复的比较快呢？</h5><p>RDB因为是二进制文件，保存时体积也比较小，所以它恢复得比较快。但它有可能会丢数据。我们通常在项目中也会使用AOF来恢复数据。虽然AOF恢复的速度慢一些，但它丢数据的风险要小很多。在AOF文件中可以设置刷盘策略。我们当时设置的就是每秒批量写入一次命令</p><h5 id="10-Redis的过期策略有哪些">10. Redis的过期策略有哪些</h5><p>嗯~，在redis中提供了两种数据过期删除策略。第一种是惰性删除。在设置该key过期时间后，我们不去管它。当需要该key时，我们检查其是否过期。如果过期，我们就删掉它；反之，返回该key。第二种是定期删除。就是说，每隔一段时间，我们就对一些key进行检查，并删除里面过期的key。定期清理的两种模式是：1) SLOW模式，是定时任务，执行频率默认为10hz，每次不超过25ms，可以通过修改配置文件redis.conf的hz选项来调整这个次数；2) FAST模式，执行频率不固定，每次事件循环会尝试执行，但两次间隔不低于2ms，每次耗时不超过1ms。Redis的过期删除策略是：惰性删除 + 定期删除两种策略配合使用。</p><h5 id="11-数据淘汰策略有哪些">11. 数据淘汰策略有哪些</h5><p>嗯，这个在redis中提供了很多种，默认是noeviction，不删除任何数据，内部不足时直接报错。这个可以在redis的配置文件中进行设置。里面有两个非常重要的概念：一个是LRU，另外一个是LFU。LRU的意思就是最少最近使用。它会用当前时间减去最后一次访问时间。这个值越大，则淘汰优先级越高。LFU的意思是最少频率使用。它会统计每个key的访问频率。值越小，淘汰优先级越高。我们在项目中设置的是allkeys-lru，它会挑选最近最少使用的数据进行淘汰，把一些经常访问的key留在redis中。</p><h5 id="12-数据库有1000万数据，Redis只能缓存20w数据。如何保证Redis中的数据都是热点数据？">12. 数据库有1000万数据，Redis只能缓存20w数据。如何保证Redis中的数据都是热点数据？</h5><p>嗯，我想一下()。可以使用allkeys-lru（挑选最近最少使用的数据淘汰）淘汰策略。那留下来的都是经常访问的热点数据。</p><h5 id="13-Redis的内存用完了会发生什么？">13. Redis的内存用完了会发生什么？</h5><p>嗯~，这个要看redis的数据淘汰策略是什么。如果是默认的配置，redis内存用完以后则直接报错。我们当时设置的是allkeys-lru策略，把最近最常访问的数据留在缓存中。</p><h5 id="14-Redis的分布式锁是如何实现的呢">14. Redis的分布式锁是如何实现的呢</h5><p>我们当时使用的是Redisson来实现分布式锁。在挂号业务中，当多个挂号员同时为同一医生同一时间段挂号时，可能会出现号源超卖的问题。底层使用的是setnx和lua脚本来保证原子性</p><h5 id="15-Redis实现分布式锁如何合理控制锁的时长">15. Redis实现分布式锁如何合理控制锁的时长</h5><p>嗯，的确。redis的<code>SETNX</code>指令不好控制这个问题。我们当时采用的是redis的一个框架Redisson实现的。在Redisson中需要手动加锁，并且可以控制锁的失效时间和等待时间。当锁住的一个业务还没有执行完成的时候，Redisson会引入一个看门狗机制。就是说，每隔一段时间就检查当前业务是否还持有锁。如果持有，就增加加锁的持有时间。当业务执行完成之后，需要使用释放锁就可以了。还有一个好处就是，在高并发下，一个业务有可能会执行很快。客户1持有锁的时候，客户2来了以后并不会马上被拒绝。它会自旋不断尝试获取锁。如果客户1释放之后，客户2就可以马上持有锁，性能也得到了提升。</p><h5 id="16-Redisson实现分布式锁是可重用的吗">16. Redisson实现分布式锁是可重用的吗</h5><p>嗯，是可以重入的。这样做是为了避免死锁的产生。这个重入其实在内部就是判断是否是当前线程持有的锁，如果是当前线程持有的锁就会计数，如果释放锁就会在计数上减一。在存储数据的时候采用的hash结构，大key可以按照自己的业务进行定制，其中小key是当前线程的唯一标识，value是当前线程重入的次数。</p><h5 id="17-Redisson可以解决主从一致的问题吗">17. Redisson可以解决主从一致的问题吗</h5><p>这个是不能的。比如，当线程1加锁成功后，master节点数据会异步复制到slave节点，此时如果当前持有Redis锁的master节点宕机，slave节点被提升为新的master节点，假如现在来了一个线程2，再次加锁，会在新的master节点上加锁成功，这个时候就会出现两个节点同时持有一把锁的问题。我们可以利用Redisson提供的红锁来解决这个问题，它的主要作用是，不能只在一个Redis实例上创建锁，应该是在多个Redis实例上创建锁，并且要求在大多数Redis节点上都成功创建锁，红锁中要求是Redis的节点数量要过半。这样就能避免线程1加锁成功后master节点宕机导致线程2成功加锁到新的master节点上的问题了。</p><p>但是，如果使用了红锁，因为需要同时在多个节点上都添加锁，性能就变得非常低，并且运维维护成本也非常高，所以，我们一般在项目中也不会直接使用红锁，并且官方也暂时废弃了这个红锁。</p><h5 id="18-如果业务非要保证数据的强一致性，这个该怎么解决呢？">18. 如果业务非要保证数据的强一致性，这个该怎么解决呢？</h5><p>嗯~，Redis本身就是支持高可用的，要做到强一致性，就非常影响性能，所以，如果有强一致性要求高的业务，建议使用ZooKeeper实现的分布式锁，它是可以保证强一致性的。</p><hr><h5 id="19-Redis集群有哪些方案，知道吗？">19. Redis集群有哪些方案，知道吗？</h5><p>嗯~~，在Redis中提供的集群方案总共有三种：主从复制、哨兵模式、Redis分片集群。</p><h5 id="20-那你来介绍一下主从同步">20. 那你来介绍一下主从同步</h5><p>嗯，是这样的，单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，可以搭建主从集群，实现读写分离。一般都是一主多从，主节点负责写数据，从节点负责读数据，主节点写入数据之后，需要把数据同步到从节点中。</p><h5 id="21-能说一下，主从同步数据的流程吗？">21. 能说一下，主从同步数据的流程吗？</h5><p>嗯~~，好！主从同步分为了两个阶段，一个是全量同步，一个是增量同步。</p><p>全量同步是指从节点第一次与主节点建立连接的时候使用全量同步，流程是这样的：</p><p>第一：从节点请求主节点同步数据，其中从节点会携带自己的replication id和offset偏移量。</p><p>第二：主节点判断是否是第一次请求，主要判断的依据就是，主节点与从节点是否是同一个replication id，如果不是，就说明是第一次同步，那主节点就会把自己的replication id和offset发送给从节点，让从节点与主节点的信息保持一致。</p><p>第三：在同时主节点会执行<code>BGSAVE</code>，生成RDB文件后，发送给从节点去执行，从节点先把自己的数据清空，然后执行主节点发送过来的RDB文件，这样就保持了一致。</p><p>当然，如果在RDB生成执行期间，依然有请求到了主节点，而主节点会以命令的方式记录到缓冲区，缓冲区是一个日志文件，最后把这个日志文件发送给从节点，这样就能保证主节点与从节点完全一致了，后期再同步数据的时候，都是依赖于这个日志文件，这个就是全量同步。</p><p>增量同步指的是，当从节点服务重启之后，数据就不一致了，所以这个时候，从节点会请求主节点同步数据，主节点还是判断不是第一次请求，不是第一次就获取从节点的offset值，然后主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步。</p><h5 id="22-怎么保证Redis的高并发高可用？">22. 怎么保证Redis的高并发高可用？</h5><p>首先可以搭建主从集群，再加上使用Redis中的哨兵模式，哨兵模式可以实现主从集群的自动故障恢复，里面就包含了对主从服务的监控、自动故障恢复、通知；如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主；同时Sentinel也充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端，所以一般项目都会采用哨兵的模式来保证Redis的高并发高可用。</p><h5 id="23-你们使用Redis是单点还是集群，哪种集群？">23. 你们使用Redis是单点还是集群，哪种集群？</h5><p>嗯！我们当时使用的是主从（1主1从）加哨兵。一般单节点不超过10G内存，如果Redis内存不足则可以给不同服务分配独立的Redis主从节点。尽量不做分片集群。因为集群维护起来比较麻烦，并且集群之间的心跳检测和数据通信会消耗大量的网络带宽，也没有办法使用Lua脚本和事务。</p><h5 id="24-Redis集群脑裂，该怎么解决呢？">24. Redis集群脑裂，该怎么解决呢？</h5><p>嗯！这个在项目中很少见，不过脑裂的问题是这样的，我们现在用的是Redis的哨兵模式集群的。</p><p>有的时候由于网络等原因可能会出现脑裂的情况，就是说，由于Redis master节点和Redis slave节点和Sentinel处于不同的网络分区，使得Sentinel没有能够心跳感知到master，所以通过选举的方式提升了一个slave为master，这样就存在了两个master，就像大脑分裂了一样，这样会导致客户端还在old master那里写入数据，新节点无法同步数据，当网络恢复后，Sentinel会将old master降为slave，这时再从新master同步数据，这会导致old master中的大量数据丢失。</p><p>关于解决的话，我记得在Redis的配置中可以设置：第一可以设置最少的slave节点个数，比如设置至少要有一个从节点才能同步数据，第二个可以设置主从数据复制和同步的延迟时间，达不到要求就拒绝请求，就可以避免大量的数据丢失。</p><h5 id="25-Redis的分片集群有什么作用">25. Redis的分片集群有什么作用</h5><p>分片集群主要解决的是海量数据存储的问题，集群中有多个master，每个master保存不同数据，并且还可以给每个master设置多个slave节点，就可以继续增大集群的高并发能力。同时每个master之间通过ping监测彼此健康状态，就类似于哨兵模式了。当客户端请求可以访问集群任意节点，最终都会被转发到正确节点。</p><h5 id="26-Redis分片集群中数据是怎么存储和读取的？">26. Redis分片集群中数据是怎么存储和读取的？</h5><p>嗯~，在Redis集群中是这样的：</p><p>Redis 集群引入了哈希槽的概念，有 16384 个哈希槽，集群中每个主节点绑定了一定范围的哈希槽范围，key通过CRC16校验后对16384取模来决定放置哪个槽，通过槽找到对应的节点进行存储。取值的逻辑是一样的。</p><h5 id="27-Redis是单线程的，但是为什么还那么快？">27. Redis是单线程的，但是为什么还那么快？</h5><p>嗯，这个有几个原因吧~~~</p><ol><li>完全基于内存的，C语言编写。</li><li>采用单线程，避免不必要的上下文切换和竞争条件。</li><li>使用多路I/O复用模型，非阻塞IO。</li></ol><p>例如：<code>BGSAVE</code>和<code>BGREWRITEAOF</code>都是在后台执行操作，不影响主线程的正常使用，不会产生阻塞。</p><h5 id="28-能解释一下I-O多路复用模型？（简历还我）">28. 能解释一下I/O多路复用模型？（简历还我）</h5><p>嗯~~，I/O多路复用是指利用单个线程来同时监听多个Socket，并且在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。目前的I/O多路复用都是采用的epoll模式实现，它会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间，不需要挨个遍历Socket来判断是否就绪，提升了性能。</p><p>其中Redis的网络模型就是使用I/O多路复用结合事件的处理器来应对多个Socket请求，比如，提供了连接应答处理器、命令回复处理器，命令请求处理器；</p><p>在Redis6.0之后，为了提升更好的性能，在命令回复处理器使用了多线程来处理回复事件，在命令请求处理器中，将命令的转换使用了多线程，增加命令转换速度，在命令执行的时候，依然是单线程</p><h4 id="二、MySQL">二、MySQL</h4><h5 id="1-在MySQL中，如何定位慢查询呢？">1. 在MySQL中，如何定位慢查询呢？</h5><p>嗯，我们当时在做压力测试时发现有些接口响应时间非常慢，压测的结果大概是5秒钟，我们在MySQL中开启了，慢日志查询，设置的值就是2秒，一但SQL的执行时间超过2秒就会记录到日志中</p><h5 id="2-那这个SQL语句执行很慢，如何分析呢？">2. 那这个SQL语句执行很慢，如何分析呢？</h5><p>如果一条SQL执行很慢，我们通常会使用MySQL的<code>EXPLAIN</code>命令来分析这条SQL的执行情况。通过<code>key</code>和<code>key_len</code>可以检查是否命中了索引，如果已经添加了索引，也可以判断索引是否有效。通过<code>type</code>字段可以查看SQL是否有优化空间，比如是否存在全索引扫描或全表扫描。通过<code>extra</code>建议可以判断是否出现回表情况，如果出现，可以尝试添加索引或修改返回字段来优化。</p><h5 id="3-那你了解过索引吗？什么是索引">3. 那你了解过索引吗？什么是索引</h5><p>嗯，索引在项目中非常常见，它是一种帮助MySQL高效获取数据的数据结构，主要用来提高数据检索效率，降低数据库的I/O成本。同时，索引列可以对数据进行排序，降低数据排序的成本，也能减少CPU的消耗。</p><h5 id="4-索引的底层数据结构了解过吗？">4. 索引的底层数据结构了解过吗？</h5><p>MySQL的默认存储引擎InnoDB使用的是B+树作为索引的存储结构。选择B+树的原因包括：节点可以有更多子节点，路径更短；磁盘读写代价更低，非叶子节点只存储键值和指针，叶子节点存储数据；B+树适合范围查询和扫描，因为叶子节点形成了一个双向链表。</p><h5 id="5-B-树与B树的区别是什么？">5. B+树与B树的区别是什么？</h5><ol><li>B树的非叶子节点和叶子节点都存放数据，而B+树的所有数据只出现在叶子节点，这使得B+树在查询时效率更稳定。</li><li>B+树在进行范围查询时效率更高，因为所有数据都在叶子节点，并且叶子节点之间形成了双向链表。</li></ol><h5 id="6-什么是聚簇索引什么是非聚簇索引">6. 什么是聚簇索引什么是非聚簇索引</h5><p>好的~聚簇索引是指数据与索引放在一起，B+树的叶子节点保存了整行数据，通常只有一个聚簇索引，一般是由主键构成。</p><p>非聚簇索引则是数据与索引分开存储，B+树的叶子节点保存的是主键值，可以有多个非聚簇索引，通常我们自定义的索引都是非聚簇索引。</p><h5 id="7-什么是回表查询呢">7. 什么是回表查询呢</h5><p>嗯，其实跟刚才介绍的聚簇索引和非聚簇索引是有关系的，回表的意思就是通过二级索引找到对应的主键值，然后再通过主键值找到聚集索引中所对应的整行数据，这个过程就是回表<br>【备注:如果面试官直接问回表，则需要先介绍聚簇索引和非聚簇索引】</p><h5 id="8-知道什么是覆盖索引吗？">8. 知道什么是覆盖索引吗？</h5><p>嗯~，清楚的<br>覆盖索引是指select查询语句使用了索引，在返回的列，必须在索引中全部能够找到，如果我们使用id查询，它会直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。<br>如果按照二级索引查询数据的时候，返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用select*，尽量在返回的列中都包含添加索引的字段</p><h5 id="9-MySQL超大分页怎么处理">9. MySQL超大分页怎么处理</h5><p>嗯，超大分页通常发生在数据量大的情况下，使用<code>LIMIT</code>分页查询且需要排序时效率较低。可以通过覆盖索引和子查询来解决。首先查询数据的ID字段进行分页，然后根据ID列表用子查询来过滤只查询这些ID的数据，因为查询ID时使用的是覆盖索引，所以效率可以提升。</p><h5 id="10-索引的创建原则有哪些">10. 索引的创建原则有哪些</h5><p>嗯，这个情况有很多，不过都有一个大前提，就是表中的数据要超过10万以上，我们才会创建索引，并且添加索引的字段是查询比较频繁的字段，一般也是像作为查询条件，排序字段或分组的字段这些。<br>还有就是，我们通常创建索引的时候都是使用复合索引来创建，一条SQL的返回值，尽量使用覆盖索引，如果字段的区分度不高的话，我们也会把它放在组合索引后面的字段。<br>如果某一个字段的内容较长，我们会考虑使用前缀索引来使用，当然并不是所有的字段都要添加索引，这个索引的数量也要控制，因为添加索引也会导致新增改的速度变慢。</p><h5 id="11-什么情况下索引会失效">11. 什么情况下索引会失效</h5><p>嗯，这个情况比较多，我说一些自己的经验，以前遇到过的<br>比如，索引在使用的时候没有遵循最左匹配法则，第二个是，模糊查询，如果%号在前面也会导致索引失效。如果在添加索引的字段上进行了运算操作或者类型转换也都会导致索引失效。<br>我们之前还遇到过一个就是，如果使用了复合索引，中间使用了范围查询，右边的条件索引也会失效所以，通常情况下，想要判断出这条sql是否有索引失效的情况，可以使用explain执行计划来分析</p><h5 id="12-谈一谈你对SQL优化的经验？（面试常见）">12. 谈一谈你对SQL优化的经验？（面试常见）</h5><p>候选人:嗯，这个在项目还是挺常见的，当然如果直说sql优化的话，我们会从这几方面考虑，比如建表的时候、使用索引、sql语句的编写、主从复制，读写分离，还有一个是如果量比较大的话，可以考虑分库分表</p><h5 id="13-创建表的时候，你们是如何优化的呢？">13. 创建表的时候，你们是如何优化的呢？</h5><p>创建表时，我们主要参考阿里云的开发手册，选择字段类型时结合字段内容，比如如果是数值的话，像tinyint、int、bigint这些类型，要根据实际情况选择。如果是字符串类型，也是结合存储的内容来选择char和varchar或者text类型</p><h5 id="14-在使用索引的时候，是如何优化呢？">14. 在使用索引的时候，是如何优化呢？</h5><p>在使用索引时，我们遵循索引创建原则，确保索引字段是查询频繁的，使用复合索引覆盖SQL返回值，避免在索引字段上进行运算或类型转换，以及控制索引数量。</p><h5 id="15-你平时对SQL语句做了哪些优化呢？">15. 你平时对SQL语句做了哪些优化呢？</h5><p>嗯，这个也有很多，比如SELECT语句务必指明字段名称，不要直接使用select*，还有就是要注意SQL语句避免造成索引失效的写法;如果是聚合查询，尽量使用<code>UNION ALL</code>代替<code>UNION</code>，表关联时优先使用<code>INNER JOIN</code>，以及在必须使用<code>LEFT JOIN</code>或<code>RIGHT JOIN</code>时，确保小表作为驱动表。</p><h5 id="16-事务的特征是什么，可以详细说一下吗">16. 事务的特征是什么，可以详细说一下吗</h5><p>事务的特性是ACID，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。例如，A向B转账500元，这个操作要么都成功，要么都失败，体现了原子性。转账过程中数据要保持一致，A扣除了500元，B必须增加500元。隔离性体现在A向B转账时，不受其他事务干扰。持久性体现在事务提交后，数据要被持久化存储。</p><h5 id="17-并发事务带来哪些问题？">17 . 并发事务带来哪些问题？</h5><p>并发事务可能导致脏读、不可重复读和幻读。脏读是指一个事务读到了另一个事务未提交的“脏数据”。不可重复读是指在一个事务内多次读取同一数据，由于其他事务的修改导致数据不一致。幻读是指一个事务读取到了其他事务插入的“幻行”。</p><h5 id="18-怎么解决这些问题呢？-MySQL的默认隔离级别是">18. 怎么解决这些问题呢？ MySQL的默认隔离级别是</h5><p>MySQL,支持四种隔离级别，分别有:<br>第一个是，未提交读(read uncommitted）它解决不了刚才提出的所有问题，一般项目中也不用这个。第二个是读已提交(read committed）它能解决脏读的问题的，但是解决不了不可重复读和幻读。第三个是可重复读（repeatable read）它能解决脏读和不可重复读，但是解决不了幻读，这个也是mysql默认的隔离级别。第四个是串行化(serializable)它可以解决刚才提出来的所有问题，但是由于让是事务串行执行的，性能比较低。所以，我们一般使用的都是mysql默认的隔离级别:可重复读</p><h5 id="19-undo-log和redo-log-的区别">19. undo log和redo log 的区别</h5><p>好的，其中redo log日志记录的是数据页的物理变化，服务宕机可用来同步数据，而undo log不同，它主要记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据，比如我们删除一条数据的时候，就会在undo log日志文件中新增一条delete语句，如果发生回滚就执行逆操作;<br>redo log保证了事务的持久性，undo log保证了事务的原子性和一致性</p><h5 id="20-事务中的隔离性是如何保障的呢？（请你解释一下MVCC）-面试常考">20. 事务中的隔离性是如何保障的呢？（请你解释一下MVCC）[面试常考]</h5><p>事务的隔离性是由锁和mvcc实现的。<br>其中mwcc的意思是多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，它的底层实现主要是分为了三个部分，第一个是隐藏字段，第二个是undo log日志，第三个是readView读视图隐藏字段是指:在mysql中给每个表都设置了隐藏字段，有一个是trx_id(事务id)，记录每一次操作的事务id，是自增的;另一个字段是roll_pointer(回滚指针)，指向上一个版本的事务版本记录地址<br>undo log主要的作用是记录回滚日志，存储老版本数据，在内部会形成一个版本链，在多个事务并行操作某一行记录，记录不同事务修改数据的版本，通过roll_pointer指针形成一个链表<br>readView解决的是一个事务查询选择版本的问题，在内部定义了一些匹配规则和当前的一些事务id判断该访问那个版本的数据，不同的隔离级别快照读是不一样的，最终的访问的结果不一样。如果是rc隔离级别，每一次执行快照读时生成ReadView，如果是rr隔离级别仅在事务中第一次执行快照读时生成ReadView，后续复用</p><p>简洁版：</p><p>事务的隔离性通过锁和多版本并发控制（MVCC）来保证。MVCC通过维护数据的多个版本来避免读写冲突。底层实现包括隐藏字段、<code>undo log</code>和<code>read view</code>。隐藏字段包括<code>trx_id</code>和<code>roll_pointer</code>。<code>undo log</code>记录了不同版本的数据，通过<code>roll_pointer</code>形成版本链。<code>read view</code>定义了不同隔离级别下的快照读，决定了事务访问哪个版本的数据。</p><h5 id="21-主从复制的原理是什么">21. 主从复制的原理是什么</h5><p>MySQL主从复制的核心是二进制日志（Binlog）。步骤如下：</p><ol><li>主库在事务提交时记录数据变更到Binlog。</li><li>从库读取主库的Binlog并写入中继日志（Relay Log）。</li><li>从库重做中继日志中的事件，反映到自己的数据中。</li></ol><h5 id="22-你们项目用过MySQL的分库分表吗？">22. 你们项目用过MySQL的分库分表吗？</h5><p>我们采用微服务架构，每个微服务对应一个数据库，是根据业务进行拆分的，这个其实就是垂直拆分。</p><h5 id="23-那你之前使用过水平分库吗？">23. 那你之前使用过水平分库吗？</h5><p>使用过。当时业务发展迅速，某个表数据量超过1000万，单库优化后性能仍然很慢，因此采用了水平分库。我们首先部署了3台服务器和3个数据库，使用mycat进行数据分片。旧数据也按照ID取模规则迁移到了各个数据库中，这样各个数据库可以分摊存储和读取压力，解决了性能问题。</p><h4 id="三、-框架篇">三、 框架篇</h4><h5 id="1-Spring框架中的单例bean是线程安全的吗？">1. Spring框架中的单例bean是线程安全的吗？</h5><p>不是线程安全的。当多用户同时请求一个服务时，容器会给每个请求分配一个线程，这些线程会并发执行业务逻辑。如果处理逻辑中包含对单例状态的修改，比如修改单例的成员属性，就必须考虑线程同步问题。Spring框架本身并不对单例bean进行线程安全封装，线程安全和并发问题需要开发者自行处理。</p><p>通常在项目中使用的Spring bean是不可变状态（如Service类和DAO类），因此在某种程度上可以说Spring的单例bean是线程安全的。如果bean有多种状态（如ViewModel对象），就需要自行保证线程安全。最简单的解决办法是将单例bean的作用域由“singleton”变更为“prototype”。</p><h5 id="2-什么是AOP？">2. 什么是AOP？</h5><p>AOP，即面向切面编程，在Spring中用于将那些与业务无关但对多个对象产生影响的公共行为和逻辑抽取出来，实现公共模块复用，降低耦合。常见的应用场景包括公共日志保存和事务处理。</p><h5 id="3-你们项目中有没有使用到AOP">3. 你们项目中有没有使用到AOP</h5><p>我们之前在后台管理系统中使用AOP来记录系统操作日志。主要思路是使用AOP的环绕通知和切点表达式，找到需要记录日志的方法，然后通过环绕通知的参数获取请求方法的参数，例如类信息、方法信息、注解、请求方式等，并将这些参数保存到数据库。</p><h5 id="4-Spring的事务是如何实现的">4. Spring的事务是如何实现的</h5><p>Spring实现事务的本质是利用AOP完成的。它对方法前后进行拦截，在执行方法前开启事务，在执行完目标方法后根据执行情况提交或回滚事务。</p><h5 id="5-Spring的事务失效的场景有哪些">5. Spring的事务失效的场景有哪些</h5><p>在项目中，我遇到过几种导致事务失效的场景：</p><ol><li>有一次我们在方法内部捕获并处理了异常，没有将异常抛出，会导致事务失效。因此，处理异常后应该确保异常能够被抛出。</li><li>如果方法抛出检查型异常（checked exception），并且没有在<code>@Transactional</code>注解上配置<code>rollbackFor</code>属性为<code>Exception</code>，那么异常发生时事务可能不会回滚。</li><li>如果事务注解的方法不是公开（public）修饰的，也可能导致事务失效。</li></ol><h5 id="6-Spring的bean的生命周期（易考）">6. Spring的bean的生命周期（易考）</h5><p>Spring中bean的生命周期包括以下步骤：</p><ol><li>通过<code>BeanDefinition</code>获取bean的定义信息。</li><li>调用构造函数实例化bean。</li><li>进行bean的依赖注入，例如通过setter方法或<code>@Autowired</code>注解。</li><li>处理实现了<code>Aware</code>接口的bean。通过Aware接口可以获取到bean的一些基本信息,比如bean的名称 bean的工厂和ApplicationContext</li><li>执行<code>BeanPostProcessor</code>的前置处理器。</li><li>调用初始化方法，如实现了<code>InitializingBean</code>接口或自定义的<code>init-method</code>。</li><li>执行<code>BeanPostProcessor</code>的后置处理器，可能在这里产生代理对象。</li><li>最后是销毁bean。</li></ol><h5 id="7-Spring中的循环引用问题">7. Spring中的循环引用问题</h5><p>循环依赖发生在两个或两个以上的bean互相持有对方，形成闭环。Spring框架允许循环依赖存在，并通过三级缓存解决大部分循环依赖问题：</p><ol><li>一级缓存：单例池，缓存已完成初始化的bean对象。</li><li>二级缓存：缓存尚未完成生命周期的早期bean对象。</li><li>三级缓存：缓存<code>ObjectFactory</code>，用于创建bean对象。</li></ol><h5 id="8-你能说一说具体流程吗">8. 你能说一说具体流程吗</h5><p>解决循环依赖的流程如下：</p><ol><li>实例化A对象，并创建<code>ObjectFactory</code>存入三级缓存。</li><li>A在初始化时需要B对象，开始B的创建逻辑。</li><li>B实例化完成，也创建<code>ObjectFactory</code>存入三级缓存。</li><li>B需要注入A，通过三级缓存获取<code>ObjectFactory</code>生成A对象，存入二级缓存。</li><li>B通过二级缓存获得A对象后，B创建成功，存入一级缓存。</li><li>A对象初始化时，由于B已创建完成，可以直接注入B，A创建成功存入一级缓存。</li><li>清除二级缓存中的临时对象A。</li></ol><h5 id="9-构造方法出现了循环依赖怎么解决">9. 构造方法出现了循环依赖怎么解决</h5><p>由于构造函数是bean生命周期中最先执行的，Spring框架无法解决构造方法的循环依赖问题。可以使用<code>@Lazy</code>懒加载注解，延迟bean的创建直到实际需要时。</p><h5 id="10-SpringMVC的执行流程知道吗">10. SpringMVC的执行流程知道吗</h5><p>SpringMVC的执行流程包括以下步骤：</p><ol><li>用户发送请求到前端控制器<code>DispatcherServlet</code>。</li><li><code>DispatcherServlet</code>调用<code>HandlerMapping</code>找到具体处理器。</li><li><code>HandlerMapping</code>返回处理器对象及拦截器（如果有）给<code>DispatcherServlet</code>。</li><li><code>DispatcherServlet</code>调用<code>HandlerAdapter</code>(处理器适配器)。</li><li><code>HandlerAdapter</code>适配并调用具体处理器（Controller）。</li><li>在方法上添加了@ResponseBody注解</li><li>通过HttpMessageConverter来返回结果转换为JSON并且响应</li></ol><h5 id="11-SpringBoot的自动装配原理（易考）">11. SpringBoot的自动装配原理（易考）</h5><p>Spring Boot的自动配置原理基于<code>@SpringBootApplication</code>注解，它封装了<code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>。<code>@EnableAutoConfiguration</code>是核心，它通过<code>@Import</code>导入配置选择器，读取<code>META-INF/spring.factories</code>文件中的类名，根据条件注解决定是否将配置类中的Bean导入到Spring容器中。</p><h5 id="12-spring框架常见注解">12. spring框架常见注解</h5><p>Spring的常见注解包括：</p><ol><li>声明Bean的注解：<code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code>。</li><li>依赖注入相关注解：<code>@Autowired</code>、<code>@``Qualifier</code>、<code>@Resource</code>。</li><li>设置作用域的注解：<code>@Scope</code>。</li><li>配置相关注解：<code>@Configuration</code>、<code>@ComponentScan</code>、<code>@Bean</code>。</li><li>AOP相关注解：<code>@Aspect</code>、<code>@Before</code>、<code>@After</code>、<code>@Around</code>、<code>@Pointcut</code>。</li></ol><h5 id="13-SpringMVC的常见注解">13. SpringMVC的常见注解</h5><p>SpringMVC的常见注解有：</p><ul><li><code>@RequestMapping</code>：映射请求路径。</li><li><code>@RequestBody</code>：接收HTTP请求的JSON数据。</li><li><code>@RequestParam</code>：指定请求参数名称。</li><li><code>@PathVariable</code>：从请求路径中获取参数。</li><li><code>@ResponseBody</code>：将Controller方法返回的对象转化为JSON。</li><li><code>@RequestHeader</code>：获取请求头数据。</li><li><code>@PostMapping</code>、<code>@GetMapping</code>等。</li></ul><h5 id="14-Springboot的常见注解">14. Springboot的常见注解</h5><p>Spring Boot的常见注解包括：</p><ul><li><code>@SpringBootApplication</code>：由<code>@``SpringBootConfiguration</code>、<code>@``EnableAutoConfiguration</code>和<code>@``ComponentScan</code>组成。</li><li>其他注解如<code>@RestController</code>、<code>@GetMapping</code>、<code>@PostMapping</code>等，用于简化Spring MVC的配置。</li></ul><h5 id="15-Spring和SpringBoot之间有什么区别？">15.Spring和SpringBoot之间有什么区别？</h5><p>Spring 和 Spring Boot 的区别在于它们的目标和用途不同。Spring 是一个轻量级的开源框架，它提供了一种简单的方式来构建企业级应用程序。Spring Boot 则是 Spring 框架的延伸和扩展，它提供了一种快速构建应用程序的方式。开发人员可以通过使用 Spring Boot Starter 来快速集成常用的第三方库和框架，使得开发人员可以快速构建出一个可运行的应用程序。</p><h5 id="16-请你描述一下Spring的DI和IOC、">16. 请你描述一下Spring的DI和IOC、</h5><p>IoC 和 DI 都是 Spring 框架中的核心概念，它们的区别在于:</p><ul><li><strong>IoC（Inverse of Control，控制反转）</strong>：它是一种思想，主要解决程序设计中的对象依赖关系管理问题。在 IoC 思想中，对象的创建权反转给第三方容器，由容器进行对象的创建及依赖关系的管理。</li><li><strong>DI（Dependency Injection，依赖注入）</strong>：它是 IoC 思想的具体实现方式之一，用于实现 IoC。在 Spring 中，依赖注入是指:在对象创建时，由容器自动将依赖对象注入到需要依赖的对象中。</li></ul><p>简单来说，它们的关系是：</p><ul><li>IoC 是一种思想、理念，定义了对象创建和依赖关系处理的方式。</li><li>DI 是 IoC 思想的具体实现方式之一，实际提供对象依赖关系的注入功能。</li></ul><p>例如在 Spring 框架中：</p><ul><li>IoC 体现为 Spring 容器承担了对象创建及依赖关系管理的控制权。</li><li>DI 体现为 Spring 容器通过构造方法注入、Setter 方法注入等方式，将依赖对象注入到需要依赖的对象中。</li></ul><h5 id="17-JDK动态代理和CGLIB动态代理有什么区别？">17.JDK动态代理和CGLIB动态代理有什么区别？</h5><p>JDK 动态代理和 CGLIB 动态代理都是常见的动态代理实现技术，但它们有以下区别：</p><ul><li>JDK 动态代理基于接口，要求目标对象实现接口；CGLIB 动态代理基于类，可以代理没有实现接口的目标对象。</li><li>JDK 动态代理使用 java.lang.reflect.Proxy 和 java.lang.reflect.InvocationHandler 来生成代理对象；CGLIB 动态代理使用 CGLIB 库来生成代理对象。</li><li>JDK 动态代理生成的代理对象是目标对象的接口实现；CGLIB 动态代理生成的代理对象是目标对象的子类。</li><li>JDK 动态代理性能相对较高，生成代理对象速度较快；CGLIB 动态代理性能相对较低，生成代理对象速度较慢。</li><li>CGLIB 动态代理无法代理 final 类和 final 方法；JDK 动态代理可以代理任意类</li></ul><h5 id="18-拦截器和过滤器有什么区别">18.拦截器和过滤器有什么区别</h5><p>拦截器和过滤器的区别主要体现在以下 5 点：</p><ol><li><strong>出身不同</strong>：过滤器来自于 Servlet，而拦截器来自于 Spring 框架；</li><li><strong>触发时机不同</strong>：请求的执行顺序是：请求进入容器 &gt; 进入过滤器 &gt; 进入 Servlet &gt; 进入拦截器 &gt; 执行控制器（Controller），所以过滤器和拦截器的执行时机，是过滤器会先执行，然后才会执行拦截器，最后才会进入真正的要调用的方法；</li><li><strong>底层实现不同</strong>：过滤器是基于方法回调实现的，拦截器是基于动态代理（底层是反射）实现的；</li><li><strong>支持的项目类型不同</strong>：过滤器是 Servlet 规范中定义的，所以过滤器要依赖 Servlet 容器，它只能用在 Web 项目中；而拦截器是 Spring 中的一个组件，因此拦截器既可以用在 Web 项目中，同时还可以用在 Application 或 Swing 程序中；</li><li><strong>使用的场景不同</strong>：因为拦截器更接近业务系统，所以拦截器主要用来实现项目中的业务判断的，比如：登录判断、权限判断、日志记录等业务；而过滤器通常是用来实现通用功能过滤的，比如：敏感词过滤、字符集编码设置、响应数据压缩等功能。</li></ol><h5 id="19-Autowired-和-Resource-有什么不同">19. <strong>@Autowired 和 @Resource</strong> 有什么不同</h5><p>@Autowired 和 @Resource 都是用来实现依赖注入的注解（在 Spring/Spring Boot 项目中），但二者却有着 5 点不同：</p><ol><li>来源不同：@Autowired 来自 Spring 框架，而 @Resource 来自于（Java）JSR-250；</li><li>依赖查找的顺序不同：@Autowired 先根据类型再根据名称查询，而 @Resource 先根据名称再根据类型查询；</li><li>支持的参数不同：@Autowired 只支持设置 1 个参数，而 @Resource 支持设置 7 个参数；</li><li>依赖注入的用法支持不同：@Autowired 既支持构造方法注入，又支持属性注入和 Setter 注入，而 @Resource 只支持属性注入和 Setter 注入；</li><li>编译器 IDEA 的提示不同：当注入 Mapper 对象时，使用 @Autowired 注解编译器会提示错误，而使用 @Resource 注解则不会提示错误</li></ol><h5 id="20-MyBatis的执行流程是什么">20. MyBatis的执行流程是什么</h5><p>MyBatis的执行流程如下：</p><ol><li>读取MyBatis配置文件<code>mybatis-config.xml</code>。</li><li>构造会话工厂<code>SqlSessionFactory</code>。</li><li>会话工厂创建<code>SqlSession</code>对象。</li><li>操作数据库的接口，<code>Executor</code>执行器。</li><li><code>Executor</code>执行方法中的<code>MappedStatement</code>参数。</li><li>输入参数映射。</li><li>输出结果映射。</li></ol><h5 id="21-Mybatis是否支持延迟加载？">21. Mybatis是否支持延迟加载？</h5><p>MyBatis支持延迟加载，即在需要用到数据时才加载。可以通过配置文件中的<code>lazyLoadingEnabled</code>配置启用或禁用延迟加载。</p><h5 id="22-延迟加载的底层原理知道吗？">22. 延迟加载的底层原理知道吗？</h5><p>延迟加载的底层原理主要使用CGLIB动态代理实现：</p><ol><li>使用CGLIB创建目标对象的代理对象。</li><li>调用目标方法时，如果发现是null值，则执行SQL查询。</li><li>获取数据后，设置属性值并继续查询目标方法。</li></ol><h5 id="23-Mybatis的一级、二级缓存用过吗？">23. Mybatis的一级、二级缓存用过吗？</h5><p>MyBatis的一级缓存是基于<code>Perpetual``Cache</code>的HashMap本地缓存，作用域为Session，默认开启。二级缓存需要单独开启，作用域为Namespace或mapper，默认也是采用<code>PerpetualCache</code>，HashMap存储。</p><h4 id="四、微服务">四、微服务</h4><h5 id="1-SpringCloud的五大组件是什么">1. SpringCloud的五大组件是什么</h5><p>在早期，Spring Cloud的五大组件通常指的是：</p><ul><li><strong>Eureka</strong>：服务注册中心。</li><li><strong>Ribbon</strong>：客户端负载均衡器。</li><li><strong>Feign</strong>：声明式的服务调用。</li><li><strong>Hystrix</strong>：服务熔断器。</li><li><strong>Zuul/Gateway</strong>：API网关。</li></ul><p>随着Spring Cloud Alibaba的兴起，我们项目中也融入了一些阿里巴巴的技术组件：</p><ul><li>服务注册与配置中心：Nacos。</li><li>负载均衡：Ribbon。</li><li>服务调用：Feign。</li><li>服务保护：Sentinel。</li><li>API网关：Gateway。</li></ul><h5 id="2-服务注册和发现是什么意思？Spring-Cloud-如何实现服务注册发现？">2. 服务注册和发现是什么意思？Spring Cloud 如何实现服务注册发现？</h5><p>服务注册与发现主要包含三个核心功能：服务注册、服务发现和服务状态监控。</p><p>我们项目中采用了 Nacos 作为服务注册中心，它是一个集服务发现、配置管理于一体的中间件。</p><ul><li><strong>服务注册</strong>：服务提供者在启动时，会将自己的信息（如服务名称、IP、端口、权重等）注册到 Nacos 服务器。</li><li><strong>服务发现</strong>：服务消费者通过 Nacos 客户端从注册中心获取目标服务的可用实例列表，并基于内置的负载均衡策略选择合适的服务实例进行调用。</li><li><strong>服务监控</strong>：服务提供者会定期向 Nacos 发送心跳以维持服务实例的健康状态；Nacos 通过心跳检测和健康检查机制，实时感知服务实例的存活状态，当实例异常时会及时将其从服务列表中移除，确保服务调用的准确性。</li></ul><h5 id="3-我看你之前也用过nacos，你能说下nacos与eureka的区别？">3. 我看你之前也用过nacos，你能说下nacos与eureka的区别？</h5><p>在使用Nacos作为注册中心的项目中，我注意到Nacos与Eureka的共同点和区别：</p><ul><li><strong>共同点</strong>：两者都支持服务注册与发现，以及心跳检测作为健康检查机制。</li><li><strong>区别</strong>：<ul><li>Nacos支持服务端主动检测服务提供者状态，而Eureka依赖客户端心跳。</li><li>Nacos区分临时实例和非临时实例，采用不同的健康检查策略。</li><li>Nacos支持服务列表变更的消息推送，使服务更新更及时。</li><li>Nacos集群默认采用AP模式，但在存在非临时实例时，会采用CP模式；而Eureka始终采用AP模式。</li></ul></li></ul><h5 id="4-你们项目负载均衡如何实现的？">4. 你们项目负载均衡如何实现的？</h5><ol><li>服务注册与元数据管理：所有服务实例启动时会自动注册到 Nacos 注册中心，同时上报自身的元数据（包括 IP、端口、权重、健康状态等信息）。</li><li>负载均衡组件集成：服务消费者端集成了 Spring Cloud LoadBalancer 作为负载均衡客户端，它会通过 Nacos 客户端实时获取目标服务的可用实例列表。</li><li>策略选择与调用：默认采用轮询策略分发请求，确保各实例负载相对均衡。针对不同业务场景，我们还做了策略扩展：<ul><li>对性能差异较大的实例，通过 Nacos 控制台配置权重策略，让高性能实例承担更多流量</li><li>对有会话保持需求的模块（如用户中心），采用 IP 哈希策略确保会话一致性</li><li>核心业务服务启用了最少并发策略，优先调用负载较低的实例</li></ul></li><li>动态调整机制：当服务实例发生扩缩容、权重变更或健康状态变化时，Nacos 会实时推送最新实例列表给客户端，负载均衡组件会自动感知并调整路由决策，无需人工干预。</li></ol><h5 id="6-nacos-Spring-Cloud-LoadBalancer-的负载均衡策略">6. nacos/Spring Cloud LoadBalancer 的负载均衡策略</h5><ol><li>轮询策略（默认）：按照服务实例的顺序依次进行调用，每个实例被调用的机会均等，适用于各实例性能相近的场景。</li><li>权重策略：可以为不同的服务实例设置不同的权重值，权重越高的实例被选中的概率越大。通过 Nacos 控制台可动态调整权重，便于在实例性能有差异时进行流量分配（如给性能好的实例分配更高权重）。</li><li>随机策略：从可用的服务实例中随机选择一个进行调用，适用于对调用顺序无要求的场景。</li><li>最少并发策略：优先选择当前并发量最低的服务实例，可避免请求集中到负载较高的实例上，提高系统整体吞吐量。</li><li>IP 哈希策略：根据请求来源的 IP 地址进行哈希计算，将同一 IP 的请求固定路由到同一个服务实例，适用于需要会话保持的场景。</li></ol><h5 id="7-如果想自定义负载均衡的策略如何实现呢">7. 如果想自定义负载均衡的策略如何实现呢</h5><ol><li>全局策略：实现 ReactorServiceInstanceLoadBalancer 接口，在逻辑中通过 Nacos 客户端获取服务实例列表及元数据，自定义选择规则后，通过配置类将其注册为默认 Bean。</li><li>特定服务策略：通过 @LoadBalancerClient 注解指定服务名和对应的配置类，在配置类中定义该服务专属的负载均衡器 Bean，同样可以结合 Nacos 的实例元数据（如在 Nacos 控制台配置的权重、扩展信息）来实现策略，这样只会对该服务生效。</li></ol><h5 id="8-什么是服务雪崩，怎么解决这个问题">8. 什么是服务雪崩，怎么解决这个问题</h5><p>服务雪崩是指一个服务的失败导致整个链路的服务相继失败。我们通常通过服务降级和服务熔断来解决这个问题：</p><p>服务降级︰服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃，一般在实际开发中与feign接口整合，编写降级逻辑<br>服务熔断∶默认关闭，需要手动打开，如果检测到10秒内请求的失败率超过50%，就触发熔断机制。之后每隔5秒重新尝试请求微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求</p><h5 id="9-你们的微服务是怎么监控的呢">9. 你们的微服务是怎么监控的呢</h5><p>我们项目中采用了SkyWalking进行微服务监控：</p><ol><li>SkyWalking能够监控接口、服务和物理实例的状态，帮助我们识别和优化慢服务。</li><li>我们还设置了告警规则，一旦检测到异常，系统会通过短信或邮件通知相关负责人。</li></ol><h5 id="10-你们项目中有没有做过限流？怎么做的？">10. 你们项目中有没有做过限流？怎么做的？</h5><p>在我们的项目中，由于面临可能的突发流量，我们采用了网关限流策略：</p><p>RequestRateLimiter过滤器进行限流，采用令牌桶算法，可以基于IP或路径进行限流。</p><h5 id="11-限流常见的算法有哪些？">11. 限流常见的算法有哪些？</h5><ol><li><p>漏桶算法</p><p>漏桶算法的实现思路是，有一个固定容量的漏桶，水流（请求）可以按照任意速率先进入到漏桶里，但漏桶总是以固定的速率匀速流出，当流入量过大的时候（超过桶的容量），则多余水流（请求）直接溢出</p></li><li><p>令牌桶算法</p><p>令牌按固定的速率被放入令牌桶中，桶中最多存放 N 个令牌（Token），当桶装满时，新添加的令牌被丢弃或拒绝。当请求到达时，将从桶中删除 1 个令牌。令牌桶中的令牌不仅可以被移除，还可以往里添加，所以为了保证接口随时有数据通过，必须不停地往桶里加令牌。由此可见，往桶里加令牌的速度就决定了数据通过接口的速度。我们通过控制往令牌桶里加令牌的速度从而控制接口的流量</p></li><li><p>区别</p><p>漏桶算法是按照常量固定速率流出请求的，流入请求速率任意，当流入的请求数累积到漏桶容量时，新流入的请求被拒绝。令牌桶算法是按照固定速率往桶中添加令牌的，请求是否被处理需要看桶中的令牌是否足够，当令牌数减为零时，拒绝新的请求。令牌桶算法允许突发请求，只要有令牌就可以处理，允许一定程度的突发流量。漏桶算法限制的是常量流出速率，从而使突发流入速率平滑。 比如服务器空闲时，理论上使用漏桶算法服务器可以直接处理一次洪峰（一次洪水过程的最大流量），但是漏桶算法处理请求的速率是恒定的，因此，前期服务器资源只能根据恒定的漏水速度逐步处理请求，无法直接处理这次洪峰。而使用令牌桶算法就不存在这个问题，因为它可以先把令牌桶一次性装满，处理一次洪峰之后再走限流</p></li></ol><h5 id="12-什么是CAP理论？">12. 什么是CAP理论？</h5><p>CAP理论是分布式系统设计的基础理论，包含一致性(Consistency)、可用性(Availability)和分区容错性(Partition tolerance)。在网络分区发生时，系统只能在一致性和可用性之间选择其一。</p><h5 id="13-什么是BASE理论">13. 什么是BASE理论</h5><p>BASE理论是分布式系统设计中对CAP理论中AP方案的延伸，强调通过基本可用、软状态和最终一致性来实现系统设计。</p><h5 id="14-为什么分布式系统中无法同时保证一致性和可用性？">14. 为什么分布式系统中无法同时保证一致性和可用性？</h5><p>在分布式系统中，为了保证分区容错性，我们通常需要在一致性和可用性之间做出选择。如果系统优先保证一致性，可能需要牺牲可用性，反之亦然。</p><h5 id="15-你们采用哪种分布式事务解决方案？">15. 你们采用哪种分布式事务解决方案？</h5><p>我们项目中使用了<strong>Seata</strong>的AT模式来解决分布式事务问题。AT模式通过记录业务数据的变更日志来保证事务的最终一致性。</p><h5 id="16-分布式服务的接口幂等性如何设计？">16. 分布式服务的接口幂等性如何设计？</h5><p>我们通过Token和<strong>Redis</strong>来实现接口幂等性。用户操作时，系统生成一个Token并存储在Redis中，当用户提交操作时，系统会验证Token的存在性，并在验证通过后删除Token，确保每个Token只被处理一次。</p><h5 id="17-xxl-job路由策略有哪些？">17. xxl-job路由策略有哪些？</h5><p>xxl-job支持多种路由策略，包括轮询、故障转移和分片广播等。</p><h5 id="18-xxl-job任务执行失败怎么解决？">18. xxl-job任务执行失败怎么解决？</h5><p>面对任务执行失败，我们可以：</p><ol><li>选择故障转移路由策略，优先使用健康的实例执行任务。</li><li>设置任务重试次数。</li><li>通过日志记录和邮件告警通知相关负责人。</li></ol><h5 id="19-如果有大数据量的任务同时都需要执行，怎么解决？">19. 如果有大数据量的任务同时都需要执行，怎么解决？</h5><p>我们可以通过部署多个实例并使用分片广播路由策略来分散任务负载。在任务执行代码中，根据分片信息和总数对任务进行分配。</p><h4 id="五、-消息中间件">五、 消息中间件</h4><h5 id="1-RabbitMQ如何保证消息不丢失">1. RabbitMQ如何保证消息不丢失</h5><p>我们使用RabbitMQ来确保MySQL和Redis间数据双写的一致性，这要求我们实现消息的高可用性，具体措施包括：</p><ol><li>开启生产者确认机制，确保消息能被送达队列，如有错误则记录日志并修复数据。</li><li>启用持久化功能，保证消息在未消费前不会在队列中丢失，需要对交换机、队列和消息本身都进行持久化。</li><li>对消费者开启自动确认机制，由spring确认消息处理成功后完成ack，并设置重试次数。例如，我们设置了3次重试，若失败则将消息发送至异常交换机，由人工处理。</li></ol><h5 id="2-RabbitMQ消息的重复消费问题如何解决？">2. RabbitMQ消息的重复消费问题如何解决？</h5><p>嗯，这个我们还真遇到过，是这样的，我们当时消费者是设置了自动确认机制，当服务还没来得及给MQ确认的时候，服务宕机了，导致服务重启之后，又消费了一次消息。这样就重复消费了<br>因为我们当时处理的支付（订单|业务唯一标识)，它有一个业务的唯一标识，我们再处理消息时，先到数据库查询一下，这个数据是否存在，如果不存在，说明没有处理过，这个时候就可以正常处理这个消息了。如果已经存在这个数据了，就说明消息重复消费了，我们就不需要再消费了</p><h5 id="3-那你还知道其他的解决方案吗？">3. 那你还知道其他的解决方案吗？</h5><p>是的，这属于幂等性问题，可以通过以下方法解决：</p><p>使用Redis分布式锁或数据库锁来确保操作的幂等性</p><h5 id="4-RabbitMQ中死信交换机了解吗？（RabbitMQ延迟队列有了解过吗？）">4. RabbitMQ中死信交换机了解吗？（RabbitMQ延迟队列有了解过吗？）</h5><p>嗯!了解过!<br>我们当时的xx项目有一个xx业务，需要用到延迟队列，其中就是使用RabbitMQ来实现的。延迟队列就是用到了死信交换机和TTL（消息存活时间）实现的。<br>如果消息超时未消费就会变成死信，在RabbitMQ中如果消息成为死信，队列可以绑定一个死信交换机，在死信交换机上可以绑定其他队列，在我们发消息的时候可以按照需求指定TTL的时间，这样就实现了延迟队列的功能了。入<br>我记得RabbitMQ还有一种方式可以实现延迟队列，在RabbitMO中安装一个死信插件，这样更方便一些，我们只需要在声明交互机的时候，指定这个就是死信交换机，然后在发送消息的时候直接指定超时时间就行了，相对于死信交换机+TTL要省略了一些步骤</p><h5 id="5-如果有100万消息堆积在MQ，如何解决？（消息堆积该如何解决）">5. 如果有100万消息堆积在MQ，如何解决？（消息堆积该如何解决）</h5><p>我在实际的开发中，没遇到过这种情况，不过，如果发生了堆积的问题，解决方案也所有很多的</p><p>第一: 提高消费者的消费能力,可以使用多线程消费任务<br>第二: 增加更多消费者，提高消费速度</p><p>​ 使用工作队列模式,设置多个消费者消费消费同一个队列中的消息</p><p>第三:扩大队列容积，提高堆积上限</p><p>可以使用RabbitMQ惰性队列，惰性队列的好处主要是<br>①接收到消息后直接存入磁盘而非内存</p><p>②消费者要消费消息时才会从磁盘中读取并加载到内存</p><p>③支持数百万条的消息存储</p><h5 id="6-RabbitMQ的高可用机制了解吗？">6. RabbitMQ的高可用机制了解吗？</h5><p>嗯，熟悉的～<br>我们当时项目在生产环境下，使用的集群，当时搭建是镜像模式集群，使用了3台机器。<br>镜像队列结构是一主多从，所有操作都是主节点完成，然后同步给镜像节点，如果主节点宕机后，镜像节点会替代成新的主节点，不过在主从同步完成前，主节点就已经宕机，可能出现数据丢失</p><h5 id="7-如果出现数据丢失怎么解决呢">7. 如果出现数据丢失怎么解决呢</h5><p>我们可以采用仲裁队列，与镜像队列一样，都是主从模式，支持主从数据同步，主从同步基于Raft协议，强一致。<br>并且使用起来也非常简单，不需要额外的配置，在声明队列的时候只要指定这个是仲裁队列即可</p><h5 id="8-Kafka怎么保证消息不丢失的呢">8. Kafka怎么保证消息不丢失的呢</h5><p>嗯，这个保证机制很多，在发送消息到消费者接收消息，在每个阶段都有可能会丢失消息，所以我们解决的话也是从多个方面考虑<br>第一个是生产者发送消息的时候，可以使用异步回调发送，如果消息发送失败，我们可以通过回调获取失败后的消息信息，可以考虑重试或记录日志，后边再做补偿都是可以的。同时在生产者这边还可以设置消息重试，有的时候是由于网络抖动的原因导致发送不成功，就可以使用重试机制来解决第二个在broker中消息有可能会丢失，我们可以通过kafka的复制机制来确保消息不丢失，在生产者发送消息的时候，可以设置一个acks，就是确认机制。我们可以设置参数为all，这样的话，当生产者发送消息到了分区之后，不仅仅只在leader分区保存确认，在follwer分区也会保存确认，只有当所有的副本都保存确认以后才算是成功发送了消息，所以，这样设置就很大程度了保证了消息不会在broker丢失<br>第三个有可能是在消费者端丢失消息，kafka消费消息都是按照offset进行标记消费的，消费者默认是自动按期提交已经消费的偏移量，默认是每隔5s提交一次，如果出现重平衡的情况，可能会重复消费或丢失数据。我们一般都会禁用掉自动提价偏移量，改为手动提交，当消费成功以后再报告给broker消费的位置，这样就可以避免消息丢失和重复消费了</p><h5 id="9-Kafka中消息的重复消费问题如何解决？">9. Kafka中消息的重复消费问题如何解决？</h5><p>kafka消费消息都是按照offset进行标记消费的，消费者默认是自动按期提交已经消费的偏移量，默认是每隔5s提交一次，如果出现重平衡的情况，可能会重复消费或丢失数据。我们一般都会禁用掉自动提价偏移量，改为手动提交，当消费成功以后再报告给broker消费的位置，这样就可以避免消息丢失和重复消费了</p><h5 id="10-Kafka是如何保证消费的顺序性的呢">10. Kafka是如何保证消费的顺序性的呢</h5><p>kafka默认存储和消费消息，是不能保证顺序性的，因为一个topic数据可能存储在不同的分区中，每个分区都有一个按照顺序的存储的偏移量，如果消费者关联了多个分区不能保证顺序性<br>如果有这样的需求的话，我们是可以解决的，把消息都存储同一个分区下就行了，有两种方式都可以进行设置，第一个是发送消息时指定分区号，第二个是发送消息时按照相同的业务设置相同的key，因为默认情况下分区也是通过key的hashcode值来选择分区的，hash值如果一样的话，分区肯定也是一样的</p><h5 id="11-Kafka的高可用机制了解吗？">11. Kafka的高可用机制了解吗？</h5><p>嗯，主要是有两个层面，第一个是集群，第二个是提供了复制机制</p><p>kafka集群指的是由多个broker实例组成，即使某一台宕机，也不耽误其他broker继续对外提供服务复制机制是可以保证kafka的高可用的，一个topic有多个分区，每个分区有多个副本，有一个leader,其余的是follower，副本存储在不同的broker中;所有的分区副本的内容是都是相同的，如果leader发生故障时，会自动将其中一个follower提升为leader，保证了系统的容错性、高可用性</p><h5 id="12-解释一下复制机制中的ISR？">12. 解释一下复制机制中的ISR？</h5><p>ISR的意思是in-sync replica，就是需要同步复制保存的follower<br>其中分区副本有很多的follower，分为了两类，一个是lSR，与leader副本同步保存数据，另外一个普通的副本，是异步同步数据，当leader挂掉之后，会优先从ISR副本列表中选取一个作为leader，因为ISR是同步保存数据，数据更加的完整一些，所以优先选择ISR副本列表</p><h5 id="13-Kafka的数据清理机制了解吗">13. Kafka的数据清理机制了解吗</h5><p>嗯，了解过～~<br>Kafka中topic的数据存储在分区上，分区如果文件过大会分段存储segment<br>每个分段都在磁盘上以索引(xxx.index)和日志文件(xxxx.log)的形式存储，这样分段的好处是，第一能够减少单个文件内容的大小，查找数据方便，第二方便kafka进行日志清理。</p><p>在kafka中提供了两个日志的清理策略:<br>第一，根据消息的保留时间，当消息保存的时间超过了指定的时间，就会触发清理，默认是168小时（7天)<br>第二是根据topic存储的数据大小，当topic所占的日志文件大小大于一定的阈值，则开始删除最久的消息。这个默认是关闭的<br>这两个策略都可以通过kafka的broker中的配置文件进行设置</p><h5 id="14-Kafka中实现高性能的设计有了解过吗？">14. Kafka中实现高性能的设计有了解过吗？</h5><p>Kafka高性能，是多方面协同的结果，包括宏观架构、分布式存储、ISR数据同步、以及高效的利用磁盘、操作系统特性等。主要体现有这么几点:<br>消息分区:不受单台服务器的限制，可以不受限的处理更多的数据</p><p>顺序读写:磁盘顺序读写，提升读写效率</p><p>页缓存:把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访问</p><p>零拷贝:减少上下文切换及数据拷贝</p><p>消息压缩:减少磁盘IO和网络IO</p><p>分批发送:将消息打包批量发送，减少网络开销</p><h4 id="六、集合篇">六、集合篇</h4><h5 id="1-ArrayList的底层原理是什么">1. ArrayList的底层原理是什么</h5><ul><li><p>ArrayList底层是用动态的数组实现的</p></li><li><p>ArrayList初始容量为0，当第一次添加数据的时候才会初始化容量为10</p></li><li><p>ArrayList在进行扩容的时候是原来容量的1.5倍，每次扩容都需要拷贝数组</p></li><li><p>ArrayList在添加数据的时候</p><ul><li><p>确保数组已使用长度(size)加1之后足够存下下一个数据</p></li><li><p>计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的1.5倍)</p></li><li><p>确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。</p></li><li><p>返回添加成功布尔值。</p></li></ul></li></ul><h5 id="2-面试题-ArrayList-list-new-ArrayList-10-中的list扩容几次-少考">2. 面试题-ArrayList list=new ArrayList(10)中的list扩容几次(少考)</h5><p>该语句只是声明和实例了一个 ArrayList，指定了容量为 10，未扩容</p><h5 id="3-如何实现数组和List之间的转换（少考）">3. 如何实现数组和List之间的转换（少考）</h5><ul><li>数组转List ，使用JDK中java.util.Arrays工具类的asList方法</li><li>List转数组，使用List的toArray方法。无参toArray方法返回 Object数组，传入初始化长度的数组对象，返回该对象数组</li></ul><h5 id="4-用Arrays-asList转List后，如果修改了数组内容，list受影响吗">4. 用Arrays.asList转List后，如果修改了数组内容，list受影响吗</h5><p>Arrays.asList转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个数组进行了包装而已，最终指向的都是同一个内存地址</p><h5 id="5-List用toArray转数组后，如果修改了List内容，数组受影响吗">5. List用toArray转数组后，如果修改了List内容，数组受影响吗</h5><p>list用了toArray转数组后，如果修改了list内容，数组不会影响，当调用了toArray以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响</p><h5 id="6-面试题-ArrayList和LinkedList的区别是什么？-常考">6. 面试题-ArrayList和LinkedList的区别是什么？(常考)</h5><p>底层数据结构</p><ul><li>ArrayList 是动态数组的数据结构实现</li><li>LinkedList 是双向链表的数据结构实现</li></ul><p>操作数据效率</p><ul><li>ArrayList按照下标查询的时间复杂度O(1)【内存是连续的，根据寻址公式】， LinkedList不支持下标查询</li><li>查找（未知索引）： ArrayList需要遍历，链表也需要遍历，时间复杂度都是O(n)</li><li>新增和删除<ul><li>ArrayList尾部插入和删除，时间复杂度是O(1)；其他部分增删需要挪动数组，时间复杂度是O(n)</li><li>LinkedList头尾节点增删时间复杂度是O(1)，其他都需要遍历链表，时间复杂度是O(n)</li></ul></li></ul><p>内存空间占用</p><ul><li>ArrayList底层是数组，内存连续，节省内存</li><li>LinkedList 是双向链表需要存储数据，和两个指针，更占用内存</li></ul><p>线程安全</p><ul><li>ArrayList和LinkedList都不是线程安全的</li><li>如果需要保证线程安全，有两种方案：<ul><li>在方法内使用，局部变量则是线程安全的</li><li>使用线程安全的ArrayList和LinkedList</li></ul></li></ul><h6 id="嗯，好的，刚才你说了ArrayList-和-LinkedList-不是线程安全的，你们在项目中是如何解决这个的线程安全问题的？">嗯，好的，刚才你说了ArrayList 和 LinkedList 不是线程安全的，你们在项目中是如何解决这个的线程安全问题的？</h6><p>嗯，是这样的，主要有两种解决方案：</p><p>第一：我们使用这个集合，优先在方法内使用，定义为局部变量，这样的话，就不会出现线程安全问题。</p><p>第二：如果非要在成员变量中使用的话，可以使用线程安全的集合来替代</p><p>ArrayList可以通过Collections 的 synchronizedList 方法将 ArrayList 转换成线程安全的容器后再使用。</p><p>LinkedList 换成ConcurrentLinkedQueue来使用</p><h5 id="7-说一下HashMap的实现原理（易考）">7. 说一下HashMap的实现原理（易考）</h5><p>HashMap的数据结构： 底层使用hash表数据结构，即数组和链表或红黑树</p><ol><li><p>当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</p></li><li><p>存储时，如果出现hash值相同的key，此时有两种情况。</p><p>a. 如果key相同，则覆盖原始值；</p><p>b. 如果key不同（出现冲突），则将当前的key-value放入链表或红黑树中</p></li><li><p>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</p></li></ol><h5 id="8-面试题-HashMap的put方法的具体流程">8. 面试题-HashMap的put方法的具体流程</h5><ol><li><p>判断键值对数组table是否为空或为null，否则执行resize()进行扩容（初始化)</p></li><li><p>根据键值key计算hash值得到数组索引</p></li><li><p>判断table[i]==null，条件成立，直接新建节点添加</p></li><li><p>如果table[i]==null ,不成立</p><p>4.1判断table[i]的首个元素是否和key一样，如果相同直接覆盖value</p><p>4.2判断table[i]是否为treeNode，即table[i]是否是红黑树，如果是红黑树，则直接在树中插入键值对</p><p>4.3遍历tablei]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，遍历过程中若发现key已经存在直接覆盖value</p></li><li><p>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold(数组长度*0.75)，如果超过，进行扩容.</p></li></ol><h5 id="9-讲一讲HashMap的扩容机制">9. 讲一讲HashMap的扩容机制</h5><p>在添加元素或初始化的时候需要调用resize方法进行扩容，第一次添加数据初始化数组长度为16，以后每次每次扩容都是达到了扩容阈值（数组长度 * 0.75）</p><p>每次扩容的时候，都是扩容之前容量的2倍；</p><p>扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中</p><ul><li>没有hash冲突的节点，则直接使用 e.hash &amp; (newCap - 1) 计算新数组的索引位置</li><li>如果是红黑树，走红黑树的添加</li><li>如果是链表，则需要遍历链表，可能需要拆分链表，判断(e.hash &amp; oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</li></ul><h5 id="10-HashMap的寻址方法">10. HashMap的寻址方法</h5><ol><li>计算对象的 hashCode()</li><li>再进行调用hash()方法进行二次哈希， hashcode值右移16位再异或运算，让哈希分布更为均匀</li><li>最后(capacity - 1)&amp; hash 得到索引</li></ol><h5 id="11-为什么HashMap的数组长度一定是2的次幂">11. 为什么HashMap的数组长度一定是2的次幂</h5><p>嗯，好的。hashmap这么设计主要有两个原因：</p><p>第一：</p><p>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模</p><p>第二：</p><p>扩容时重新计算索引效率更高：在进行扩容时会进行判断 hash值按位与运算旧数组长租是否 == 0</p><p>如果等于0，则把元素留在原来位置 ，否则新位置是等于旧位置的下标+旧数组长度</p><h5 id="12-hashmap在1-7情况下的多线程死循环问题">12. hashmap在1.7情况下的多线程死循环问题</h5><p>在jdk1.7的hashmap中在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环</p><p>比如说，现在有两个线程</p><p>线程一：读取到当前的hashmap数据，数据中一个链表，在准备扩容时，线程二介入</p><p>线程二：也读取hashmap，直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是AB，扩容后的顺序是BA，线程二执行结束。</p><p>线程一：继续执行的时候就会出现死循环的问题。</p><p>线程一先将A移入新的链表，再将B插入到链头，由于另外一个线程的原因，B的next指向了A，</p><p>所以B-&gt;A-&gt;B,形成循环。</p><p>当然，JDK 8 将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），<strong>尾插法</strong>，就避免了jdk7中死循环的问题。</p><h5 id="13-HashSet与HashMap的区别">13. HashSet与HashMap的区别</h5><p>(1)HashSet实现了Set接口, 仅存储对象; HashMap实现了 Map接口, 存储的是键值对.</p><p>(2)HashSet底层其实是用HashMap实现存储的, HashSet封装了一系列HashMap的方法. 依靠HashMap来存储元素值,(利用hashMap的key键进行存储), 而value值默认为Object对象. 所以HashSet也不允许出现重复值, 判断标准和HashMap判断标准相同, 两个元素的hashCode相等并且通过equals()方法返回true.</p><h5 id="15-说一说Java提供的常见集合？">15. 说一说Java提供的常见集合？</h5><p>在java中提供了两大类的集合框架，主要分为两类：</p><p>第一个是Collection 属于单列集合，第二个是Map 属于双列集合</p><ul><li>在Collection中有两个子接口List和Set。在我们平常开发的过程中用的比较多像list接口中的实现类ArrarList和LinkedList。 在Set接口中有实现类HashSet和TreeSet。</li><li>在map接口中有很多的实现类，平时比较常见的是HashMap、TreeMap，还有一个线程安全的map:ConcurrentHashMap</li></ul><h5 id="16-ArrayList底层是如何实现的？">16. ArrayList底层是如何实现的？</h5><p>嗯~，我阅读过arraylist的源码，我主要说一下add方法吧</p><p>第一：确保数组已使用长度（size）加1之后足够存下下一个数据</p><p>第二：计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的1.5倍）</p><p>第三：确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。</p><p>第四：返回添加成功布尔值。</p><h5 id="17-HashTable与HashMap的区别">17. HashTable与HashMap的区别</h5><p>嗯，他们的主要区别是有几个吧</p><p>第一，数据结构不一样，hashtable是数组+链表，hashmap在1.8之后改为了数组+链表+红黑树</p><p>第二，hashtable存储数据的时候都不能为null，而hashmap是可以的</p><p>第三，hash算法不同，hashtable是用本地修饰的hashcode值，而hashmap经常了二次hash</p><p>第四，扩容方式不同，hashtable是当前容量翻倍+1，hashmap是当前容量翻倍</p><p>第五，hashtable是线程安全的，操作数据的时候加了锁synchronized，hashmap不是线程安全的，效率更高一些</p><p>在实际开中不建议使用HashTable，在多线程环境下可以使用ConcurrentHashMap类</p><h4 id="七、多线程篇（易考）">七、多线程篇（易考）</h4><h5 id="1-进程和线程区别">1. 进程和线程区别</h5><p>进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务</p><p>不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间</p><p>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)</p><h5 id="2-并行和并发有什么区别？">2. 并行和并发有什么区别？</h5><p>现在都是多核CPU，在多核CPU下</p><p>并发是同一时间应对多件事情的能力，多个线程轮流使用一个或多个CPU</p><p>并行是同一时间动手做多件事情的能力，4核CPU同时执行4个线程</p><h5 id="3-创建线程的方式有哪些（易考）">3. 创建线程的方式有哪些（易考）</h5><p>在java中一共有四种常见的创建方式，分别是：继承Thread类、实现runnable接口、实现Callable接口、线程池创建线程。通常情况下，我们项目中都会采用线程池的方式创建线程。</p><h5 id="4-runnable-和-callable-有什么区别">4. runnable 和 callable 有什么区别</h5><ol><li>Runnable 接口run方法没有返回值；Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</li><li>Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</li><li>Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛</li></ol><h5 id="5-线程的-run-和-start-有什么区别？">5. 线程的 run()和 start()有什么区别？</h5><p>start(): 用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。</p><p>run(): 封装了要被线程执行的代码，可以被调用多次。</p><h5 id="6-线程包括了哪些状态，状态之间是如何变化的">6. 线程包括了哪些状态，状态之间是如何变化的</h5><p>在JDK中的Thread类中的枚举State里面定义了6中线程的状态分别是：新建、可运行、终结、阻塞、等待和有时限等待六种。</p><p>关于线程的状态切换情况比较多。我分别介绍一下</p><p>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态，调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong>状态。如果线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong>状态。当然这些是一个线程正常执行情况。</p><p>如果线程获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，只有当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</p><p>如果线程获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁<strong>等待</strong>状态，当其它持锁线程调用 notify() 或 notifyAll() 方法，会恢复为<strong>可运行</strong>状态</p><p>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</p><h5 id="7-新建-T1、T2、T3-三个线程，如何保证它们按顺序执行？">7. 新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？</h5><p>嗯~~，我思考一下 （适当的思考或想一下属于正常情况，脱口而出反而太假[背诵痕迹]）</p><p>可以这么做，在多线程中有多种方法让线程按特定顺序执行，可以用线程类的<strong>join</strong>()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。</p><p>比如说：</p><p>使用join方法，T3调用T2，T2调用T1，这样就能确保T1就会先完成而T3最后完成</p><h5 id="8-notify-和-notifyAll-有什么区别？">8. notify()和 notifyAll()有什么区别？</h5><p>notifyAll：唤醒所有wait的线程</p><p>notify：只随机唤醒一个 wait 线程</p><h5 id="9-在-java-中-wait-和-sleep-方法的不同？">9. 在 java 中 wait 和 sleep 方法的不同？</h5><p>共同点</p><ul><li>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</li></ul><p>不同点</p><ul><li>方法归属不同<ul><li>sleep(long) 是 Thread 的静态方法</li><li>而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有</li></ul></li><li>醒来时机不同<ul><li>执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</li><li>wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去</li><li>它们都可以被打断唤醒</li></ul></li><li>锁特性不同（重点）<ul><li>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制</li><li>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）</li><li>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）</li></ul></li></ul><h5 id="10-如何停止一个正在运行的线程">10. 如何停止一个正在运行的线程</h5><p>有三种方式可以停止线程</p><ul><li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止</li><li>使用stop方法强行终止（不推荐，方法已作废）</li><li>使用interrupt方法中断线程</li></ul><h5 id="11-讲一下synchronized关键字的底层原理？">11. 讲一下synchronized关键字的底层原理？</h5><p>synchronized 底层使用的JVM级别中的Monitor 来决定当前线程是否获得了锁，如果某一个线程获得了锁，在没有释放锁之前，其他线程是不能或得到锁的。synchronized 属于悲观锁。</p><p>synchronized 因为需要依赖于JVM级别的Monitor ，相对性能也比较低。</p><p>monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因</p><p>monitor内部维护了三个变量</p><ul><li>WaitSet：保存处于Waiting状态的线程</li><li>EntryList：保存处于Blocked状态的线程</li><li>Owner：持有锁的线程</li></ul><p>只有一个线程获取到的标志就是在monitor中设置成功了Owner，一个monitor中只能有一个Owner</p><p>在上锁的过程中，如果有其他线程也来抢锁，则进入EntryList 进行阻塞，当获得锁的线程执行完了，释放了锁，就会唤醒EntryList 中等待的线程竞争锁，竞争的时候是非公平的。</p><h5 id="12-synchronized关键字的底层原理-进阶">12. synchronized关键字的底层原理-进阶</h5><p>Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。</p><p>重量级锁：底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。</p><p>轻量级锁：线程加锁的时间是错开的（也就是没有竞争），可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性</p><p>偏向锁：一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark word中是否是自己的线程id即可，而不是开销相对较大的CAS命令</p><p>一旦锁发生了竞争，都会升级为重量级锁</p><h5 id="13-你谈谈-JMM（Java-内存模型）">13. 你谈谈 JMM（Java 内存模型）</h5><p>Java内存模型是Java虚拟机规范中定义的一种非常重要的内存模型。它的主要作用是描述Java程序中线程共享变量的访问规则，以及这些变量在JVM中是如何被存储和读取的，涉及到一些底层的细节。</p><p>这个模型有几个核心的特点。首先，所有的共享变量，包括实例变量和类变量，都被存储在主内存中，也就是计算机的RAM。需要注意的是，局部变量并不包含在内，因为它们是线程私有的，所以不存在竞争问题。</p><p>其次，每个线程都有自己的工作内存，这里保留了线程所使用的变量的工作副本。这意味着，线程对变量的所有操作，无论是读还是写，都必须在自己的工作内存中完成，而不能直接读写主内存中的变量。</p><p>最后，不同线程之间不能直接访问对方工作内存中的变量。如果线程间需要传递变量的值，那么这个过程必须通过主内存来完成。</p><h5 id="14-谈谈你对CAS的理解">14. 谈谈你对CAS的理解</h5><p>CAS的全称是： Compare And Swap(比较再交换);它体现的一种乐观锁的思想，在无锁状态下保证线程操作数据的原子性。</p><ul><li>CAS使用到的地方很多：AQS框架、AtomicXXX类</li><li>在操作共享变量的时候使用的自旋锁，效率上更高一些</li><li>CAS的底层是调用的Unsafe类中的方法，都是操作系统提供的，其他语言实现</li></ul><h5 id="15-谈谈你对volatile的理解">15. 谈谈你对volatile的理解</h5><p>volatile 是一个关键字，可以修饰类的成员变量、类的静态成员变量，主要有两个功能</p><p>第一：保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。</p><p>第二： 禁止进行指令重排序，可以保证代码执行有序性。底层实现原理是，添加了一个<strong>内存屏障</strong>，通过插入内存屏障禁止在内存屏障<strong>前后</strong>的指令执行重排序优化</p><h5 id="16-什么是AQS">16. 什么是AQS</h5><p>AQS的话，其实就一个jdk提供的类AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架。</p><p>内部有一个属性 state 属性来表示资源的状态，默认state等于0，表示没有获取锁，state等于1的时候才标明获取到了锁。通过cas 机制设置 state 状态</p><p>在它的内部还提供了基于 FIFO 的等待队列，是一个双向列表，其中</p><ul><li>tail 指向队列最后一个元素</li><li>head 指向队列中最久的一个元素</li></ul><p>其中我们刚刚聊的ReentrantLock底层的实现就是一个AQS。</p><h5 id="17-ReentrantLock的实现原理">17. ReentrantLock的实现原理</h5><p>ReentrantLock是一个可重入锁:，调用 lock 方 法获取了锁之后，再次调用 lock，是不会再阻塞，内部直接增加重入次数 就行了，标识这个线程已经重复获取一把锁而不需要等待锁的释放。</p><p>ReentrantLock是属于juc报下的类，属于api层面的锁，跟synchronized一样，都是悲观锁。通过lock()用来获取锁，unlock()释放锁。</p><p>它的底层实现原理主要利用<strong>CAS+AQS队列</strong>来实现。它支持公平锁和非公平锁，两者的实现类似</p><p>构造方法接受一个可选的公平参数（<strong>默认非公平锁</strong>），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高。</p><h5 id="18-synchronized和Lock有什么区别-（易考）">18. synchronized和Lock有什么区别 ? （易考）</h5><p>第一，语法层面</p><ul><li>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现，退出同步代码块锁会自动释放</li><li>Lock 是接口，源码由 jdk 提供，用 java 语言实现，需要手动调用 unlock 方法释放锁</li></ul><p>第二，功能层面</p><ul><li>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</li><li>Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量，同时Lock 可以实现不同的场景，如 ReentrantLock， ReentrantReadWriteLock</li></ul><p>第三，性能层面</p><ul><li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li><li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li></ul><p>统合来看，需要根据不同的场景来选择不同的锁的使用。</p><h5 id="19-死锁产生的条件是什么？">19. 死锁产生的条件是什么？</h5><p>嗯，是这样的，一个线程需要同时获取多把锁，这时就容易发生死锁，举个例子来说：</p><p>t1 线程获得A对象锁，接下来想获取B对象的锁</p><p>t2 线程获得B对象锁，接下来想获取A对象的锁</p><p>这个时候t1线程和t2线程都在互相等待对方的锁，就产生了死锁</p><h5 id="20-如何进行死锁诊断？">20. 如何进行死锁诊断？</h5><p>我们只需要通过jdk自动的工具就能搞定</p><p>我们可以先通过jps来查看当前java程序运行的进程id</p><p>然后通过jstack来查看这个进程id，就能展示出来死锁的问题，并且，可以定位代码的具体行号范围，我们再去找到对应的代码进行排查就行了。</p><h5 id="21-聊一下ConcurrentHashMap-易考">21. 聊一下ConcurrentHashMap (易考)</h5><p>ConcurrentHashMap 是一种线程安全的高效Map集合，jdk1.7和1.8也做了很多调整。</p><ul><li>JDK1.7的底层采用是<strong>分段的数组</strong>+<strong>链表</strong> 实现</li><li>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。</li></ul><p>在jdk1.7中 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一 种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构 的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修 改时，必须首先获得对应的 Segment的锁。</p><p>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元 素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁</p><p>在jdk1.8中的ConcurrentHashMap 做了较大的优化，性能提升了不少。首先是它的数据结构与jdk1.8的hashMap数据结构完全一致。其次是放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保 证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲 突，就不会产生并发 , 效率得到提升</p><h5 id="22-导致并发程序出现问题的根本原因是什么">22. 导致并发程序出现问题的根本原因是什么</h5><p>Java并发编程有三大核心特性，分别是原子性、可见性和有序性。</p><p>首先，原子性指的是一个线程在CPU中的操作是不可暂停也不可中断的，要么执行完成，要么不执行。比如，一些简单的操作如赋值可能是原子的，但复合操作如自增就不是原子的。为了保证原子性，我们可以使用synchronized关键字或JUC里面的Lock来进行加锁。</p><p>其次，可见性是指让一个线程对共享变量的修改对另一个线程可见。由于线程可能在自己的工作内存中缓存共享变量的副本，因此一个线程对共享变量的修改可能不会立即反映在其他线程的工作内存中。为了解决这个问题，我们可以使用synchronized关键字、volatile关键字或Lock来确保可见性。</p><p>最后，有序性是指处理器为了提高程序运行效率，可能会对输入代码进行优化，导致程序中各个语句的执行先后顺序与代码中的顺序不一致。虽然处理器会保证程序最终执行结果与代码顺序执行的结果一致，但在某些情况下我们可能需要确保特定的执行顺序。为了解决这个问题，我们可以使用volatile关键字来禁止指令重排。</p><h5 id="23-项目中有没有用到线程池，以及线程数是怎么设置的和拒绝策略是怎么设置的">23. 项目中有没有用到线程池，以及线程数是怎么设置的和拒绝策略是怎么设置的</h5><p>线程池的使用场景：</p><p>我们当时在项目中确实使用了线程池，主要用于异步处理AI大模型的请求。因为AI接口的响应时间比较长，如果使用同步调用会阻塞主线程，所以我们使用线程池来处理这些异步任务。</p><p>线程池配置：</p><p>我们创建了一个自定义的线程池，核心线程数设置为5，最大线程数设置为20，队列容量设置为100。这样配置是因为AI请求不是特别频繁，但单个请求耗时较长，所以需要足够的线程来处理并发请求。</p><p>线程数设置原则：</p><p>我们按照CPU密集型任务来设置线程数，因为AI请求主要是网络IO和计算密集型操作。考虑到我们的服务器是4核CPU，我们设置核心线程数为5，最大线程数为20，这样可以充分利用CPU资源，同时避免创建过多线程导致上下文切换开销。</p><p>拒绝策略设置：</p><p>我们使用了CallerRunsPolicy作为拒绝策略，当线程池和队列都满了时，新任务会由调用线程来执行。这样虽然会阻塞调用线程，但能保证任务不会丢失，对于AI请求这种重要业务来说是比较合适的选择。</p><p>实际效果：</p><p>使用线程池后，AI接口的响应时间从原来的3-5秒降低到1-2秒，用户体验得到了显著提升。同时系统的并发处理能力也得到了增强，能够支持更多的用户同时使用AI功能。</p><h5 id="24-说一下线程池的核心参数（线程池的执行原理知道嘛）（易考）">24. 说一下线程池的核心参数（线程池的执行原理知道嘛）（易考）</h5><p>在线程池中一共有7个核心参数：</p><ol><li>corePoolSize 核心线程数目 - 池中会保留的最多线程数</li><li>maximumPoolSize 最大线程数目 - 核心线程+救急线程的最大数目</li><li>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</li><li>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</li><li>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</li><li>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</li><li>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略</li></ol><p>拒绝策略有4种，当线程数过多以后，第一种是抛异常、第二种是由调用者执行任务、第三是丢弃当前的任务，第四是丢弃最早排队任务。默认是直接抛异常。</p><h5 id="25-线程池中有哪些常见的阻塞队列">25. 线程池中有哪些常见的阻塞队列</h5><p>Jdk中提供了很多阻塞队列，开发中常见的有两个：<code>ArrayBlockingQueue</code>和<code>LinkedBlockingQueue</code></p><p><code>ArrayBlockingQueue</code>和<code>LinkedBlockingQueue</code>是Java中两种常见的阻塞队列，它们在实现和使用上有一些关键的区别。</p><p>首先，<code>ArrayBlockingQueue</code>是一个有界队列，它在创建时必须指定容量，并且这个容量不能改变。而<code>LinkedBlockingQueue</code>默认是无界的，但也可以在创建时指定最大容量，使其变为有界队列。</p><p>其次，它们在内部数据结构上也有所不同。<code>ArrayBlockingQueue</code>是基于数组实现的，而<code>LinkedBlockingQueue</code>则是基于链表实现的。这意味着<code>ArrayBlockingQueue</code>在访问元素时可能会更快，因为它可以直接通过索引访问数组中的元素。而<code>LinkedBlockingQueue</code>则在添加和删除元素时可能更快，因为它不需要移动其他元素来填充空间。</p><p>另外，它们在加锁机制上也有所不同。<code>ArrayBlockingQueue</code>使用一把锁来控制对队列的访问，这意味着读写操作都是互斥的。而<code>LinkedBlockingQueue</code>则使用两把锁，一把用于控制读操作，另一把用于控制写操作，这样可以提高并发性能。</p><h5 id="26-如何确定核心线程数">26. 如何确定核心线程数</h5><p>① 高并发、任务执行时间短 --&gt;（ CPU核数+1 ），减少线程上下文的切换</p><p>② 并发不高、任务执行时间长</p><ul><li>IO密集型的任务 --&gt; (CPU核数 * 2 + 1)</li><li>计算密集型任务 --&gt; （ CPU核数+1 ）</li></ul><p>③ 并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，参考CPU核数*2+1</p><h5 id="27-线程池的种类有哪些">27. 线程池的种类有哪些</h5><p>在jdk中默认提供了4中方式创建线程池</p><p>第一个是：newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回 收空闲线程，若无可回收，则新建线程。</p><p>第二个是：newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列 中等待。</p><p>第三个是：newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</p><p>第四个是：newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任 务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p><h5 id="28-为什么不建议用Executors创建线程池">28. 为什么不建议用Executors创建线程池</h5><p>其实这个事情在阿里提供的最新开发手册《Java开发手册-嵩山版》中也提到了</p><p>主要原因是如果使用Executors创建线程池的话，它允许的请求队列默认长度是Integer.MAX_VALUE，这样的话，有可能导致堆积大量的请求，从而导致OOM（内存溢出）。</p><p>所以，我们一般推荐使用ThreadPoolExecutor来创建线程池，这样可以明确规定线程池的参数，避免资源的耗尽。</p><h5 id="29-线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）">29. 线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）</h5><p>我们当时在项目中主要在两个地方使用了多线程：一个是AI大模型请求的异步处理，另一个是批量数据导入的并行处理。</p><p>我们使用CompletableFuture来处理AI请求的异步结果。比如医生提交病历分析请求后，我们返回一个Future对象，前端可以轮询这个Future来获取处理结果。当AI分析完成后，我们会将结果存储到缓存中，前端通过轮询获取到最终结果。</p><p>当管理员需要导入大量患者数据时，我们会将数据分批处理，每批数据使用一个线程来处理，最后使用Future.allOf()等待所有批次处理完成。这样既提升了处理速度，又保证了数据的一致性。</p><p>我们创建了一个异步服务类，使用@Async注解标记异步方法，返回CompletableFuture类型。在调用时，我们可以通过Future.get()方法获取结果，或者使用回调函数处理结果。大大改善了用户体验感</p><h5 id="30-如何控制某个方法允许并发访问线程的数量？">30. 如何控制某个方法允许并发访问线程的数量？</h5><p>嗯~~，我想一下</p><p>在jdk中提供了一个Semaphore[seməfɔːr]类（信号量）</p><p>它提供了两个方法，semaphore.acquire() 请求信号量，可以限制线程的个数，是一个正数，如果信号量是0,就代表已经用完了信号量，其他线程需要阻塞了</p><p>第二个方法是semaphore.release()，代表是释放一个信号量，此时信号量的个数+1</p><h5 id="31-谈谈你对ThreadLocal的理解（易考）">31.谈谈你对ThreadLocal的理解（易考）</h5><p>嗯，是这样的~~</p><p>ThreadLocal 主要功能有两个，第一个是可以实现资源对象的线程隔离，让每个线程各用各的资源对象，避免争用引发的线程安全问题，第二个是实现了线程内的资源共享</p><h5 id="32-好的，那你知道ThreadLocal的底层原理实现吗？">32. 好的，那你知道ThreadLocal的底层原理实现吗？</h5><p>嗯，知道一些~</p><p>在ThreadLocal内部维护了一个一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p><p>当我们调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</p><p>当调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</p><p>当调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</p><h5 id="33-好的，那关于ThreadLocal会导致内存溢出这个事情，了解吗？">33. 好的，那关于ThreadLocal会导致内存溢出这个事情，了解吗？</h5><p>嗯，我之前看过源码，我想一下~~</p><p>是因为ThreadLocalMap 中的 key 被设计为弱引用，它是被动的被GC调用释放key，不过关键的是只有key可以得到内存释放，而value不会，因为value是一个强引用。</p><p>在使用ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收，建议主动的remove 释放 key，这样就能避免内存溢出。</p><h5 id="34-我看你的项目中有使用ThreadLocal，谈谈你对他的理解">34. 我看你的项目中有使用ThreadLocal，谈谈你对他的理解</h5><p>ThreadLocal是Java提供的一个线程本地变量，每个线程都有自己独立的变量副本，线程之间互不干扰。它通过ThreadLocalMap来实现线程隔离，每个线程都有自己的ThreadLocalMap来存储变量。</p><p>我们当时在项目中主要用ThreadLocal来存储当前登录用户的信息。当用户登录后，我们将用户信息存储到ThreadLocal中，这样在整个请求处理过程中，任何地方都可以通过ThreadLocal获取到当前用户信息，而不需要每次都传递用户参数。</p><p>使用ThreadLocal后，我们不需要在每个方法中传递用户参数，代码更加简洁。同时，由于每个线程都有独立的变量副本，避免了线程安全问题，不需要使用synchronized等同步机制。</p><p>在使用ThreadLocal时，我们需要注意内存泄漏问题。如果ThreadLocal变量没有及时清理，可能会导致内存泄漏。所以我们会在请求处理完成后主动清理ThreadLocal，确保资源的正确释放。</p><h4 id="八、JVM">八、JVM</h4><h5 id="1-JVM由那些部分组成，运行流程是什么？（易考）">1. JVM由那些部分组成，运行流程是什么？（易考）</h5><p>嗯，好的~~</p><p>在JVM中共有四大部分，分别是ClassLoader（类加载器）、Runtime Data Area（运行时数据区，内存分区）、Execution Engine（执行引擎）、Native Method Library（本地库接口）</p><p>它们的运行流程是：</p><p>第一，类加载器（ClassLoader）把Java代码转换为字节码</p><p>第二，运行时数据区（Runtime Data Area）把字节码加载到内存中，而字节码文件只是JVM的一套指令集规范，并不能直接交给底层系统去执行，而是有执行引擎运行</p><p>第三，执行引擎（Execution Engine）将字节码翻译为底层系统指令，再交由CPU执行去执行，此时需要调用其他语言的本地库接口（Native Method Library）来实现整个程序的功能。</p><h5 id="2-什么是程序计数器？（易考）">2. 什么是程序计数器？（易考）</h5><p>嗯，是这样~~</p><p>java虚拟机对于多线程是通过线程轮流切换并且分配线程执行时间。在任何的一个时间点上，一个处理器只会处理执行一个线程，如果当前被执行的这个线程它所分配的执行时间用完了【挂起】。处理器会切换到另外的一个线程上来进行执行。并且这个线程的执行时间用完了，接着处理器就会又来执行被挂起的这个线程。这时候程序计数器就起到了关键作用，程序计数器在来回切换的线程中记录他上一次执行的行号，然后接着继续向下执行。</p><h5 id="3-介绍一下Java的堆">3. 介绍一下Java的堆</h5><p>好的~</p><p>Java中的堆术语线程共享的区域。主要用来保存<strong>对象实例，数组</strong>等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。</p><p>​ 在JAVA8中堆内会存在年轻代、老年代</p><p>​ 1）Young区被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中，Survivor区间中，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用。在Eden区变满的时候， GC就会将存活的对象移到空闲的Survivor区间中，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到Tenured区间。</p><p>​ 2）Tenured区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在Young复制转移一定的次数以后，对象就会被转移到Tenured区。</p><h5 id="4-什么是虚拟机栈">4. 什么是虚拟机栈</h5><p>虚拟机栈是描述的是方法执行时的内存模型,是线程私有的，生命周期与线程相同,每个方法被执行的同时会创建<strong>栈桢</strong>。保存执行方法时的<strong>局部变量、动态连接信息、方法返回地址信息</strong>等等。方法开始执行的时候会进栈，方法执行完会出栈【相当于清空了数据】，所以这块区域<strong>不需要进行 GC</strong>。</p><h5 id="5-垃圾回收是否涉及栈内存？">5. 垃圾回收是否涉及栈内存？</h5><p>垃圾回收主要指就是堆内存，当栈帧弹栈以后，内存就会释放</p><h5 id="6-栈内存分配越大越好吗？">6. 栈内存分配越大越好吗？</h5><p>未必，默认的栈内存通常为1024k</p><p>栈帧过大会导致线程数变少，例如，机器总内存为512m，目前能活动的线程数则为512个，如果把栈内存改为2048k，那么能活动的栈帧就会减半</p><h5 id="7-方法内的局部变量是否线程安全？">7. 方法内的局部变量是否线程安全？</h5><p>如果方法内局部变量没有逃离方法的作用范围，它是线程安全的</p><p>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</p><h5 id="8-栈内存溢出情况">8. <strong>栈内存溢出情况</strong></h5><p>栈帧过多导致栈内存溢出，典型问题：递归调用</p><p>栈帧过大导致栈内存溢出</p><h5 id="9-栈和堆的区别呢">9. 栈和堆的区别呢</h5><p>嗯，好的，有这几个区别</p><p>第一，栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会。</p><p>第二、栈内存是线程私有的，而堆内存是线程共有的。</p><p>第三、两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。</p><p>栈空间不足：java.lang.StackOverFlowError。</p><p>堆空间不足：java.lang.OutOfMemoryError。</p><h5 id="10-能不能解释一下方法区">10. 能不能解释一下方法区</h5><p>好的~</p><p>与虚拟机栈类似。本地方法栈是为虚拟机<strong>执行本地方法时提供服务的</strong>。不需要进行GC。本地方法一般是由其他语言编写。</p><h5 id="11-解释一下运行常量池">11. 解释一下运行常量池</h5><p>常量池:可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息<br>当类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</p><h5 id="12-说一下-JVM-运行时数据区">12. 说一下 JVM 运行时数据区</h5><p>嗯，好~</p><p>运行时数据区包含了堆、方法区、栈、本地方法栈、程序计数器这几部分，每个功能作用不一样。</p><ul><li>堆解决的是对象实例存储的问题，垃圾回收器管理的主要区域。</li><li>方法区可以认为是堆的一部分，用于存储已被虚拟机加载的信息，常量、静态变量、即时编译器编译后的代码。</li><li>栈解决的是程序运行的问题，栈里面存的是栈帧，栈帧里面存的是局部变量表、操作数栈、动态链接、方法出口等信息。</li><li>本地方法栈与栈功能相同，本地方法栈执行的是本地方法，一个Java调用非Java代码的接口。</li><li>程序计数器（PC寄存器）程序计数器中存放的是当前线程所执行的字节码的行数。JVM工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令。</li></ul><h5 id="13-你听过直接内存吗？">13. 你听过直接内存吗？</h5><p>嗯~~</p><p>它又叫做<strong>堆外内存</strong>，<strong>线程共享的区域</strong>，在 Java 8 之前有个<strong>永久代</strong>的概念，实际上指的是 HotSpot 虚拟机上的永久代，它用永久代实现了 JVM 规范定义的方法区功能，<strong>主要存储类的信息，常量，静态变量</strong>，即时编译器编译后代码等，这部分由于是在堆中实现的，受 GC 的管理，不过由于永久代有 -XX:MaxPermSize 的上限，所以如果大量动态生成类（将类信息放入永久代），很容易造成 OOM，有人说可以把永久代设置得足够大，但很难确定一个合适的大小，受类数量，常量数量的多少影响很大。</p><p>​ 所以在 Java 8 中就把方法区的实现移到了本地内存中的元空间中，这样方法区就不受 JVM 的控制了,也就不会进行 GC，也因此提升了性能。</p><h5 id="14-什么是类加载器，类加载器有哪些">14. 什么是类加载器，类加载器有哪些?</h5><p>嗯，是这样的</p><p>JVM只会运行二进制文件，而类加载器（ClassLoader）的主要作用就是将<strong>字节码文件加载到JVM中</strong>，从而让Java程序能够启动起来。</p><p>常见的类加载器有4个</p><p>第一个是启动类加载器(BootStrap ClassLoader)：其是由C++编写实现。用于加载JAVA_HOME/jre/lib目录下的类库。</p><p>第二个是扩展类加载器(ExtClassLoader)：该类是ClassLoader的子类，主要加载JAVA_HOME/jre/lib/ext目录中的类库。</p><p>第三个是应用类加载器(AppClassLoader)：该类是ClassLoader的子类，主要用于加载classPath下的类，也就是加载开发者自己编写的Java类。</p><p>第四个是自定义类加载器：开发者自定义类继承ClassLoader，实现自定义类加载规则。</p><h5 id="15-什么是双亲委派模型（易考）">15. 什么是双亲委派模型（易考）</h5><p>嗯，它是是这样的。</p><p>如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传说到顶层的启动类加载器中，只有当父类加载器返回自己无法完成这个加载请求（它的搜索返回中没有找到所需的类）时，子类加载器才会尝试自己去加载</p><h5 id="16-JVM为什么采用双亲委派机制">16. JVM为什么采用双亲委派机制</h5><p>主要有两个原因。</p><p>第一、通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。</p><p>第二、为了安全，保证类库API不会被修改</p><h5 id="17-说一下类装载的执行过程">17. 说一下类装载的执行过程</h5><p>面试官您好，类装载的执行过程主要分为以下几个步骤：</p><p>首先是<strong>加载</strong>阶段，这一步会去查找并导入<code>class</code>文件，把字节码数据加载到 JVM 的方法区中，同时在堆区创建对应的<code>Class</code>对象，作为程序访问方法区中类数据的入口。</p><p>接着是<strong>验证</strong>阶段，目的是保证加载进来的类的准确性，会对字节码的格式、语义等进行校验，防止恶意或者错误的类文件影响 JVM 的正常运行。</p><p>然后是<strong>准备</strong>阶段，要为类变量（也就是静态变量）分配内存，并且设置类变量的初始值，不过这里要注意，初始值通常是该类型的默认值，比如<code>int</code>类型默认初始值是 0，而不是代码中显式指定的初始值。</p><p>之后是<strong>解析</strong>阶段，会把类中的符号引用转换为直接引用，符号引用就像我们代码里用名字来指代其他类、方法等，直接引用则是实际能定位到目标的内存地址等具体引用方式。</p><p>再然后是<strong>初始化</strong>阶段，这一步会对类的静态变量、静态代码块执行初始化操作，按照代码中定义的顺序去赋值或者执行代码逻辑，这时候才会把准备阶段的默认初始值替换成我们期望的初始值。</p><p>当完成初始化后，就到了<strong>使用</strong>阶段，JVM 会从入口方法开始，执行用户的程序代码。</p><p>最后是<strong>卸载</strong>阶段，当用户程序代码执行完毕，JVM 就会开始销毁创建的<code>Class</code>对象，释放相关的资源。</p><h5 id="18-简述Java垃圾回收机制？（GC是什么？为什么要GC）">18. 简述Java垃圾回收机制？（GC是什么？为什么要GC）</h5><p>嗯，是这样~~</p><p>为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC(Garbage Collection)。</p><p>有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动识别完成。</p><p>在进行垃圾回收时，不同的对象引用类型，GC会采用不同的回收时机</p><h5 id="19-对象什么时候可以被垃圾器回收（易考）">19. 对象什么时候可以被垃圾器回收（易考）</h5><p>思考一会~~</p><p>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。</p><p>如果要定位什么是垃圾，有两种方式来确定，第一个是引用计数法，第二个是可达性分析算法</p><p>通常都使用可达性分析算法来确定是不是垃圾</p><h5 id="20-JVM的垃圾清除算法有哪些（易考）">20. JVM的垃圾清除算法有哪些（易考）</h5><p>我记得一共有四种，分别是标记清除算法、复制算法、标记整理算法、分代回收</p><h5 id="21-说一下JVM的分代回收">21. 说一下JVM的分代回收</h5><p>关于分代回收是这样的</p><p>在java8时，堆被分为了两份：新生代和老年代，它们默认空间占用比例是1:2</p><p>对于新生代，内部又被分为了三个区域。Eden区，S0区，S1区默认空间占用比例是8:1:1</p><p>具体的工作机制是有些情况：</p><p>1）当创建一个对象的时候，那么这个对象会被分配在新生代的Eden区。当Eden区要满了时候，触发YoungGC。</p><p>2）当进行YoungGC后，此时在Eden区存活的对象被移动到S0区，并且<strong>当前对象的年龄会加1</strong>，清空Eden区。</p><p>3）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S0中的对象，移动到S1区中，这些对象的年龄会加1，清空Eden区和S0区。</p><p>4）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S1中的对象，移动到S0区中，这些对象的年龄会加1，清空Eden区和S1区。</p><p>5）对象的年龄达到了某一个限定的值（<strong>默认15岁</strong> ），那么这个对象就会进入到老年代中。</p><p>当然也有特殊情况，如果进入Eden区的是一个大对象，在触发YoungGC的时候，会直接存放到老年代</p><p>当老年代满了之后，<strong>触发FullGC</strong>。<strong>FullGC同时回收新生代和老年代</strong>，当前只会存在一个FullGC的线程进行执行，其他的线程全部会被挂起。 我们在程序中要尽量避免FullGC的出现。</p><h5 id="22-说一说讲一下新生代、老年代、永久代-区别相关">22. 说一说讲一下新生代、老年代、永久代 区别相关</h5><p>嗯！是这样的，简单说就是</p><p><strong>新生代</strong>主要用来存放新生的对象。</p><p><strong>老年代</strong>主要存放应用中生命周期长的内存对象。</p><p><strong>永久代</strong>指的是永久保存区域。主要存放Class和Meta（元数据）的信息。在Java8中，永久代已经被移除，取而代之的是一个称之为“元数据区”（<strong>元空间</strong>）的区域。元空间和永久代类似，不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存的限制。</p><h5 id="23-说一下JVM有哪些垃圾回收器（易考）">23. 说一下JVM有哪些垃圾回收器（易考）</h5><p>在jvm中，实现了多种垃圾收集器，包括：串行垃圾收集器、并行垃圾收集器（JDK8默认）、CMS（并发）垃圾收集器、G1垃圾收集器（JDK9默认）</p><h5 id="24-详细说一下什么是G1垃圾回收器">24. 详细说一下什么是G1垃圾回收器</h5><p>面试官您好，G1 垃圾回收器是 JVM 里很重要的一款回收器，我来详细和您聊聊。</p><p>首先，它能同时处理新生代和老年代，而且从 JDK9 之后，G1 就成为默认的垃圾回收器了。</p><p>G1 把堆内存划分成多个区域，每个区域可以灵活充当 eden 区、survivor 区、old 区，还有专门为大对象准备的 humongous 区。</p><p>在回收算法上，G1 采用的是复制算法。它在性能方面做得不错，能兼顾响应时间和吞吐量，这对于很多应用场景来说是很友好的。</p><p>G1 的工作主要分三个阶段：第一阶段是新生代回收，这个阶段会触发 STW（暂停所有应用线程）；第二阶段是并发标记，不过其中重新标记的环节还是会 STW；第三阶段是混合收集。另外，如果出现并发失败的情况，也就是垃圾回收的速度跟不上新对象创建的速度，就会触发 Full GC。</p><h5 id="25-强引用，软引用，弱引用，虚引用的区别">25. 强引用，软引用，弱引用，虚引用的区别</h5><p>嗯，其实它们指的是不同代之间的垃圾回收</p><p>Minor GC 发生在新生代的垃圾回收，暂停时间短</p><p>Major GC 老年代区域的垃圾回收，老年代空间不足时，会先尝试触发Minor GC。Minor GC之后空间还不足，则会触发Major GC，Major GC速度比较慢，暂停时间长</p><p>Full GC 新生代 + 老年代完整垃圾回收，暂停时间长，<strong>应尽力避免</strong></p><h5 id="26-JVM的调优参数可以在哪里设置">26. JVM的调优参数可以在哪里设置</h5><p>我们当时的项目是springboot项目，可以在项目启动的时候，java -jar中加入参数就行了</p><h5 id="27-JVM的调优参数都有哪些（少考）">27. JVM的调优参数都有哪些（少考）</h5><p>嗯，这些参数是比较多的</p><p>我记得当时我们设置过堆的大小，像-Xms和-Xmx</p><p>还有就是可以设置年轻代中Eden区和两个Survivor区的大小比例</p><p>还有就是可以设置使用哪种垃圾回收器等等。具体的指令还真记不太清楚。</p><h5 id="28-说一下JVM的调优工具（少考）">28. 说一下JVM的调优工具（少考）</h5><p>嗯，我们一般都是使用jdk自带的一些工具，比如</p><p>jps 输出JVM中运行的进程状态信息</p><p>jstack查看java进程内<strong>线程的堆栈</strong>信息。</p><p>jmap 用于生成堆转存快照</p><p>jstat用于JVM统计监测工具</p><p>还有一些可视化工具，像jconsole和VisualVM等</p><h5 id="29-java内存泄漏的排查思路（易考）">29. java内存泄漏的排查思路（易考）</h5><p>嗯，这个我在之前项目排查过</p><p>第一呢可以通过jmap指定打印他的内存快照 dump文件，不过有的情况打印不了，我们会设置vm参数让程序自动生成dump文件</p><p>第二，可以通过工具去分析 dump文件，jdk自带的VisualVM就可以分析</p><p>第三，通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题</p><p>第四，找到对应的代码，通过阅读上下文的情况，进行修复即可</p><h5 id="30-CPU飙高的排查方案与思路（易考）">30. CPU飙高的排查方案与思路（易考）</h5><p>嗯，我思考一下~~</p><p>可以这么做~~</p><p>第一可以使用使用top命令查看占用cpu的情况</p><p>第二通过top命令查看后，可以查看是哪一个进程占用cpu较高，记录这个进程id</p><p>第三可以通过ps 查看当前进程中的线程信息，看看哪个线程的cpu占用较高</p><p>第四可以jstack命令打印进行的id，找到这个线程，就可以进一步定位问题代码的行号</p><h4 id="九、常见技术场景">九、常见技术场景</h4><h5 id="1-你的单点登录模块怎么实现的呢（什么是SSO）">1. 你的单点登录模块怎么实现的呢（什么是SSO）</h5><p>我们当时在项目中实现了单点登录功能，主要解决了用户在不同系统间切换时需要重复登录的问题。我们采用了基于JWT Token的方案，结合Redis缓存来实现单点登录。</p><p>当用户首次登录时，系统会生成一个JWT Token，并将Token存储到Redis中，同时设置合理的过期时间。用户访问其他系统时，会携带这个Token，系统通过验证Token的有效性来判断用户是否已登录。如果token无效会返回401错误，跳转到登录页面。</p><p>不同系统通过统一的认证中心来验证Token的有效性。认证中心会检查Token的签名、过期时间等信息，同时查询Redis确认Token是否仍然有效。</p><h5 id="2-你的项目中权限认证如何实现的">2. 你的项目中权限认证如何实现的</h5><p>我们当时在项目中采用了基于RBAC（基于角色的访问控制）的权限模型。我们设计了用户、角色、权限三个核心实体，用户通过角色来获得权限，角色通过权限来控制系统功能。比如管理员角色拥有所有权限，挂号员角色只能进行挂号相关操作，医生角色只能进行诊疗相关操作。</p><p>我们使用Spring Security作为安全框架，通过配置SecurityConfig类来实现权限控制。我们自定义了UserDetailsService来加载用户信息，实现了基于数据库的用户认证。同时，我们配置了不同的URL路径对应不同的权限要求，比如/admin/路径需要管理员权限，/doctor/路径需要医生权限。</p><p>我们创建了自定义的权限验证拦截器，在用户访问受保护的资源时，会检查用户是否具有相应的权限。我们使用@PreAuthorize注解在方法级别进行权限控制，来确保只有相对应的权限才能执行挂号操作。</p><h5 id="3-你负责的项目中遇到哪些棘手的问题？怎么解决的">3. 你负责的项目中遇到哪些棘手的问题？怎么解决的</h5><p>我们当时在项目中遇到了药品分页查询性能问题。药品表有300多万条数据，当医生查询药品信息时，使用传统的LIMIT分页查询，当查询第1000页以后的数据时，查询时间从原来的几百毫秒飙升到几秒钟，严重影响用户体验。</p><p>通过EXPLAIN分析发现，当使用LIMIT 1000, 20查询时，MySQL需要先扫描前1000条记录，然后返回第1001-1020条记录，随着页码增加，扫描的数据量呈线性增长，导致查询性能急剧下降。</p><p>我们采用了基于主键的分页查询优化方案。首先，我们为药品表添加了合适的索引，包括药品名称、分类、价格等常用查询字段的复合索引。然后，我们修改了分页查询逻辑，使用主键ID作为游标进行分页，比如查询ID大于某个值的记录，这样避免了大量数据的扫描。</p><p>我们将传统的LIMIT分页改为基于ID的分页，前端传递上一页最后一条记录的ID，后端查询ID大于该值的记录。同时，我们实现了查询条件的优化，将常用的查询条件组合成复合索引，比如(药品名称, 分类, 价格)的复合索引。</p><p>我们使用Redis缓存了热门药品信息，对于访问频率高的药品，直接从缓存获取，减少数据库查询压力。同时，我们实现了查询结果的缓存，相同查询条件的结果会缓存5分钟。</p><p>经过优化后，药品分页查询的响应时间从原来的几秒钟降低到几十毫秒，用户体验得到了显著提升。同时，通过缓存机制，我们进一步减少了数据库的查询压力，提升了系统的整体性能。</p><h5 id="4-你们项目中的日志是怎么采集的">4. 你们项目中的日志是怎么采集的</h5><p>我们当时在项目中采用了ELK（Elasticsearch + Logstash + Kibana）日志采集方案。通过Logstash收集应用日志，存储到Elasticsearch中，最后通过Kibana进行日志分析和可视化展示。</p><p>我们使用Logback作为日志框架，配置了不同的Appender来输出不同类型的日志。系统日志输出到系统日志文件，业务日志输出到业务日志文件，错误日志输出到错误日志文件。Logstash通过文件监控的方式采集这些日志文件。</p></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/03/01/67c2609b7c10b.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/03/01/67c2609b7c10b.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">李阳</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://blog.baskly.fun/posts/45509/">原创</a><a class="post-copyright-title"><span onclick='rm.copyPageUrl("https://blog.baskly.fun/posts/45509/")'>java面试黑马版</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://blog.baskly.fun/posts/45509/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=java面试黑马版&amp;url=https://blog.baskly.fun/posts/45509/&amp;pic=https://bu.dusays.com/2024/12/24/676a8d8bc7d9f.png?_r_=3b9fde37-24bc-0474-7dd1-4a5586f05907" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl(){var e=window.location.href,t=document.createElement("input");t.setAttribute("value",e),document.body.appendChild(t),t.select(),t.setSelectionRange(0,99999),document.execCommand("copy"),document.body.removeChild(t)}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.baskly.fun" target="_blank">李阳的秘密小屋</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/%E9%9D%A2%E8%AF%95/"><span class="categoryes-punctuation"><i class="anzhiyufont anzhiyu-icon-inbox"></i></span> 面试<span class="categoryesPageCount">4</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tags-punctuation"><i class="anzhiyufont anzhiyu-icon-tag"></i></span> 面试<span class="tagsPageCount">4</span></a></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2024/11/24/674340e151d6a.png?_r_=f96b4b60-e054-e337-0c45-a45159026be7" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/3860/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2024/11/24/674340e0cd15e.png?_r_=456351c6-24ef-054b-2585-a57c1677c6ef" onerror='onerror=null,src="https://bu.dusays.com/2025/05/30/68398ca86a127.gif"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">黑马学成在线</div></div></a></div><div class="next-post pull-right"><a href="/posts/11096/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2024/12/24/676a8d8bc7d9f.png?_r_=b766501c-375f-d622-6ca5-bfbc65ab58d7" onerror='onerror=null,src="https://bu.dusays.com/2025/05/30/68398ca86a127.gif"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis黑马版</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i> <span>评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left:4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/03/01/67c2609b7c10b.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"><div class="author-status"><img class="g-status" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2021/01/15/805daa7195f2c.gif" alt="status"></div></div><div class="author-info__description"><div style="line-height:1.38;margin:.6rem 0;text-align:justify;color:rgba(255,255,255,.8)">这有描绘<b style="color:#fff">我的痕迹</b></div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about"><h1 class="author-info__name">李阳</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/lyay23" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80-%E3%80%81Redis"><span class="toc-number">1.</span> <span class="toc-text">一 、Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%88%91%E7%9C%8B%E4%BD%A0%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%86Redis%EF%BC%8C%E4%BD%A0%E6%9C%80%E8%BF%91%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%86Redis%E5%91%A2%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">1. 我看你在项目中使用了Redis，你最近在哪些场景中使用了Redis呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Redis%E7%9A%84%E7%BC%93%E5%AD%98%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">Redis的缓存在项目中的使用？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">为什么使用Redisson分布式锁？</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%82%A3%E4%B9%88%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%9A%84%E9%97%AE%E9%A2%98%E5%91%A2%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">2. 那么你是怎么解决缓存穿透的问题呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BD%A0%E8%83%BD%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%90%97%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">3. 你能介绍一下布隆过滤器吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">1.4.</span> <span class="toc-text">4. 什么是缓存击穿？怎么解决</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">5. 什么是缓存雪崩，怎么解决？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-Redis%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%EF%BC%8CMysql%E4%B8%8ERedis%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%90%8C%E6%AD%A5%E5%91%A2%EF%BC%88%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">6. Redis作为缓存，Mysql与Redis数据如何进行同步呢（双写一致）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-Redis%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%EF%BC%8C%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84"><span class="toc-number">1.7.</span> <span class="toc-text">7. Redis作为缓存，数据持久化是怎么做的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E8%BF%99%E4%B8%A4%E7%A7%8D%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">8. 这两种持久化方式有什么区别呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-%E8%BF%99%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%93%AA%E7%A7%8D%E6%81%A2%E5%A4%8D%E7%9A%84%E6%AF%94%E8%BE%83%E5%BF%AB%E5%91%A2%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">9. 这两种方式，哪种恢复的比较快呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-Redis%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.10.</span> <span class="toc-text">10. Redis的过期策略有哪些</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.11.</span> <span class="toc-text">11. 数据淘汰策略有哪些</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%891000%E4%B8%87%E6%95%B0%E6%8D%AE%EF%BC%8CRedis%E5%8F%AA%E8%83%BD%E7%BC%93%E5%AD%9820w%E6%95%B0%E6%8D%AE%E3%80%82%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81Redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E9%83%BD%E6%98%AF%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">12. 数据库有1000万数据，Redis只能缓存20w数据。如何保证Redis中的数据都是热点数据？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-Redis%E7%9A%84%E5%86%85%E5%AD%98%E7%94%A8%E5%AE%8C%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">13. Redis的内存用完了会发生什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-Redis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%91%A2"><span class="toc-number">1.14.</span> <span class="toc-text">14. Redis的分布式锁是如何实现的呢</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E6%8E%A7%E5%88%B6%E9%94%81%E7%9A%84%E6%97%B6%E9%95%BF"><span class="toc-number">1.15.</span> <span class="toc-text">15. Redis实现分布式锁如何合理控制锁的时长</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-Redisson%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%98%AF%E5%8F%AF%E9%87%8D%E7%94%A8%E7%9A%84%E5%90%97"><span class="toc-number">1.16.</span> <span class="toc-text">16. Redisson实现分布式锁是可重用的吗</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-Redisson%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E4%B8%BB%E4%BB%8E%E4%B8%80%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%97"><span class="toc-number">1.17.</span> <span class="toc-text">17. Redisson可以解决主从一致的问题吗</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-%E5%A6%82%E6%9E%9C%E4%B8%9A%E5%8A%A1%E9%9D%9E%E8%A6%81%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E7%9A%84%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%AF%A5%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%91%A2%EF%BC%9F"><span class="toc-number">1.18.</span> <span class="toc-text">18. 如果业务非要保证数据的强一致性，这个该怎么解决呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19-Redis%E9%9B%86%E7%BE%A4%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%A1%88%EF%BC%8C%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="toc-number">1.19.</span> <span class="toc-text">19. Redis集群有哪些方案，知道吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20-%E9%82%A3%E4%BD%A0%E6%9D%A5%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">1.20.</span> <span class="toc-text">20. 那你来介绍一下主从同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#21-%E8%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8B%EF%BC%8C%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B5%81%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="toc-number">1.21.</span> <span class="toc-text">21. 能说一下，主从同步数据的流程吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#22-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81Redis%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F"><span class="toc-number">1.22.</span> <span class="toc-text">22. 怎么保证Redis的高并发高可用？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#23-%E4%BD%A0%E4%BB%AC%E4%BD%BF%E7%94%A8Redis%E6%98%AF%E5%8D%95%E7%82%B9%E8%BF%98%E6%98%AF%E9%9B%86%E7%BE%A4%EF%BC%8C%E5%93%AA%E7%A7%8D%E9%9B%86%E7%BE%A4%EF%BC%9F"><span class="toc-number">1.23.</span> <span class="toc-text">23. 你们使用Redis是单点还是集群，哪种集群？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#24-Redis%E9%9B%86%E7%BE%A4%E8%84%91%E8%A3%82%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%91%A2%EF%BC%9F"><span class="toc-number">1.24.</span> <span class="toc-text">24. Redis集群脑裂，该怎么解决呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#25-Redis%E7%9A%84%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">1.25.</span> <span class="toc-text">25. Redis的分片集群有什么作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#26-Redis%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%95%B0%E6%8D%AE%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E5%92%8C%E8%AF%BB%E5%8F%96%E7%9A%84%EF%BC%9F"><span class="toc-number">1.26.</span> <span class="toc-text">26. Redis分片集群中数据是怎么存储和读取的？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#27-Redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%8C%E4%BD%86%E6%98%AF%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%82%A3%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-number">1.27.</span> <span class="toc-text">27. Redis是单线程的，但是为什么还那么快？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#28-%E8%83%BD%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BI-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B%EF%BC%9F%EF%BC%88%E7%AE%80%E5%8E%86%E8%BF%98%E6%88%91%EF%BC%89"><span class="toc-number">1.28.</span> <span class="toc-text">28. 能解释一下I&#x2F;O多路复用模型？（简历还我）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81MySQL"><span class="toc-number">2.</span> <span class="toc-text">二、MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9C%A8MySQL%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%91%A2%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">1. 在MySQL中，如何定位慢查询呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%82%A3%E8%BF%99%E4%B8%AASQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%BE%88%E6%85%A2%EF%BC%8C%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E5%91%A2%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">2. 那这个SQL语句执行很慢，如何分析呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%82%A3%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87%E7%B4%A2%E5%BC%95%E5%90%97%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95"><span class="toc-number">2.3.</span> <span class="toc-text">3. 那你了解过索引吗？什么是索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">4. 索引的底层数据结构了解过吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-B-%E6%A0%91%E4%B8%8EB%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">5. B+树与B树的区别是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">2.6.</span> <span class="toc-text">6. 什么是聚簇索引什么是非聚簇索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%91%A2"><span class="toc-number">2.7.</span> <span class="toc-text">7. 什么是回表查询呢</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E5%90%97%EF%BC%9F"><span class="toc-number">2.8.</span> <span class="toc-text">8. 知道什么是覆盖索引吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-MySQL%E8%B6%85%E5%A4%A7%E5%88%86%E9%A1%B5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-number">2.9.</span> <span class="toc-text">9. MySQL超大分页怎么处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8E%9F%E5%88%99%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">2.10.</span> <span class="toc-text">10. 索引的创建原则有哪些</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E7%B4%A2%E5%BC%95%E4%BC%9A%E5%A4%B1%E6%95%88"><span class="toc-number">2.11.</span> <span class="toc-text">11. 什么情况下索引会失效</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-%E8%B0%88%E4%B8%80%E8%B0%88%E4%BD%A0%E5%AF%B9SQL%E4%BC%98%E5%8C%96%E7%9A%84%E7%BB%8F%E9%AA%8C%EF%BC%9F%EF%BC%88%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%EF%BC%89"><span class="toc-number">2.12.</span> <span class="toc-text">12. 谈一谈你对SQL优化的经验？（面试常见）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-%E5%88%9B%E5%BB%BA%E8%A1%A8%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%BD%A0%E4%BB%AC%E6%98%AF%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">2.13.</span> <span class="toc-text">13. 创建表的时候，你们是如何优化的呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-%E5%9C%A8%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%98%AF%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%91%A2%EF%BC%9F"><span class="toc-number">2.14.</span> <span class="toc-text">14. 在使用索引的时候，是如何优化呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-%E4%BD%A0%E5%B9%B3%E6%97%B6%E5%AF%B9SQL%E8%AF%AD%E5%8F%A5%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%E5%91%A2%EF%BC%9F"><span class="toc-number">2.15.</span> <span class="toc-text">15. 你平时对SQL语句做了哪些优化呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E5%BE%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AF%A6%E7%BB%86%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%90%97"><span class="toc-number">2.16.</span> <span class="toc-text">16. 事务的特征是什么，可以详细说一下吗</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">2.17.</span> <span class="toc-text">17 . 并发事务带来哪些问题？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98%E5%91%A2%EF%BC%9F-MySQL%E7%9A%84%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF"><span class="toc-number">2.18.</span> <span class="toc-text">18. 怎么解决这些问题呢？ MySQL的默认隔离级别是</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19-undo-log%E5%92%8Credo-log-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.19.</span> <span class="toc-text">19. undo log和redo log 的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20-%E4%BA%8B%E5%8A%A1%E4%B8%AD%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%9A%84%E5%91%A2%EF%BC%9F%EF%BC%88%E8%AF%B7%E4%BD%A0%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BMVCC%EF%BC%89-%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83"><span class="toc-number">2.20.</span> <span class="toc-text">20. 事务中的隔离性是如何保障的呢？（请你解释一下MVCC）[面试常考]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#21-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.21.</span> <span class="toc-text">21. 主从复制的原理是什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#22-%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E7%94%A8%E8%BF%87MySQL%E7%9A%84%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%90%97%EF%BC%9F"><span class="toc-number">2.22.</span> <span class="toc-text">22. 你们项目用过MySQL的分库分表吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#23-%E9%82%A3%E4%BD%A0%E4%B9%8B%E5%89%8D%E4%BD%BF%E7%94%A8%E8%BF%87%E6%B0%B4%E5%B9%B3%E5%88%86%E5%BA%93%E5%90%97%EF%BC%9F"><span class="toc-number">2.23.</span> <span class="toc-text">23. 那你之前使用过水平分库吗？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81-%E6%A1%86%E6%9E%B6%E7%AF%87"><span class="toc-number">3.</span> <span class="toc-text">三、 框架篇</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8Bbean%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">1. Spring框架中的单例bean是线程安全的吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AFAOP%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">2. 什么是AOP？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8%E5%88%B0AOP"><span class="toc-number">3.3.</span> <span class="toc-text">3. 你们项目中有没有使用到AOP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">3.4.</span> <span class="toc-text">4. Spring的事务是如何实现的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.5.</span> <span class="toc-text">5. Spring的事务失效的场景有哪些</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-Spring%E7%9A%84bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%88%E6%98%93%E8%80%83%EF%BC%89"><span class="toc-number">3.6.</span> <span class="toc-text">6. Spring的bean的生命周期（易考）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-Spring%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-number">3.7.</span> <span class="toc-text">7. Spring中的循环引用问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E4%BD%A0%E8%83%BD%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%E5%90%97"><span class="toc-number">3.8.</span> <span class="toc-text">8. 你能说一说具体流程吗</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%87%BA%E7%8E%B0%E4%BA%86%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">3.9.</span> <span class="toc-text">9. 构造方法出现了循环依赖怎么解决</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-SpringMVC%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9F%A5%E9%81%93%E5%90%97"><span class="toc-number">3.10.</span> <span class="toc-text">10. SpringMVC的执行流程知道吗</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-SpringBoot%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86%EF%BC%88%E6%98%93%E8%80%83%EF%BC%89"><span class="toc-number">3.11.</span> <span class="toc-text">11. SpringBoot的自动装配原理（易考）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-spring%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.12.</span> <span class="toc-text">12. spring框架常见注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-SpringMVC%E7%9A%84%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.13.</span> <span class="toc-text">13. SpringMVC的常见注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-Springboot%E7%9A%84%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.14.</span> <span class="toc-text">14. Springboot的常见注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-Spring%E5%92%8CSpringBoot%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.15.</span> <span class="toc-text">15.Spring和SpringBoot之间有什么区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-%E8%AF%B7%E4%BD%A0%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BSpring%E7%9A%84DI%E5%92%8CIOC%E3%80%81"><span class="toc-number">3.16.</span> <span class="toc-text">16. 请你描述一下Spring的DI和IOC、</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.17.</span> <span class="toc-text">17.JDK动态代理和CGLIB动态代理有什么区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">3.18.</span> <span class="toc-text">18.拦截器和过滤器有什么区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19-Autowired-%E5%92%8C-Resource-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="toc-number">3.19.</span> <span class="toc-text">19. @Autowired 和 @Resource 有什么不同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20-MyBatis%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.20.</span> <span class="toc-text">20. MyBatis的执行流程是什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#21-Mybatis%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%9F"><span class="toc-number">3.21.</span> <span class="toc-text">21. Mybatis是否支持延迟加载？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#22-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="toc-number">3.22.</span> <span class="toc-text">22. 延迟加载的底层原理知道吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#23-Mybatis%E7%9A%84%E4%B8%80%E7%BA%A7%E3%80%81%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F"><span class="toc-number">3.23.</span> <span class="toc-text">23. Mybatis的一级、二级缓存用过吗？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">4.</span> <span class="toc-text">四、微服务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-SpringCloud%E7%9A%84%E4%BA%94%E5%A4%A7%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.1.</span> <span class="toc-text">1. SpringCloud的五大组件是什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9FSpring-Cloud-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">2. 服务注册和发现是什么意思？Spring Cloud 如何实现服务注册发现？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%88%91%E7%9C%8B%E4%BD%A0%E4%B9%8B%E5%89%8D%E4%B9%9F%E7%94%A8%E8%BF%87nacos%EF%BC%8C%E4%BD%A0%E8%83%BD%E8%AF%B4%E4%B8%8Bnacos%E4%B8%8Eeureka%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">3. 我看你之前也用过nacos，你能说下nacos与eureka的区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">4. 你们项目负载均衡如何实现的？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-nacos-Spring-Cloud-LoadBalancer-%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="toc-number">4.5.</span> <span class="toc-text">6. nacos&#x2F;Spring Cloud LoadBalancer 的负载均衡策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E5%A6%82%E6%9E%9C%E6%83%B3%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E7%AD%96%E7%95%A5%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%91%A2"><span class="toc-number">4.6.</span> <span class="toc-text">7. 如果想自定义负载均衡的策略如何实现呢</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E9%9B%AA%E5%B4%A9%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">4.7.</span> <span class="toc-text">8. 什么是服务雪崩，怎么解决这个问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-%E4%BD%A0%E4%BB%AC%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%98%AF%E6%80%8E%E4%B9%88%E7%9B%91%E6%8E%A7%E7%9A%84%E5%91%A2"><span class="toc-number">4.8.</span> <span class="toc-text">9. 你们的微服务是怎么监控的呢</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E6%B2%A1%E6%9C%89%E5%81%9A%E8%BF%87%E9%99%90%E6%B5%81%EF%BC%9F%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F"><span class="toc-number">4.9.</span> <span class="toc-text">10. 你们项目中有没有做过限流？怎么做的？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-%E9%99%90%E6%B5%81%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.10.</span> <span class="toc-text">11. 限流常见的算法有哪些？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-%E4%BB%80%E4%B9%88%E6%98%AFCAP%E7%90%86%E8%AE%BA%EF%BC%9F"><span class="toc-number">4.11.</span> <span class="toc-text">12. 什么是CAP理论？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-%E4%BB%80%E4%B9%88%E6%98%AFBASE%E7%90%86%E8%AE%BA"><span class="toc-number">4.12.</span> <span class="toc-text">13. 什么是BASE理论</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%97%A0%E6%B3%95%E5%90%8C%E6%97%B6%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E5%8F%AF%E7%94%A8%E6%80%A7%EF%BC%9F"><span class="toc-number">4.13.</span> <span class="toc-text">14. 为什么分布式系统中无法同时保证一致性和可用性？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-%E4%BD%A0%E4%BB%AC%E9%87%87%E7%94%A8%E5%93%AA%E7%A7%8D%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">4.14.</span> <span class="toc-text">15. 你们采用哪种分布式事务解决方案？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="toc-number">4.15.</span> <span class="toc-text">16. 分布式服务的接口幂等性如何设计？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-xxl-job%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.16.</span> <span class="toc-text">17. xxl-job路由策略有哪些？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-xxl-job%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E5%A4%B1%E8%B4%A5%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">4.17.</span> <span class="toc-text">18. xxl-job任务执行失败怎么解决？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19-%E5%A6%82%E6%9E%9C%E6%9C%89%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%90%8C%E6%97%B6%E9%83%BD%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">4.18.</span> <span class="toc-text">19. 如果有大数据量的任务同时都需要执行，怎么解决？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E3%80%81-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">5.</span> <span class="toc-text">五、 消息中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-RabbitMQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="toc-number">5.1.</span> <span class="toc-text">1. RabbitMQ如何保证消息不丢失</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-RabbitMQ%E6%B6%88%E6%81%AF%E7%9A%84%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">2. RabbitMQ消息的重复消费问题如何解决？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%82%A3%E4%BD%A0%E8%BF%98%E7%9F%A5%E9%81%93%E5%85%B6%E4%BB%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%90%97%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">3. 那你还知道其他的解决方案吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-RabbitMQ%E4%B8%AD%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%EF%BC%88RabbitMQ%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9F%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">4. RabbitMQ中死信交换机了解吗？（RabbitMQ延迟队列有了解过吗？）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%A6%82%E6%9E%9C%E6%9C%89100%E4%B8%87%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E5%9C%A8MQ%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F%EF%BC%88%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E8%AF%A5%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%89"><span class="toc-number">5.5.</span> <span class="toc-text">5. 如果有100万消息堆积在MQ，如何解决？（消息堆积该如何解决）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-RabbitMQ%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">5.6.</span> <span class="toc-text">6. RabbitMQ的高可用机制了解吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E5%A6%82%E6%9E%9C%E5%87%BA%E7%8E%B0%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%91%A2"><span class="toc-number">5.7.</span> <span class="toc-text">7. 如果出现数据丢失怎么解决呢</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-Kafka%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1%E7%9A%84%E5%91%A2"><span class="toc-number">5.8.</span> <span class="toc-text">8. Kafka怎么保证消息不丢失的呢</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-Kafka%E4%B8%AD%E6%B6%88%E6%81%AF%E7%9A%84%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">5.9.</span> <span class="toc-text">9. Kafka中消息的重复消费问题如何解决？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-Kafka%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E8%B4%B9%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7%E7%9A%84%E5%91%A2"><span class="toc-number">5.10.</span> <span class="toc-text">10. Kafka是如何保证消费的顺序性的呢</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-Kafka%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">5.11.</span> <span class="toc-text">11. Kafka的高可用机制了解吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E5%A4%8D%E5%88%B6%E6%9C%BA%E5%88%B6%E4%B8%AD%E7%9A%84ISR%EF%BC%9F"><span class="toc-number">5.12.</span> <span class="toc-text">12. 解释一下复制机制中的ISR？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-Kafka%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-number">5.13.</span> <span class="toc-text">13. Kafka的数据清理机制了解吗</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-Kafka%E4%B8%AD%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9F"><span class="toc-number">5.14.</span> <span class="toc-text">14. Kafka中实现高性能的设计有了解过吗？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E9%9B%86%E5%90%88%E7%AF%87"><span class="toc-number">6.</span> <span class="toc-text">六、集合篇</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-ArrayList%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">6.1.</span> <span class="toc-text">1. ArrayList的底层原理是什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%9D%A2%E8%AF%95%E9%A2%98-ArrayList-list-new-ArrayList-10-%E4%B8%AD%E7%9A%84list%E6%89%A9%E5%AE%B9%E5%87%A0%E6%AC%A1-%E5%B0%91%E8%80%83"><span class="toc-number">6.2.</span> <span class="toc-text">2. 面试题-ArrayList list&#x3D;new ArrayList(10)中的list扩容几次(少考)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%92%8CList%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%88%E5%B0%91%E8%80%83%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">3. 如何实现数组和List之间的转换（少考）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E7%94%A8Arrays-asList%E8%BD%ACList%E5%90%8E%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BF%AE%E6%94%B9%E4%BA%86%E6%95%B0%E7%BB%84%E5%86%85%E5%AE%B9%EF%BC%8Clist%E5%8F%97%E5%BD%B1%E5%93%8D%E5%90%97"><span class="toc-number">6.4.</span> <span class="toc-text">4. 用Arrays.asList转List后，如果修改了数组内容，list受影响吗</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-List%E7%94%A8toArray%E8%BD%AC%E6%95%B0%E7%BB%84%E5%90%8E%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BF%AE%E6%94%B9%E4%BA%86List%E5%86%85%E5%AE%B9%EF%BC%8C%E6%95%B0%E7%BB%84%E5%8F%97%E5%BD%B1%E5%93%8D%E5%90%97"><span class="toc-number">6.5.</span> <span class="toc-text">5. List用toArray转数组后，如果修改了List内容，数组受影响吗</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E9%9D%A2%E8%AF%95%E9%A2%98-ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-%E5%B8%B8%E8%80%83"><span class="toc-number">6.6.</span> <span class="toc-text">6. 面试题-ArrayList和LinkedList的区别是什么？(常考)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%97%AF%EF%BC%8C%E5%A5%BD%E7%9A%84%EF%BC%8C%E5%88%9A%E6%89%8D%E4%BD%A0%E8%AF%B4%E4%BA%86ArrayList-%E5%92%8C-LinkedList-%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%8C%E4%BD%A0%E4%BB%AC%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F"><span class="toc-number">6.6.1.</span> <span class="toc-text">嗯，好的，刚才你说了ArrayList 和 LinkedList 不是线程安全的，你们在项目中是如何解决这个的线程安全问题的？</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E8%AF%B4%E4%B8%80%E4%B8%8BHashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%98%93%E8%80%83%EF%BC%89"><span class="toc-number">6.7.</span> <span class="toc-text">7. 说一下HashMap的实现原理（易考）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E9%9D%A2%E8%AF%95%E9%A2%98-HashMap%E7%9A%84put%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-number">6.8.</span> <span class="toc-text">8. 面试题-HashMap的put方法的具体流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-%E8%AE%B2%E4%B8%80%E8%AE%B2HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">6.9.</span> <span class="toc-text">9. 讲一讲HashMap的扩容机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-HashMap%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E6%B3%95"><span class="toc-number">6.10.</span> <span class="toc-text">10. HashMap的寻址方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-%E4%B8%BA%E4%BB%80%E4%B9%88HashMap%E7%9A%84%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E4%B8%80%E5%AE%9A%E6%98%AF2%E7%9A%84%E6%AC%A1%E5%B9%82"><span class="toc-number">6.11.</span> <span class="toc-text">11. 为什么HashMap的数组长度一定是2的次幂</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-hashmap%E5%9C%A81-7%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98"><span class="toc-number">6.12.</span> <span class="toc-text">12. hashmap在1.7情况下的多线程死循环问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-HashSet%E4%B8%8EHashMap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.13.</span> <span class="toc-text">13. HashSet与HashMap的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-%E8%AF%B4%E4%B8%80%E8%AF%B4Java%E6%8F%90%E4%BE%9B%E7%9A%84%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88%EF%BC%9F"><span class="toc-number">6.14.</span> <span class="toc-text">15. 说一说Java提供的常见集合？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-ArrayList%E5%BA%95%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">6.15.</span> <span class="toc-text">16. ArrayList底层是如何实现的？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-HashTable%E4%B8%8EHashMap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.16.</span> <span class="toc-text">17. HashTable与HashMap的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%EF%BC%88%E6%98%93%E8%80%83%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">七、多线程篇（易考）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB"><span class="toc-number">7.1.</span> <span class="toc-text">1. 进程和线程区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.2.</span> <span class="toc-text">2. 并行和并发有什么区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%88%E6%98%93%E8%80%83%EF%BC%89"><span class="toc-number">7.3.</span> <span class="toc-text">3. 创建线程的方式有哪些（易考）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-runnable-%E5%92%8C-callable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">7.4.</span> <span class="toc-text">4. runnable 和 callable 有什么区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E7%9A%84-run-%E5%92%8C-start-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.5.</span> <span class="toc-text">5. 线程的 run()和 start()有什么区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E7%BA%BF%E7%A8%8B%E5%8C%85%E6%8B%AC%E4%BA%86%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%EF%BC%8C%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%E7%9A%84"><span class="toc-number">7.6.</span> <span class="toc-text">6. 线程包括了哪些状态，状态之间是如何变化的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E6%96%B0%E5%BB%BA-T1%E3%80%81T2%E3%80%81T3-%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%83%E4%BB%AC%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-number">7.7.</span> <span class="toc-text">7. 新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-notify-%E5%92%8C-notifyAll-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.8.</span> <span class="toc-text">8. notify()和 notifyAll()有什么区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-%E5%9C%A8-java-%E4%B8%AD-wait-%E5%92%8C-sleep-%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">7.9.</span> <span class="toc-text">9. 在 java 中 wait 和 sleep 方法的不同？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.10.</span> <span class="toc-text">10. 如何停止一个正在运行的线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-%E8%AE%B2%E4%B8%80%E4%B8%8Bsynchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">7.11.</span> <span class="toc-text">11. 讲一下synchronized关键字的底层原理？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-%E8%BF%9B%E9%98%B6"><span class="toc-number">7.12.</span> <span class="toc-text">12. synchronized关键字的底层原理-进阶</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-%E4%BD%A0%E8%B0%88%E8%B0%88-JMM%EF%BC%88Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%89"><span class="toc-number">7.13.</span> <span class="toc-text">13. 你谈谈 JMM（Java 内存模型）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9CAS%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">7.14.</span> <span class="toc-text">14. 谈谈你对CAS的理解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9volatile%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">7.15.</span> <span class="toc-text">15. 谈谈你对volatile的理解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-%E4%BB%80%E4%B9%88%E6%98%AFAQS"><span class="toc-number">7.16.</span> <span class="toc-text">16. 什么是AQS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-ReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">7.17.</span> <span class="toc-text">17. ReentrantLock的实现原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-synchronized%E5%92%8CLock%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%EF%BC%88%E6%98%93%E8%80%83%EF%BC%89"><span class="toc-number">7.18.</span> <span class="toc-text">18. synchronized和Lock有什么区别 ? （易考）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19-%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">7.19.</span> <span class="toc-text">19. 死锁产生的条件是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%AD%BB%E9%94%81%E8%AF%8A%E6%96%AD%EF%BC%9F"><span class="toc-number">7.20.</span> <span class="toc-text">20. 如何进行死锁诊断？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#21-%E8%81%8A%E4%B8%80%E4%B8%8BConcurrentHashMap-%E6%98%93%E8%80%83"><span class="toc-number">7.21.</span> <span class="toc-text">21. 聊一下ConcurrentHashMap (易考)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#22-%E5%AF%BC%E8%87%B4%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">7.22.</span> <span class="toc-text">22. 导致并发程序出现问题的根本原因是什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#23-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E6%B2%A1%E6%9C%89%E7%94%A8%E5%88%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%8C%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%E7%9A%84%E5%92%8C%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%E7%9A%84"><span class="toc-number">7.23.</span> <span class="toc-text">23. 项目中有没有用到线程池，以及线程数是怎么设置的和拒绝策略是怎么设置的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#24-%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E7%9F%A5%E9%81%93%E5%98%9B%EF%BC%89%EF%BC%88%E6%98%93%E8%80%83%EF%BC%89"><span class="toc-number">7.24.</span> <span class="toc-text">24. 说一下线程池的核心参数（线程池的执行原理知道嘛）（易考）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#25-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">7.25.</span> <span class="toc-text">25. 线程池中有哪些常见的阻塞队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#26-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0"><span class="toc-number">7.26.</span> <span class="toc-text">26. 如何确定核心线程数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#27-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%A7%8D%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">7.27.</span> <span class="toc-text">27. 线程池的种类有哪些</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#28-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E7%94%A8Executors%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.28.</span> <span class="toc-text">28. 为什么不建议用Executors创建线程池</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#29-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AFCountDownLatch%E3%80%81Future%EF%BC%88%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E5%93%AA%E9%87%8C%E7%94%A8%E5%88%B0%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89"><span class="toc-number">7.29.</span> <span class="toc-text">29. 线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#30-%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E6%9F%90%E4%B8%AA%E6%96%B9%E6%B3%95%E5%85%81%E8%AE%B8%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%95%B0%E9%87%8F%EF%BC%9F"><span class="toc-number">7.30.</span> <span class="toc-text">30. 如何控制某个方法允许并发访问线程的数量？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#31-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9ThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%88%E6%98%93%E8%80%83%EF%BC%89"><span class="toc-number">7.31.</span> <span class="toc-text">31.谈谈你对ThreadLocal的理解（易考）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#32-%E5%A5%BD%E7%9A%84%EF%BC%8C%E9%82%A3%E4%BD%A0%E7%9F%A5%E9%81%93ThreadLocal%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%E5%90%97%EF%BC%9F"><span class="toc-number">7.32.</span> <span class="toc-text">32. 好的，那你知道ThreadLocal的底层原理实现吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#33-%E5%A5%BD%E7%9A%84%EF%BC%8C%E9%82%A3%E5%85%B3%E4%BA%8EThreadLocal%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E8%BF%99%E4%B8%AA%E4%BA%8B%E6%83%85%EF%BC%8C%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">7.33.</span> <span class="toc-text">33. 好的，那关于ThreadLocal会导致内存溢出这个事情，了解吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#34-%E6%88%91%E7%9C%8B%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E4%BD%BF%E7%94%A8ThreadLocal%EF%BC%8C%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E4%BB%96%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">7.34.</span> <span class="toc-text">34. 我看你的项目中有使用ThreadLocal，谈谈你对他的理解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AB%E3%80%81JVM"><span class="toc-number">8.</span> <span class="toc-text">八、JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-JVM%E7%94%B1%E9%82%A3%E4%BA%9B%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90%EF%BC%8C%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E6%98%93%E8%80%83%EF%BC%89"><span class="toc-number">8.1.</span> <span class="toc-text">1. JVM由那些部分组成，运行流程是什么？（易考）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%9F%EF%BC%88%E6%98%93%E8%80%83%EF%BC%89"><span class="toc-number">8.2.</span> <span class="toc-text">2. 什么是程序计数器？（易考）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BJava%E7%9A%84%E5%A0%86"><span class="toc-number">8.3.</span> <span class="toc-text">3. 介绍一下Java的堆</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">8.4.</span> <span class="toc-text">4. 什么是虚拟机栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%98%AF%E5%90%A6%E6%B6%89%E5%8F%8A%E6%A0%88%E5%86%85%E5%AD%98%EF%BC%9F"><span class="toc-number">8.5.</span> <span class="toc-text">5. 垃圾回收是否涉及栈内存？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E6%A0%88%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%B6%8A%E5%A4%A7%E8%B6%8A%E5%A5%BD%E5%90%97%EF%BC%9F"><span class="toc-number">8.6.</span> <span class="toc-text">6. 栈内存分配越大越好吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E6%96%B9%E6%B3%95%E5%86%85%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">8.7.</span> <span class="toc-text">7. 方法内的局部变量是否线程安全？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E6%A0%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E6%83%85%E5%86%B5"><span class="toc-number">8.8.</span> <span class="toc-text">8. 栈内存溢出情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-%E6%A0%88%E5%92%8C%E5%A0%86%E7%9A%84%E5%8C%BA%E5%88%AB%E5%91%A2"><span class="toc-number">8.9.</span> <span class="toc-text">9. 栈和堆的区别呢</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-%E8%83%BD%E4%B8%8D%E8%83%BD%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">8.10.</span> <span class="toc-text">10. 能不能解释一下方法区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E8%BF%90%E8%A1%8C%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">8.11.</span> <span class="toc-text">11. 解释一下运行常量池</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-%E8%AF%B4%E4%B8%80%E4%B8%8B-JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-number">8.12.</span> <span class="toc-text">12. 说一下 JVM 运行时数据区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-%E4%BD%A0%E5%90%AC%E8%BF%87%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E5%90%97%EF%BC%9F"><span class="toc-number">8.13.</span> <span class="toc-text">13. 你听过直接内存吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">8.14.</span> <span class="toc-text">14. 什么是类加载器，类加载器有哪些?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%88%E6%98%93%E8%80%83%EF%BC%89"><span class="toc-number">8.15.</span> <span class="toc-text">15. 什么是双亲委派模型（易考）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-JVM%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">8.16.</span> <span class="toc-text">16. JVM为什么采用双亲委派机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%B1%BB%E8%A3%85%E8%BD%BD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">8.17.</span> <span class="toc-text">17. 说一下类装载的执行过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-%E7%AE%80%E8%BF%B0Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%9F%EF%BC%88GC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81GC%EF%BC%89"><span class="toc-number">8.18.</span> <span class="toc-text">18. 简述Java垃圾回收机制？（GC是什么？为什么要GC）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19-%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9E%83%E5%9C%BE%E5%99%A8%E5%9B%9E%E6%94%B6%EF%BC%88%E6%98%93%E8%80%83%EF%BC%89"><span class="toc-number">8.19.</span> <span class="toc-text">19. 对象什么时候可以被垃圾器回收（易考）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20-JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%88%E6%98%93%E8%80%83%EF%BC%89"><span class="toc-number">8.20.</span> <span class="toc-text">20. JVM的垃圾清除算法有哪些（易考）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#21-%E8%AF%B4%E4%B8%80%E4%B8%8BJVM%E7%9A%84%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="toc-number">8.21.</span> <span class="toc-text">21. 说一下JVM的分代回收</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#22-%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%AE%B2%E4%B8%80%E4%B8%8B%E6%96%B0%E7%94%9F%E4%BB%A3%E3%80%81%E8%80%81%E5%B9%B4%E4%BB%A3%E3%80%81%E6%B0%B8%E4%B9%85%E4%BB%A3-%E5%8C%BA%E5%88%AB%E7%9B%B8%E5%85%B3"><span class="toc-number">8.22.</span> <span class="toc-text">22. 说一说讲一下新生代、老年代、永久代 区别相关</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#23-%E8%AF%B4%E4%B8%80%E4%B8%8BJVM%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E6%98%93%E8%80%83%EF%BC%89"><span class="toc-number">8.23.</span> <span class="toc-text">23. 说一下JVM有哪些垃圾回收器（易考）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#24-%E8%AF%A6%E7%BB%86%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AFG1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">8.24.</span> <span class="toc-text">24. 详细说一下什么是G1垃圾回收器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#25-%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%8C%E8%BD%AF%E5%BC%95%E7%94%A8%EF%BC%8C%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%8C%E8%99%9A%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.25.</span> <span class="toc-text">25. 强引用，软引用，弱引用，虚引用的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#26-JVM%E7%9A%84%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%93%AA%E9%87%8C%E8%AE%BE%E7%BD%AE"><span class="toc-number">8.26.</span> <span class="toc-text">26. JVM的调优参数可以在哪里设置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#27-JVM%E7%9A%84%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%88%E5%B0%91%E8%80%83%EF%BC%89"><span class="toc-number">8.27.</span> <span class="toc-text">27. JVM的调优参数都有哪些（少考）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#28-%E8%AF%B4%E4%B8%80%E4%B8%8BJVM%E7%9A%84%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%EF%BC%88%E5%B0%91%E8%80%83%EF%BC%89"><span class="toc-number">8.28.</span> <span class="toc-text">28. 说一下JVM的调优工具（少考）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#29-java%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF%EF%BC%88%E6%98%93%E8%80%83%EF%BC%89"><span class="toc-number">8.29.</span> <span class="toc-text">29. java内存泄漏的排查思路（易考）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#30-CPU%E9%A3%99%E9%AB%98%E7%9A%84%E6%8E%92%E6%9F%A5%E6%96%B9%E6%A1%88%E4%B8%8E%E6%80%9D%E8%B7%AF%EF%BC%88%E6%98%93%E8%80%83%EF%BC%89"><span class="toc-number">8.30.</span> <span class="toc-text">30. CPU飙高的排查方案与思路（易考）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%B8%B8%E8%A7%81%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF"><span class="toc-number">9.</span> <span class="toc-text">九、常见技术场景</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BD%A0%E7%9A%84%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E6%A8%A1%E5%9D%97%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%91%A2%EF%BC%88%E4%BB%80%E4%B9%88%E6%98%AFSSO%EF%BC%89"><span class="toc-number">9.1.</span> <span class="toc-text">1. 你的单点登录模块怎么实现的呢（什么是SSO）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">9.2.</span> <span class="toc-text">2. 你的项目中权限认证如何实现的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BD%A0%E8%B4%9F%E8%B4%A3%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E5%93%AA%E4%BA%9B%E6%A3%98%E6%89%8B%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84"><span class="toc-number">9.3.</span> <span class="toc-text">3. 你负责的项目中遇到哪些棘手的问题？怎么解决的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%97%A5%E5%BF%97%E6%98%AF%E6%80%8E%E4%B9%88%E9%87%87%E9%9B%86%E7%9A%84"><span class="toc-number">9.4.</span> <span class="toc-text">4. 你们项目中的日志是怎么采集的</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/21192/" title="面经"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2024/11/24/674340e151d6a.png?_r_=f96b4b60-e054-e337-0c45-a45159026be7" onerror='this.onerror=null,this.src="https://bu.dusays.com/2025/05/30/68398ca86a127.gif"' alt="面经"></a><div class="content"><a class="title" href="/posts/21192/" title="面经">面经</a><time datetime="2025-09-27T11:34:21.000Z" title="发表于 2025-09-27 19:34:21">2025-09-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/29545/" title="java面试笔记八股文（二）"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2024/11/24/674340e1191e4.png?_r_=ae138d39-5ed7-2f3f-5c17-d1a350b435f5" onerror='this.onerror=null,this.src="https://bu.dusays.com/2025/05/30/68398ca86a127.gif"' alt="java面试笔记八股文（二）"></a><div class="content"><a class="title" href="/posts/29545/" title="java面试笔记八股文（二）">java面试笔记八股文（二）</a><time datetime="2025-09-24T11:34:21.000Z" title="发表于 2025-09-24 19:34:21">2025-09-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1918/" title="面试准备"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2024/11/24/674340e56737a.png?_r_=da26521f-cbd4-914e-9f3d-7e1dcc562c51" onerror='this.onerror=null,this.src="https://bu.dusays.com/2025/05/30/68398ca86a127.gif"' alt="面试准备"></a><div class="content"><a class="title" href="/posts/1918/" title="面试准备">面试准备</a><time datetime="2025-09-24T11:34:21.000Z" title="发表于 2025-09-24 19:34:21">2025-09-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/62391/" title="黑马头条"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2024/11/24/674340e56737a.png?_r_=35568bb4-b1f4-4171-7933-4d939665e1ca" onerror='this.onerror=null,this.src="https://bu.dusays.com/2025/05/30/68398ca86a127.gif"' alt="黑马头条"></a><div class="content"><a class="title" href="/posts/62391/" title="黑马头条">黑马头条</a><time datetime="2025-09-24T02:34:21.000Z" title="发表于 2025-09-24 10:34:21">2025-09-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/11096/" title="Redis黑马版"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2024/12/24/676a8d8bc7d9f.png?_r_=b766501c-375f-d622-6ca5-bfbc65ab58d7" onerror='this.onerror=null,this.src="https://bu.dusays.com/2025/05/30/68398ca86a127.gif"' alt="Redis黑马版"></a><div class="content"><a class="title" href="/posts/11096/" title="Redis黑马版">Redis黑马版</a><time datetime="2025-09-08T02:34:21.000Z" title="发表于 2025-09-08 10:34:21">2025-09-08</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By 李阳</div><div class="footer_custom_text">下次再见！</div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size:.9em"></i> <span>隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size:.9em"></i> <span>分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size:.9em"></i> <span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/charts/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tongji1"></use></svg> <span>统计</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=12781955100&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size:.9em"></i> <span>耳机分你一半</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size:.9em"></i> <span>留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/todolist/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zuji"></use></svg> <span>脚步</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/essay/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-taiyang"></use></svg> <span>小太阳</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-a-xiaoyangyang_huaban1"></use></svg> <span>了解我</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/408/" style="font-size:.88rem">408<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size:.88rem">C语言<sup>1</sup></a><a href="/tags/java/" style="font-size:.88rem;font-weight:500;color:var(--anzhiyu-lighttext)">java<sup>1</sup></a><a href="/tags/javaweb/" style="font-size:.88rem">javaweb<sup>9</sup></a><a href="/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/" style="font-size:.88rem">力扣刷题<sup>1</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size:.88rem">操作系统<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size:.88rem">数据结构<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size:.88rem">计算机组成原理<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size:.88rem">计算机网络<sup>2</sup></a><a href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" style="font-size:.88rem">软件工程<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size:.88rem">面试<sup>4</sup></a></div></div><hr></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="anzhiyu.scrollToDest(document.body.scrollHeight,500)"><i class="anzhiyufont anzhiyu-icon-arrow-down"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="12781955100" server="netease" type="playlist" mutex="true" preload="none" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size:1rem"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/playlist?id=12781955100&quot;, &quot;_blank&quot;);" style="display:none"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>var HoldLog=console.log;console.log=function(){};let now1=new Date;queueMicrotask((()=>{const o=function(){HoldLog.apply(console,arguments)},n=new Date("04/01/2021 00:00:00");now1.setTime(now1.getTime()+250);const c=(now1-n)/1e3/60/60/24,e=["欢迎使用安知鱼!","生活明朗, 万物可爱","\n        \n       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗\n      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║\n      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║\n      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║\n      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝\n      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝\n        \n        ","已上线",Math.floor(c),"天","©2024 By 安知鱼 V1.6.14"],t=["NCC2-036","调用前置摄像头拍照成功，识别为【小笨蛋】.","Photo captured: ","🤪"];setTimeout(o.bind(console,`\n%c${e[0]} %c ${e[1]} %c ${e[2]} %c${e[3]}%c ${e[4]}%c ${e[5]}\n\n%c ${e[6]}\n`,"color:#425AEF","","color:#425AEF","color:#425AEF","","color:#425AEF","")),setTimeout(o.bind(console,`%c ${t[0]} %c ${t[1]} %c \n${t[2]} %c\n${t[3]}\n`,"color:white; background-color:#4fd953","","",'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%')),setTimeout(o.bind(console,"%c WELCOME %c 你好，小笨蛋.","color:white; background-color:#4f90d9","")),setTimeout(console.warn.bind(console,"%c ⚡ Powered by 安知鱼 %c 你正在访问 李阳 的博客.","color:white; background-color:#f0ad4e","")),setTimeout(o.bind(console,"%c W23-12 %c 你已打开控制台.","color:white; background-color:#4f90d9","")),setTimeout(console.warn.bind(console,"%c S013-782 %c 你现在正处于监控中.","color:white; background-color:#d9534f",""))}))</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" href="https://cdn.cbd.int/katex@0.16.0/dist/katex.min.css"><script src="https://cdn.cbd.int/katex@0.16.0/dist/contrib/copy-tex.min.js"></script><script>document.querySelectorAll("#article-container span.katex-display").forEach((a=>{anzhiyu.wrap(a,"div",{class:"katex-wrap"})}))</script><script>(()=>{const e=document.querySelectorAll("#article-container .mermaid-wrap");if(0===e.length)return;const t=()=>{window.loadMermaid=!0;const t="dark"===document.documentElement.getAttribute("data-theme")?"dark":"default";Array.from(e).forEach(((e,n)=>{const d=e.firstElementChild,r="mermaid-"+n,a="%%{init:{ 'theme':'"+t+"'}}%%\n"+d.textContent,i=mermaid.render(r,a);var m;"string"==typeof i?(m=i,d.insertAdjacentHTML("afterend",m)):i.then((({svg:e})=>{d.insertAdjacentHTML("afterend",e)}))}))},n=()=>{window.loadMermaid?t():getScript("https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js").then(t)};anzhiyu.addGlobalFn("themeChange",t,"mermaid"),window.pjax?n():document.addEventListener("DOMContentLoaded",n)})()</script><script>(()=>{const t=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo.baskly.fun",region:"",onCommentLoaded:()=>{anzhiyu.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const t=document.getElementById("twikoo-count");t&&twikoo.getCommentsCount({envId:"https://twikoo.baskly.fun",region:"",urls:[window.location.pathname],includeReply:!1}).then((o=>{t.textContent=o[0].count})).catch((t=>{console.error(t)}))})()};"object"==typeof twikoo?setTimeout(t,0):getScript("https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js").then(t)})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener("load",(()=>{const e=e=>{let t="";if(e.length)for(let n=0;n<e.length;n++){t+="<div class='aside-list-item'>";{const a="data-lazy-src";t+=`<a href='${e[n].url}' class='thumbnail'><img ${a}='${e[n].avatar}' alt='${e[n].nick}'><div class='name'><span>${e[n].nick} </span></div></a>`}t+=`<div class='content'>\n        <a class='comment' href='${e[n].url}' title='${e[n].content}'>${e[n].content}</a>\n        <time datetime="${e[n].date}">${anzhiyu.diffDate(e[n].date,!0)}</time></div>\n        </div>`}else t+="没有评论";let n=document.querySelector("#card-newest-comments .aside-list");n&&(n.innerHTML=t),window.lazyLoadInstance&&window.lazyLoadInstance.update(),window.pjax&&window.pjax.refresh(n)},t=()=>{if(document.querySelector("#card-newest-comments .aside-list")){const t=saveToLocal.get("twikoo-newest-comments");t?e(JSON.parse(t)):(()=>{const t=()=>{twikoo.getRecentComments({envId:"https://twikoo.baskly.fun",region:"",pageSize:6,includeReply:!0}).then((function(t){const n=t.map((e=>{return{content:(t=e.comment,""===t||(t=(t=(t=(t=t.replace(/<img.*?src="(.*?)"?[^\>]+>/gi,"[图片]")).replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi,"[链接]")).replace(/<pre><code>.*?<\/pre>/gi,"[代码]")).replace(/<[^>]+>/g,"")).length>150&&(t=t.substring(0,150)+"..."),t),avatar:e.avatar,nick:e.nick,url:e.url+"#"+e.id,date:new Date(e.created).toISOString()};var t}));saveToLocal.set("twikoo-newest-comments",JSON.stringify(n),10/1440),e(n)})).catch((function(e){document.querySelector("#card-newest-comments .aside-list").textContent="无法获取评论，请确认相关配置是否正确"}))};"object"==typeof twikoo?t():getScript("https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js").then(t)})()}};t(),document.addEventListener("pjax:complete",t)}))</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail="yang@li.com"</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script async src="//at.alicdn.com/t/c/font_4782341_g014uvnbwk6.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/echarts/4.9.0-rc.1/echarts.min.js"></script><script src="https://lib.baomitu.com/echarts/4.9.0-rc.1/echarts.min.js"></script><script src="https://jsd-proxy.ygxz.in/gh/lyay23/blogstatic@v1.0.0/static/imgloaded.min.js"></script><script src="https://jsd-proxy.ygxz.in/gh/lyay23/blogstatic@v1.0.0/static/countdown.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors=['meta[property="og:image"]','meta[property="og:title"]','meta[property="og:url"]','meta[property="og:type"]','meta[property="og:site_name"]','meta[property="og:description"]',"head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"]):not([href="/music/"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(anzhiyu.removeGlobalFnEvent("pjax"),anzhiyu.removeGlobalFnEvent("themeChange"),document.getElementById("rightside").classList.remove("rightside-show"),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>