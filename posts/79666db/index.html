<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>数据结构 | 李阳的秘密小屋</title><meta name="keywords" content="数据结构"><meta name="author" content="李阳"><meta name="copyright" content="李阳"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="数据结构"><meta name="application-name" content="数据结构"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="数据结构"><meta property="og:url" content="https://blog.baskly.fun/posts/79666db/index.html"><meta property="og:site_name" content="李阳的秘密小屋"><meta property="og:description" content="参考郝斌，王卓老师的C语言版数据结构 后序会再更新"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://i1.wp.com/dev.ruom.top/i/2025/03/02/121183.webp"><meta property="article:author" content="李阳"><meta property="article:tag" content="bask,李阳"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://i1.wp.com/dev.ruom.top/i/2025/03/02/121183.webp"><meta name="description" content="参考郝斌，王卓老师的C语言版数据结构 后序会再更新"><link rel="shortcut icon" href="/img/flow-32x32.ico"><link rel="canonical" href="https://blog.baskly.fun/posts/79666db/"><link rel="preconnect" href="//cdn.cbd.int"><meta name="google-site-verification" content="xxx"><meta name="baidu-site-verification" content="code-xxx"><meta name="msvalidate.01" content="xxx"><link rel="manifest" href="/manifest.json"><meta name="msapplication-TileColor" content="var(--anzhiyu-main)"><link rel="mask-icon" href="/img/siteicon/yang180.png" color="#5bbad5"><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/yang180.png"><link rel="apple-touch-icon-precomposed" sizes="180x180" href="/img/siteicon/yang180.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/yang32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/yang16.png"><link rel="bookmark" href="/img/siteicon/yang180.png"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-2732.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2732-2048.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2388.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2388-1668.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1536-2048.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-1536.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2224.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2224-1668.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1620-2160.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2160-1620.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1290-2796.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2796-1290.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1179-2556.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2556-1179.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1284-2778.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2778-1284.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1170-2532.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2532-1170.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1125-2436.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2436-1125.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2688.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2688-1242.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-828-1792.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1792-828.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2208.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2208-1242.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-750-1334.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1334-750.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-640-1136.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1136-640.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={linkPageTop:void 0,peoplecanvas:void 0,postHeadAiDescription:{enable:!0,gptName:"Liyang",mode:"local",switchBtn:!1,btnLink:"https://afdian.net/item/886a79d4db6711eda42a52540025c377",randomNum:3,basicWordCount:1e3,key:"xxxx",Referer:"https://xx.xx/"},diytitle:{enable:!0,leaveTitle:"不要走",backTitle:"不要离开我     -"},LA51:void 0,greetingBox:{enable:!0,default:"晚上好👋",list:[{greeting:"晚安😴",startTime:0,endTime:5},{greeting:"早上好鸭👋, 祝你一天好心情！",startTime:6,endTime:9},{greeting:"上午好👋, 状态很好，鼓励一下～",startTime:10,endTime:10},{greeting:"11点多啦, 在坚持一下就吃饭啦～",startTime:11,endTime:11},{greeting:"午安👋, 要睡觉喽",startTime:12,endTime:14},{greeting:"🌈充实的一天辛苦啦！",startTime:14,endTime:18},{greeting:"19点喽, 奖励一顿丰盛的大餐吧🍔。",startTime:19,endTime:19},{greeting:"晚上好👋, 在属于自己的时间好好放松😌~",startTime:20,endTime:24}]},twikooEnvId:"https://twikoo.baskly.fun",commentBarrageConfig:void 0,music_page_default:"nav_music",root:"/",preloader:{source:3},friends_vue_info:void 0,navMusic:!0,mainTone:{mode:"both",api:null,cover_change:!0},authorStatus:{skills:["东隅已逝 桑榆非晚","集中精神 攻克难关"]},algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简",rightMenuMsgToTraditionalChinese:"转为繁体",rightMenuMsgToSimplifiedChinese:"转为简体"},noticeOutdate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:330},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,simplehomepage:!0,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{copy:!0,copyrightEbable:!1,limitCount:50,languages:{author:"作者: 李阳",link:"链接: ",source:"来源: 李阳的秘密小屋",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",copySuccess:"复制成功，复制和转载请标注本文地址"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#425AEF",bgDark:"#1f1f1f",position:"top-center"},source:{justifiedGallery:{js:"https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js",css:"https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1,shortcutKey:void 0,autoDarkmode:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={configTitle:"李阳的秘密小屋",title:"数据结构",postAI:"",pageFillDescription:"C语言—数据结构, 一、数据结构之基础, 1.数据结构的三要素, 数据的存储结构有几种, 2、存储结构, 顺序结构, 链式存储, 索引存储, 散列存储, 3.算法特征：, 好算法特征：, 二、链表, 1.数组的优缺点：, 2.链表, 3.术语：, 首节点, 尾节点, 头结点：, 头指针, 4.链表的定义, 5.分类：, 6.算法, 7.创建带头单链表并遍历输出, 8.※链表的基本操作※, 9.李阳的线性表, 10.李阳的带头单链表, 三、栈, 1.定义, 2.分类, 3.算法, 4.应用, 5.栈的表达式求值—后缀表达式（逆波兰表达式）, 6.后缀表达式转中缀, 7.李阳的栈, 四、队列, 1、定义, 2.分类, 3.代码, 4.队列的操作, 5.李阳的队列, 6.李阳的循环队列, 五、递归, 1.简单应用—阶层, 2.定义要求意义, ①定义：, ②递归需要满足的三个条件, ③意义, ④循环：, 六、串、数组和广义表, 一、串（string）, 1.子串的定义, 2.串的类型定义、存储结构及运算, 3.串的表示, 顺序存储, 链式存储, 4.串的模式匹配, 1.BF算法（穷举法）, 2.※※※ KMP算法, 3.KMP算法改进, 二、数组, 1.定义, 2.存储位置, 3.压缩存储, 1.对称矩阵, [特点], [存储方法], 2.三角矩阵, [特点], [存储方法], 3.对角矩阵（带状矩阵）, 4.稀疏矩阵, 十字链表, 三.广义表, 1.定义, 2.性质, 3.广义表和线性表的区别, 4.广义表的基本运算, 七、树, 1.树的定义, 树的定义, 树的基本术语, 树结构和线性结构的比较, 2.二叉树的定义, 定义, 特点, 树和二叉树区别, 3.案例引用, 4.树和二叉树的抽象数据类型定义, 5.二叉树的性质和存储结构, 1.性质, 满二叉树与完全二叉树, 性质1, 性质2, 性质3, 性质4, 性质5, 2.存储结构, 1.二叉树的顺序存储结构, 2.二叉树的链式存储结构, 3.三叉链表, 3.遍历二叉树和线索二叉树, 1.类型, 先—根左右, 中—左根右, 后—左右根, 2.根据遍历序列确定二叉树（先 中 后序）, 实例1：先序+中序, 实例2—中序+后续, 3.遍历的算法实现-先序遍历, 代码实现, 递归代码解释, 4.遍历的算法实现-中序遍历, 5.历的算法实现-后序遍历, 6.二叉树遍历小总结, 7.中序遍历非递归算法-栈, 8.二叉树的层次遍历, 9.二叉树遍历算法的应用, 1.二叉树的建立, 2.复制二叉树, 3.计算二叉树的深度, 4.计算二叉树的结点总数, 5.计算叶子结点的个数, 10.线索二叉树, 1.定义, 2.线索二叉树画法, 3.遍历算法, 11.李阳的交换左右子树, 6.树和森林, 1.定义, 2.双亲表示法, 3.孩子链表, 4.*孩子兄弟表示法（二叉树表示法二叉链表表示法）, 1.定义, 5.*树与二叉树的转换, 1.定义, 2.操作, 1.将树转为二叉树, 2.将二叉树转为树, 6.*森林和二叉树的转换（二叉树与多棵树之间的关系), 1.森林转化为二叉树, 2.二叉树转为森林, 7.树与森林的遍历, 1.树的遍历的三种方式{先根（次序)后根层次遍历}, 2.森林的遍历, 1.先序遍历, 2.中序遍历, 3.小案例, 7.*哈夫曼树及其应用, 1.基本概念, 2.哈夫曼算法, 1.构造方法, 总结, 2.哈夫曼树的算法, 顺序结构（一维数组）, 3.哈夫曼编码, 1.方法, 问题, 2.实现, 4.编码的实现, 八、图, 1.图的定义和基本术语, 1.图的定义, 2.图的类型定义, 1.图的抽象数据类型定义如下, 2. 图的操作, 3.图的存储结构, 1.数组（邻接矩阵）表示法, 无向图邻接矩阵, 有向图的邻接矩阵, 有向网的邻接矩阵, 2.邻接矩阵的存储形式, 1.用两个数组分别存储顶点表和邻接矩阵, 2.采用邻接矩阵表示法创建无向网, 算法思想, 3.邻接矩阵的好处和坏处, 好处, 坏处, 3.邻接表表示法（链式）, 1.无向图的邻接表, 特点, 2.有向图, 特点, 3.链式代码, 1.定义代码, 2.采用邻接表表示法创建无向网的算法思想, 5.邻接表的特点, 1.特点, 4.邻接矩阵与邻接表表示方法的关系, 2.联系, 2.区别, 3.用途, 5.十字链表, 1.简介, 2.具体, 6.邻接多重表, 4.图的遍历, 1.定义, 2.深度优先(DFS), 1.连通图的遍历, 方法, 实现, 效率分析, 结论, 2.广度优先遍历, 1.方法, 2.实现, 3.效率分析, 4.效率比较, 5.图的应用, 1.最小生成树, 1.生成树的简介, 2.无向图的生成树, 3.最小生成树, 构造最小生成树, Prim-普里姆算法, Kruskal-克鲁斯卡尔算法, 两种比较, 2.最短路径, 1.定义, 2.Dijkstra算法, 概述, 具体-按路径长度递增次序产生最短路径, 3.Floyd 弗洛伊德算法, 算法思想, 3.拓扑排序, 1.AOV网, 定义, 特点, 检测AOV 网中是否存在环方法, 2.AOE网, 3.拓扑排序, 4.关键路径, 讨论语言数据结构故天将降大任于是人也必先苦其心志劳其筋骨饿其体肤空乏其身行拂乱其所为孟子告子章句下第十五节一数据结构之基础数据结构的三要素若采用顺序存储则各个数据元素在物理上必须是连续的若采用非顺序存储则各个数据元素在物理上可以是离散的数据的存储结构会影响存储空间分配的方便程度数椐的存储结构会影响对数据运算的速度数据的存储结构有几种线性连续存储数组优点存储速度很快缺点插入和删除元素很慢空间通常是有限的离散存储链表优点空间没有限制插入删除元素很快缺点存取速度很慢存储结构顺序结构顺序存储把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中元素之间的关系由存储单元的邻接关系来体现链式存储链式存储逻辑上相邻的元素在物理位置上可以不相邻借助指示元素存储地址的指针来表示元素之间的逻辑关系指针链接指针索引存储索引存储在存储元素信息的同时还建立附加的索引表索引表中的每项称为索引项索引项的一般形式是关键字地址离散的散列存储散列存储根据元素的夭键字直接计算出该元素的存储地址又称哈希存储算法特征确定性可行性输入输出好算法特征正确性可读性健壮性高效率与低存储需求时间空间复杂度低二链表数组的优缺点优点存储速度快缺点需要一个连续很大的内存插入和删除元素的效率很低链表优点插入删除元素效率高不需要一个连续的很大内存缺点查找某个元素的效率低术语首节点存放第一个有效数据的节点尾节点存放最后一个元素的有效数据节点头结点头结点的数据类型和首节点的类型是一样的头结点是首结点前面的那个节点头结点里面不存放有效数据设置结点是为了方便对链表经行操作头指针存放头结点的地址的指针变量可以通过头指针推算出链表的其他信息链表的定义个节点离散分配彼此通过指针相连接每个节点只有一个前驱节点和后驱节点首节点没有前驱节点尾节点没有后续节点数据指向下一元素的指针域递归相同类型的指针等价于等价于分类单链表双链表每一个节点都有两个指针域循环链表能通过任何一个节点找到其他所有节点非循环链表算法遍历查找清空销毁排序删除节点插入节点创建带头单链表并遍历输出郝斌老师代码李阳数据结构之链表定义单链表数据指向下一元素的指针域递归相同类型的指针等价于等价于等价于创建一个非循环的单链表并将该链表的头结点的地址给遍历创建单链表带头返回值是一个地址用来临时存放用户输入的节点值分配了一个不存放有效数据的头结点内存分配失败定义了一个指针变量首先分配一个头节点然后将初始化为指向这个头节点由于此时链表为空头节点也是尾节点地址为空请输入链表的节点个数请输入第个节点的值内存分配失败将临时的值放给新创的节点设置为指向新节点的指针这样新节点就被添加到了链表的末尾将指向链表的最后一个节点更新向后移遍历输出定义了一个指针变量将链表的头指针给不为时打印的数据向后移链表的基本操作郝斌老师代码李阳数据结构之单链表数据指向下一元素的指针域递归相同类型的指针等价于等价于遍历是否为空等价于创建一个非循环的单链表并将该链表的头结点的地址给遍历判断链表是否为空链表为空链表不空返回链表长度链表长度是排序从小到大排序后的代码是插入删除删除成功您删除的元素是删除未成功返回值是一个地址用来临时存放用户输入的节点值分配了一个不存放有效数据的头结点内存分配失败定义了一个指针变量首先分配一个头节点然后将初始化为指向这个头节点由于此时链表为空头节点也是尾节点地址为空请输入链表的节点个数请输入第个节点的值内存分配失败将临时的值放给新创的节点设置为指向新节点的指针这样新节点就被添加到了链表的末尾将指向链表的最后一个节点更新向后移定义了一个指针变量将链表的头指针给不为时打印的数据向后移判断链表是否为空返回链表长度定义了一个指针变量将头节点的地址给他如果这里面是空的指向下一个元素排序放的是第一个元素放的是的后面的一个元素插入在第的前面插入一个新的节点从开始动态内存分配失败定义了一个新节点将先放进去此时已经来到了的地方也就是他的前面将他的地址给再将的下一元素的地址给删除第个必须要知道第二个第个节点将要删除的节点保存下来删除节点后面的节点李阳的线性表李阳线性表定义了一个数组当前长度初始化顺序表插入元素第位置插入插入位置不合法表满了依次向后移当用户输入在的位置插入其实是在索引的位置如果想修改可以将改为即可删删除第个元素并保存在中保存被删除的元素找到被删除元素位置向前移遍历这里传的而不是是值传递不需要对数据进行修改返回当前元素个数修改指定位置元素查找索引为的指定元素查找元素的位置返回第一个匹配元素的位置返回的是位置索引从开始计数未找到初始化插入遍历删除删除的元素是李阳的带头单链表李阳带头单链表初始化动态内存分配失败尾插法创建失败头插法创建失败尾巴结点为遍历删除指定元素没找到哦返回指定元素检查是否越界索引越界或者返回一个特殊值表示错误比如或需要包含获取链表的长度不计算头结点释放链表内存的函数从头结点的下一个节点开始释放最后释放头结点在指定位置添加数据内存分配失败特殊情况在头部插入位置超出链表长度插入位置超出链表长度根据索引删除元素并将值保存在中链表为空链表为空无法删除删除有误尾插法头插法删除元素获取链表长度释放链表内存三栈定义一种可以实现先进后出的存储结构栈类似于一个箱子先放进去的后拿出来后进去的先拿出来分类静态栈动态栈算法出栈压栈郝斌老师代码数据结构之栈李阳栈元素顶部元素底部等价于建立了一个名为的成员变量里面有两个元素和里面暂时没有有效数据初始化造出空栈压栈压栈压栈压栈输出清空输出出栈出栈成功出栈的元素是出栈失败输出初始化将指向一个新造的空节点内存分配失败地址都指向空节点将新造的节点的指针域为空因为他是最后一个元素的下一个元素因此没有指针域压栈进栈此时里面放的是初始化时的临时变量地址这里调用将新建的栈的指针域指向初始化的元素地址再将新的节点地址给遍历定义个临时指针变量将头的值给当为底部元素时程序终止指向的下一元素地址出栈把所指向的栈出栈一次并将出栈元素存入新参所指向的变量中成功返回否则定义一个变量将顶元素给再将指向下一元素这样就被孤立了清空表指向第二个又指向了下一个元素了应用函数调用中断表达式求值内存分配缓存处理迷宫栈的表达式求值后缀表达式逆波兰表达式例如后缀表达式为遇到一个运算符他会在前面两个数字间运算然后向后移到总结操作数和运算符操作数如变量和常数直接添加到输出列表中运算符则需要根据优先级和括号来决定是否入栈弹出或保持在栈中运算符优先级运算符的优先级从高到低一般为和乘法和除法优先级高和加法和减法优先级低在遇到相同优先级的运算符时按照左结合性处理从左到右括号的处理遇到左括号时直接入栈遇到右括号时弹出栈中的运算符到输出直到遇到对应的左括号为止左括号被丢弃栈的使用当一个运算符被处理时检查栈顶运算符的优先级如果栈顶运算符的优先级高于或等于当前运算符则弹出栈顶运算符到输出否则将当前运算符入栈表达式结束时的处理当整个中序表达式处理完毕后仍有运算符在栈中时将它们全部弹出到输出后缀表达式的特征后缀表达式不需要括号因为运算符的顺序和位置已经明确了运算的优先级和关联性当一个运算符被处理时检查栈顶运算符的优先级如果栈顶运算符的优先级高于或等于当前运算符则弹出栈顶运算符到输出否则将当前运算符入栈总结栈底部的运算符永远是最低的遇到括号先输出括号里的运算符但不保留括号当有刚入栈的运算符小于或等于当前栈中的运算符那直接将栈出到小于此运算符的位置来看个小例子吧当栈低为或时来了个或时可以留着栈中当此时又来了一个新运算符假设为此时栈中的为和那么将和直接出栈再放入栈中假设栈底运算符为或者当入栈为或时那么将或出栈将或压入栈底部当栈低为和时此时入栈了一个那么将出栈留在栈中也压入栈中特别注意的运算符是在两个运算的字母后的例题遇到括号左括号进栈输出进栈输出扫描到右括号出栈此时为入栈左括号入栈输出入栈输出右括号出栈此时变为栈低为扫描入栈因为的优先级不大于因此出栈此时变为栈低为输出进栈的优先级不大于要出栈但是因为我们的运算符要相匹配因此输出在依次输出栈这里表示和进行指数运算表示乘法结果除以的结果输出进栈输出此时为在栈里面扫描左括号入栈输出进栈输出进栈因为我们的优先级低于所以的位置上移动出栈输出扫描到又括号出栈出栈栈低为和此时为入栈因为的优先级不大于所以出栈入栈栈里为输出进栈因为是个组合所以输出结果是后缀表达式转中缀我们学完了中缀转后缀下面来试一试后缀表达式转中缀吧我们先来看题吧首先我们的进栈这时我们扫描到运算符这时候就变成然后入栈遇到运算符要与他的前两位进行计算进栈扫描到运算符就变成然后入栈此时栈里存放的是和然后扫描到运算符就变成因为我们左右两边是个整体所以要加括号然后再入栈进栈扫描到就变成此时栈里存放的是和扫描到就变成本题结束由此我们可以反推出字母总是两两存在的因此在中序转后缀需要考虑组合后缀转中缀的是运算符之前的两位数字字母进行计算李阳的栈李阳链式栈定义栈结构栈顶指针初始化为表示空栈初始化初始化栈顶指针为判断栈是否为空解析让我来为你解析吧首先我们定义了一个链表然后一个空栈里面有一个指向然后我们传入一个元素假设为然后新节点的指向当前栈顶这俩是核心代码我们直接说这个上面初始化为所以里面就是然后为指针类型的就是将指向了他的指针我理解的是双胞胎栈的的指针就指向了假设我们现在又传入了一个的里面放的是的地址我们又将的地址给了类似再向上移动入栈新节点的指向当前栈顶我又来啦现在由李阳为你解析链栈的出栈我们这个是有返回值的首先传入一个栈是毋庸置疑的还需要一个小小的判断如果栈里面没有元素呢核心代码首先我们定义了一个临时变量用于存放栈顶这里里面放的是最后一个元素的地址根据地址可以找到元素没问题吧然后我们再将栈顶的元素的下一个地址重新给我们之前里面放的是栈顶的地址现在我们变成传入栈顶的下一元素的地址也就是将向下移动栈是空的打印取出栈顶元素栈为空释放下一个元素来检验一下吧初始化栈顶元素是出栈了四队列定义一种可以实现先进先出的存储结构排队买票进站分类链式队列链表静态队列数组静态队列通常都必须是循环队列代码郝斌老师代码李阳数据结构之静态循环队列首尾改变实参的值所以要加入队列遍历判断是否满出队判断是否为空调用初始化函数出队成功修正输出格式出队失败初始化定义了个数据的数组初始化入队队列满啦将值放入尾部并且尾部要尾部因为是循环队列当他满的时候会又从开始判断是否为满遍历判断是否空出队因为要带回来值所以要表是空的队列的操作所有和时间有关的操作李阳的队列李阳链式队列定义节点结构定义队列结构队头指针队尾指针初始化判断队列是否为空返回为空不为空所以为类型入队出队队列是空的先进先出打印释放取队头元素队列为空打印队列内容队头再次打印队列内容释放队列内存李阳的循环队列李阳循环队列定义循环队列结构指向队列数组的指针队列的最大容量队头索引队尾索引指向下一个入队位置队列中当前元素的数量初始化循环队列内存分配失败内存分配失败检查队列是否为空检查队列是否已满入队操作队列已满无法入队出队操作队列为空无法出队队列中只有一个元素出队后队列为空打印队列中的所有元素用于调试队列为空释放队列占用的内存出队元素这将导致队列满尝试再次入队会失败因为队列已满五递归简单应用阶层数据结构之递归李阳求阶层循环版的阶层是递归版请输入要求的阶层的阶层是递归实现定义要求意义定义一个函数间接或直接调用自己递归需要满足的三个条件递归必须要有一个明确的终止条件该函数所处理的数据规模必须在递减这个转化必须是可解的意义优点易于理解缺点速度慢存储空间大循环不易理解速度快存储空间小六串数组和广义表一串个或多个任意字符组成的有限序列子串的定义一个串中任意个连续字符组成的子序列含空串称为该串的子串例如的子串有真子串是指不包含自身的所有子串主串包含子串的串相应的称为主串字符位置字符在序列中的序号为该字符串中的位置子串位置子串第一个字符在主串中的位置空格串由一个或多个空格组成的串与空串不同串相等当且仅当两个串的长度相等并且各个对应立置上的字符都相同时这两个串才是相等的串的类型定义存储结构及运算顺序存储结构顺序串链式存储结构链式串串的表示顺序存储串的顺序存储结构存储串的一维数组串的当前长度链式存储串的链式存储结构块链结构存储字符块指向下一个块的指针串的首指针串的尾指针串的当前长度串的模式匹配算法穷举法匹配成功算法计算模式串的数组的当前位置前缀的长度通常设为注意是位置的前缀长度使用数组回溯算法实现返回模式串在主串中首次出现的位置的当前位置的当前位置表示需要跳过使用数组回溯匹配成功返回匹配位置匹配失败返回算法改进的当前位置前缀的长度通常设为使用数组回溯二数组定义按照一点格式排列起来的具有相同的数据元素集合一维数组若线性表中的元素为非结构的简单元素则称为一维数组线性结构定长的线性表二维数组若一维数组中的元素又是一维数组结构则称为二维数组二维数组逻辑结构非线性结构每一个元素既在一个行表中又在一个列表中线性结构该线性表的每一个元素也是一个定长的线性表数组特点结构固定定义后维度和为界不再改变结论线性表结构是数组的一个特例而数组结构又是线性表结构的扩展基本操作除了结构的初始化和销毁之外只有取元素和修改元素值的操作一般采用顺序结构来表示数组存储位置数组元素的存储位置是是存储每个元素所需要个存储单元压缩存储什么是压缩存储若多个数据元素的值都相同则只分配一个元素值的存储空间且零元素不占存储空间什么样的矩阵能够压缩一些特殊矩阵如对称矩阵对角矩阵三角矩阵稀疏矩阵等什么叫稀疏矩阵矩阵中非零元素的个数较少一般小于对称矩阵特点沿着对角线对称在的矩阵中满足如下性质存储方法只存储下或者上三角包括主对角线的数据元素共占用个元素空间三角矩阵特点对角线以下或者以上的数据元素不包括对角线全部为常数存储方法重复元素共享一个元素存储空间共占用个元素空间对角矩阵带状矩阵特点在的方阵中所有非零元素都集中在以主对角线为中心的带状区域中区域外的值全为则称为对角矩阵常见的有三对角矩阵五对角矩阵七对角矩阵等稀疏矩阵稀疏矩阵设在的矩阵中有个非零元素令当时称为稀疏矩阵三元组顺序表又称有序的双下标法三元组顺序表的优点非零元在表中按行序有序存储因此便于进行依行顺序处理的矩阵运算三元组顺序表的缺点不能随机存取若按行号存取某一行中的非零元则需从头开始进行查找十字链表优点它能够灵活地插入因运算而产生的新的非零元素删除因运算而产生的新的零元素实现矩阵的各种运算三广义表定义广义表又称列表是个元素的有限序列其中每一个或者是原子或者是一个广义表广义表通常记作其中为表名为表的长度每一个为表的元素习惯上一般用大写字母表示广义表小写字母表示原子表头若非空则其第一个元素就是表头记作注表头可以是原子也可以是子表表尾除表头之外的其它元素组成的表记作注表尾不是最后一个元素而是一个子表性质广义表中的数据元素有相对次序一个直接前驱和一个直接后驱广义表的长度定义为最外层所包含元素的个数如是长度为的广义表广义表的深度定义为该广义表展开后所含括号的重数的深度为的深度为的深度为注意原子的深度为空表的深度为广义表可以为其他广义表共享如广义表就共享了广义表在中不必列出的值而是通过名称来引用广义表可以是一个递归的表如注意递归表的深度是无穷值长度是有限值这里长度是广义表是多层次结构广义表的元素可以是单元素也可以是子表而子表的元素还可以是子表可以用图形象地表示例其中广义表和线性表的区别广义表可以看成是线性表的推广线性表是广义表的特例广义表的结构相当灵活在某种前提下它可以兼容线性表数组树和有向图等各种常用的数据结构当二维数组的每行或每列作为子表处理时二维数组即为一个广义表另外树和有向图也可以用广义表来表示由于广义表不仅集中了线性表数组树和有向图等常见数据结构的特点而且可有效地利用存储空间因此在计算机的许多应用领域都有成功使用广义表的实例广义表的基本运算案例分析代码实现七树树的定义树的定义树是个结点的有限集递归若称为空树若则它满足如下两个条件有且仅有一个特定的称为根的结点其余结点可分为个互不相交的有限集其中每一个集合本身又是一棵树并称为根的子树树的基本术语结点数据元素以及指向树的分支根结点非空树中无前驱点的结点结点的度结点拥有的子树数树的度数内各结点的度的最大值叶子结点终端结点度为分支结点非终端结点内部结点根节点以外的分支结点称为内部结点孩子结点结点的子树的根称为孩子双亲结点孩子结点的前驱是的孩子结点是的双亲结点兄弟结点同级的结点祖先结点从根到该结点所经分支上的所有结点的祖先结点为子孙结点从某结点为根的子树的任意结点的孙子有树的深度树中结点的最大层次有序树树中的各子树从左至右有次序最左边为第一个孩子无序树树中结点的各子树无次序森林是棵互不相交的树的集合树一定是森林森林不一定是树树结构和线性结构的比较二叉树的定义定义二叉树是个结点的有限集它或者是空集或者由一个根结点及两棵互不相交的分别称作这个根的左子树和右子树的二叉树组成特点每个结点最多有俩孩子二叉树中不存在度大于的结点子树有左右之分其次序不能颠倒二叉树可以是空集合根可以有空的左子树或空的右子树树和二叉树区别二叉树不是树的特殊情况它们是两个概念二叉树结点的子树要区分左子树和右子树即使只有一棵子树也经行区分说明它是左子树还是右子树树当结点只有一个孩子时就无须区分它是左还是右的次序因此二者是不同的这是二叉树与树的最主要的差别也就是二叉树每个结点位置或者次序都是固定的可以是空但是个可以说它没有位置而树的结点位置是相对于别的结点来说的没有别的结点时它就无所谓左右了案例引用树和二叉树的抽象数据类型定义二叉树的性质和存储结构性质满二叉树与完全二叉树满二叉树一颗深度为且有个结点的二叉树就叫满二叉树完全二叉树深度为的具有个结点的二叉树当且仅当每一个结点都与深度为的满二叉树中的编号为的结点一一对应时称为完全二叉树叶子结点的编号是连续的左侧树必须满元素叶子只可能分布在层次最大的两层上对任意结点如果其右子树的最大层次为则其左子树的最大层次必为或性质在二叉树的第层上至多有个结点性质深度为的二叉树至多有个结点性质对任何一个二叉树如果其叶子为度为的结点为则这里叶子结点有个度为的有有五个总结点数又总边个数性质具有个结点的完全二叉树的深度为性质如果有一颗个结点的完全二叉树深度为的结点按层编号从第层到第层每层从左到右对任一结点有如果则结点是二叉树的根无双亲如果则其双亲是结点如果则结点为叶子结点无左孩子否则其左孩子是结点如果则结点无右孩子否则其右孩子是结点总结编号为他的父结点为左结点为右节点存储结构二叉树的顺序存储结构实现按满二叉树的结点层次编号依次存放在二叉树的数据元素缺点结点间的关系蕴含在其存储位置中浪费空间适合满二叉树和完全二叉树二叉树的链式存储结构左右孩子在个结点的二叉链表中有个空指针域必有个链域除根节点外每个结点有且仅有一个双亲所有只会有个结点的链域存放指针指向非空子女结点三叉链表指向双亲结点遍历二叉树和线索二叉树类型先序遍历根左右中序遍历左根右后续遍历左右根先根左右中左根右后左右根实例根据遍历序列确定二叉树先中后序若二叉树中的各结点均不相同则二叉树结点的先徐序列中序序列和后序序列都是唯一的由二叉树的先序和中序序列或由二叉树的后序和中序序列可以确定唯一一颗二叉树实例先序中序先中解题思路由先知必为根必为左由中知在左部在右边由先序知道为根由中序知道为左子树为右子树由先序知道是根那么为左子树为右子树由中序左根右知道为左为右先序知道为根中序知道为左由中序知道为左子树实例中序后续中序序列后序序列由中序后续知道根为为左根为右根后序知道为根中序推出没有左根为下一个根左右根为左为右边后序知道为根由中序知道没有左那么为左为根遍历的算法实现先序遍历代码实现指向根节点的指针递归代码解释首先进入函数此时为传入的根结点打印根节点第一次调用根左右函数指向根进入第二层循环遍历左左为空此时返回回到第二层循环此时为空那么自动执行下一条语句进入循环执行到再向下执行为空返回到第一次循环再执行明白了吗遍历的算法实现中序遍历指向根节点的指针可替换访问根节点历的算法实现后序遍历指向根节点的指针可替换访问根节点二叉树遍历小总结时间复杂度每个结点只访问一次空间复杂度栈占用的最大辅助空间中序遍历非递归算法栈初始化遇到的是根的时候不为空入栈访问左子树出栈输出根二叉树的层次遍历队列定义初始化根节点指针进入队列队不为空则循环出栈结点访问结点有左孩子时将其进队有右孩子时将其进队二叉树遍历算法的应用二叉树的建立生成根节点构造左子树构造右子树复制二叉树计算二叉树的深度如果是空树则深度为否则递归计算左子树的深度计为递归计算右子树的深度计为二叉树的深度则为与的较大者计算二叉树的结点总数如果为空树则结点为否则结点个数为左子树个数右子树结点个数再计算叶子结点的个数如果是空树返回否则为左子树的叶子结点右子树的叶子结点空树如果是叶子结点返回线索二叉树如果某个结点的左孩子为空则将空的左孩子指针域改为指向其前驱如果某孩子的右结点为空则将空的右孩子的指针域改为指向其后继这里是依照遍历来判断前驱后继而不是图定义表示是左右孩子表示是前后继线索二叉树画法遍历算法不要求掌握李阳的交换左右子树李阳树的交换左右子树失败的树交换左右子树交换左半树右半边树前序遍历打印二叉树释放二叉树内存构建一个简单的二叉树树和森林要求森林与二叉树的转换树和森林的遍历定义森林是棵互不相交的树的集合双亲表示法实现定义结构数组存放树的结点每个结点含两个域数据域存放结点本身信息双亲域指示本结点的双亲结点在数组中的位置特点找双亲容易找孩子难树的结点定义数据元素双亲位置域树的类型定义双亲表示节点数根节点位置孩子链表把每个结点的孩子结点排列起来看成是一个线性表用单链表存储则个结点有个孩子链表叶子的孩子链表为空表而个头指针又组成一个线性表用顺序表含个元素的结构数组存储解释每个结点都有一个单链表叶子节点的单链表是空表然后再将这些链表的头指针存放在数组中孩子结点结构整数下一个孩子的地址双亲结点结构数据元素孩子链表头指针树结构头指针数组节点数和根节点位置下标特点找孩子容易找双亲难孩子兄弟表示法二叉树表示法二叉链表表示法定义实现用二叉链表作树的存储结构链表中的美观结点的指针域分别指向其第一个孩子节点和下一个兄弟节点元素类型数据元素第一个孩子下一个兄弟左孩子右兄弟是兄弟的就来砍我特点找孩子找兄弟简单找双亲难树与二叉树的转换定义将树转化为二叉树利用二叉树的算法实现对树的操作由于树和二叉树都可以用二叉链表作存储结构则以二叉树链表作媒介可以导出树与二叉树之间的对应关系操作将树转为二叉树加线在兄弟之间加一连线抹线对每个结点除了其左孩子外去除其与其余孩子之间的关系旋转以树的根结点为轴心将整树顺时针转将二叉树转为树加线若结点是双亲结点的左孩子则将的右孩子右孩子的右孩沿分支找到的所有右孩子都与的双亲用线连起来抹线抹掉原二叉树中双亲与右孩子之间的连线调整将结点按层次排列形成树结构森林和二叉树的转换二叉树与多棵树之间的关系森林转化为二叉树将各棵树分别转换成二叉树将每棵树的根结点用线相连以第一棵树根结点为二叉树的根再以根结点为轴心顺时针旋转构成二叉树型结构二叉树转为森林抹线将二叉树中根结点与其右孩子连线及沿右分支搜索到的所有右孩子间连线全部抹掉使之变成孤立的二又树去掉全部右孩线还原将孤立的二又树还原成树孤立二叉再还原树与森林的遍历树的遍历的三种方式先根次序后根层次遍历先根遍历次序若树不空则先访问根结点然后依次先根遍历各棵子树后根遍历次序若树不空则先依次后根遍历各棵子树然后访问根结点层次遍历若树不空则至上而下自左至右访问树的每个结点森林的遍历将森林看作部分构成森林中第一棵树的根结点森林中第一棵树的子树森林森林中其它树构成的森林先序遍历若森林不空则访问森林中第一棵树的根结点先序遍历森林中第一棵树的子树森林先序遍历森林中除第一棵树之外其余树构成的森林中序遍历若森林不空则中序遍历森林中第一棵树的子树森林访问森林中第一棵树的根结点中序遍历森林中除第一棵树之外其余树构成的森林对应小案例哈夫曼树及其应用要求哈夫曼树和哈夫曼编码并查集及其应用堆及其应用新增基本概念路径从树中的一个结点到另一个结点之间的分支构成这两个结点间的路径结点路径的长度两结点间的路径上的分支数树的路径长度从树根到每一个结点的路径长度之和记作结点数目相同的二叉树中完全二叉树是路径长度最短的二叉树权将树中结点赋给一个有着某种含义的数值则这个数值称为该结点的权结点的带权路径长度从根节点到该结点之间的路径长度与该结点的权的乘积树的带权的路径长度树中的所有叶子结点带权路径长度之和最优树带权路径最短的树最优树度要相同最优二叉树带权路径长度最短的二叉树满二叉树不一定是哈夫曼树具有相同带权结点的哈夫曼树不唯一贪心算法构造哈夫曼树时首先选择权最小的叶子结点哈夫曼算法构造方法根据个给定的权值构成的棵二叉树的森林其中只有一个带权为的根节点构造森林全是根在中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树且设置新的二叉树的根结点的权值为其左右子树上根结点的权值之和选用两小造新树在中删除这两棵树同时将新得到的二叉校加入森林中删除两小添新人重复剩单根总结哈夫曼树的结点只有度为或的没有度为的结点包含各叶子结点的哈夫曼树共有个结点包含棵树的森林要经过次合并才能形成哈夫曼树共产生个新结点在哈夫曼算法中初始时有棵二叉树要经过次合并最终形成哈夫曼树经过次合并产生个新结点且这个新结点都是具有两个孩子的分支结点可见哈夫曼树中共有个结点且其所有的分支结点的度均不为哈夫曼树的算法顺序结构一维数组权值双亲左孩子右孩子构造哈夫曼树哈夫曼算法数组共个元素号单元未用表示根结点将个元素的置为输入前个元素的值初始化结束下面开始建立哈夫曼树合并产生个结点构造树在中选择两个其双亲域为且权值最小的结点并返回它们在中的序号和表示从中删除分别作为的左右孩子的权值为左右孩子权值之和初始化输入初始个叶子结点置的值进行以下次合并依次产生个结点在中选两个未被选过从的结点中选的最小的两个结点和为两个最小结点下标修改和的的值修改新产生的哈夫曼编码前缀编码任意一字符不是另一个字符的前缀方法统计字符集中每个字符在电文中出现的平均概率概率越大要求编码越短利用哈夫曼树的特点权越大的叶子离根越近将每个字符的概率值作为权值构造哈夫曼树则概率越大的结点路径越短在哈夫曼树的每个分支上标上或结点的左分支标右分支标把从根到每个吐子的路径上的标号连接起来作为该叶子代表的字符的编码左分支标记右分支标记问题为什么哈夫曼编码能够保证是前缀编码因为没有一片树叶是另一片树叶的祖先所以每个叶结点的编码就不可能是其它叶结点编码的前缀为什么哈夫曼编码能够保证字符编码总长最短因为哈夫曼树的带权路径长度最短故字符编码的总长最短性质哈夫曼编码是前缀编码性质哈夫曼编码是最优前缀码实现从叶子到根逆向求每个字符的哈夫曼编码存储在编码表中分配个字符编码的头指针矢量分配临时存放编码的动态数组空间编码结束符逐个字符求哈夫曼编码从叶子结点开始向上回溯直到根结点回溯一次向前指一个位置结点是的左孩子则生成代码结点是的右孩子则生成代码继续向上回溯求出第个字符的编码为第个字符串编码分配空间将求得的编码从临时空间复制到的当前行中释放临时空间编码的实现八图图的定义和基本术语图的定义图顶点数据元素的有穷非空集合边的有穷集合无向图每条边都没有方向有向图每条边都有方向完全图任意两个点都有一条边相连稀疏图有很少边或弧的图稠密图有较多边或弧的图网边弧带权的图邻接有边弧相连的两个顶点之间的关系存在则称和互为邻接点无向图存在则称邻接到邻接于有向图关联边弧与顶点的关系存在称为该边弧关联于和顶点的度与该顶点相关联的边的数目记为在有向图中顶点的度等于该顶点的入度与出度之和顶点的入度是以为终点的有向边的条数记作顶点的出度是以为始点的有向边的条数记作路径接续的边构成的顶点序列路径长度路径上边或弧的数目权值之和回路环第一个顶点和最后一个顶点相同的路径简单路径除路径起点和终点可以相同外其余顶点均不相同的路径简单回路简单环除路径起点和终点相同外其余顶点均不相同的路径连通图强连通图在无有向图中若对任何两个顶点都右在从至到的路径称是连通图裾连通图权与网图中边或弧所具有的相关数称为权表明从一个顶点到另一个顶点的距离或耗费带权的图称为网子图设有两个图若则称是的子图连通分量强连通分量无向图的极大连通子图称为的连通分量极大连通子图意思是该子图是连通子图将的任何不在该子图中的顶点加入子图不再连通有向图的极大强连通子图称为的强连通分量极大强连通子图意思是该子图是的强连通子图将的任何不在该子图中的顶点加入子图不再是强连通的极小连通子图该子图是的连通子图在该子图中删除任何一天边子图不再连通生成树包含无向图所有顶点的极小连通子图生成森林对非连通图由各个连通分量的生成树的集合图的类型定义图的抽象数据类型定义如下数据对象具有相同特性的数据元素的集合称为顶点集数据关系表示从到的弧定义了弧的信息图的操作图的存储结构数组邻接矩阵表示法无向图邻接矩阵分析无向图的邻接矩阵是对称的分析顶点的度第行列中的的个数特别完全的邻接矩阵中对角元素为其余为有向图的邻接矩阵分析有向图的邻接矩阵可能不是对称的分析顶点的出度第行元素之和指向和顶点的出度第列元素之和顶点的度第行元素之和第列元素之和有向网的邻接矩阵网即有权图的邻接矩阵表示法定义为或无边弧如果两个顶点之间存在弧或边那么我就记录两个顶点为权如果不存在则记录无穷大邻接矩阵的存储形式用两个数组分别存储顶点表和邻接矩阵最大顶点数设顶点的娄文据类型为字符型假设边的权值类型为整型顶点表邻接矩阵图的当前点数和边数采用邻接矩阵表示法创建无向网算法思想输入总顶点数和总边数依次输点的信息存人顶点表中初始化邻接矩阵使每个权值初始化为极大值构造邻接矩阵代码先欠着邻接矩阵的好处和坏处好处直观简单好理解方便检查任意一对顶点间是否存在边方便找任一顶点的所有邻接点有边直接相连的顶点方便计算任一顶点的度从该点发出的边数为出度指向该点的边数为入度无向图对应行或列非元素的个数有向图对应行非元素的个数是出度对应列非元素的个数是入度坏处不便于增加和删除顶点浪费空间传稀疏图人点很多而边很少有大量无效元素对稠密图特别是完全图还是很合算的浪费时间统计稀疏图中一共有多少条边邻接表表示法链式无向图的邻接表顶点按编号顺序将顶点数据存储在一维数组中关联同一顶点的边以顶点为尾的弧用线性链表存储表示顶点本身表示第一条边的指针以为例子下标为或为的元素的指针表示邻接的顶点表示下一元素的指针特点邻接表不唯一若无向图中有个顶点条边则其邻接表需个头结点和个表结点适宜存储稀疏图无向图中顶点的度为第个单链表中的结点数有向图特点顶点的出度为第个单链表中的结点个数顶点的入度为整个单链表中邻接点域值是的结点个数链式代码定义代码顶点顶点信息类型自义定指向第一条依附该顶点的边的指针表示邻接表类型为最大数组数边结点最大顶点数边结点该边所指向的顶点的位置指向下一条边的指针和边相关的信息图结点的复数顶点数组图的当前顶点数和弧数采用邻接表表示法创建无向网的算法思想算法思想输入总顶点数和总边数建立顶点表依次输入点的信息存入顶点表中使每个表头结点的指针域初始化为创建邻接表依次输入每条边依附的两个顶点确定两个顶点的序号和建立边结点将此边结点分别插入到和对应的两个边链表的头部邻接表的特点特点方便找任一顶点的所有邻接点节约稀疏图的空间需要个头指针个结点每个结点至少个域方便计算任一顶点的度对无向图是的对有向图只能计算出度需要构造逆邻接表存指向自己的边来方便计算入度不方便检查任意对顶点间是否存在边邻接矩阵与邻接表表示方法的关系联系邻接表中每个链表对应于邻接矩阵中的一行链表中结点个数等于一行中非零元素的个数区别对于任一确定的无向图邻接矩阵是唯一的行列号与顶点编号一致但邻接表不唯一链接次序与顶点编号无关邻接矩阵的空间复杂度为而邻接表的空间复杂度为用途邻接矩阵多用于榈密图而邻接表多用于稀疏图十字链表简介十字链表是有向图的另一种链式存储结构我们也可以把它看成是将有向图的邻接表和逆邻接表结合起来形成的一种链表有向图中的每一条弧对应十字链表中的一个弧结点同时有向图中的每个顶点在十字链表中对应有一个结点叫做顶点结点具体数据第一个入度边第一个出度边弧尾位置弧头位置弧头相同的下一条弧弧尾相同的下一条弧邻接多重表图的遍历定义遍历定义从已给的连通图中某一顶点出发沿着一些边访遍图中所有的顶点且使每个顶点仅被访问一次就叫做图的遍历它是图的基本运算遍历实质找每个顶点的邻接点的过程图的特点图中可能存在回路且图的任一顶点都可能与其它顶点相通在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点如何避免回路解决思路设置辅助数组用来标记每个被访问过的顶点初始状态为顶点被访问改为防止被多次访问深度优先连通图的遍历方法在访问图中某一起始顶点后由出发访问它的任一邻接顶点再从出发访问与邻接但还未被访问过的顶点然后再从出发进行类似的访问如此进行下去直至到达所有的邻接顶点都被访问过的顶点为止接着退回一步退到前一次刚访问过的顶点看是否还有其它没有被访问的邻接顶点如果有则访问此顶点之后再从此顶点出发进行与前述类似的访问如果没有就再退回一步进行搜索重复上述过程直到连通图中所有顶点都被访问过为止实现王道代码访问标记数组对图进行深度优先遍历初始化已访问数组从开始遍历从顶点出发深度遍历图访问顶点设已访问标记依次检查邻接矩阵所在的行为还没访问的邻接顶点效率分析用邻接矩阵来表示图遍历图中每一个顶点都要从头扫描该顶点所在的行时间复杂度为用邻接表来表示图虽然有个表结点但只需扫描个结点即可完成遍历加上访问个头结点的时间时间复杂度为结论稠密图适于在邻接矩阵上进行深度遍历稀疏图通于在邻接表上进行深度遍历广度优先遍历方法方法从图的某一结点出发首先依次访问该结点的所有邻接点再按这些顶点被访问的先后次序依次访问与它们相邻接的所有未被访问的顶点重复此过程直至所有顶点均被访问为止实现王道代码访问标记数组对图进行广度优先遍历访问标记数组初始化初始化辅助队列从号顶点开始遍历对每个连通分量调用一次未访问过从开始从顶点出发广度优先遍历图访问初始顶点对做以访问标志顶点入队列顶点出队列检测到的所有邻接点为未访问的邻接顶点访问顶点对做以访问标记顶点入队列效率分析如果使用邻接矩阵则对于每一个被访问到的顶点都要循环检测矩阵中的整整一行个元素总的时间代价为用邻接表来表示图虽然有个表结点但只需扫描个结点即可完成遍历加上访问个头结点的时间时间复杂度为效率比较空间复杂度相同都是借用了堆栈或队列时间复杂度只与存储结构邻接矩阵或邻接表有关而与搜索路径无关图的应用最小生成树生成树的简介生成树所有顶点均由边连接在一起但不存在回路一个图可以有许多棵不同的生成树所有生成树具有以下共同特点生成树的顶点个数与图的顶点个数相同生成树是图的极小连通子图去掉一条边则非连通一个有个顶点的连通图的生成树有条边在生成树中再加一条边必然形成回路生成树中任意两个顶点间的路径是唯一的含有个顶点条边的图不一定是最小生成树无向图的生成树最小生成树最小生成树给定一个无向网络在该网的所有生成树中使得各边权值之和最小的那棵生成树称为该网的最小生成树也叫最小代价生成树构造最小生成树构造最小生成树的算法很多其中多数算法都利用了的性质性质设是一个连通网是顶点集的一个非空子集若边是一条具有最小权值的边其中则必存在一棵包含边的最小生成树普里姆算法算法思想设是连通网是上最小生成树中边的集合初始令在所有的边中找一条代价最小的边将并入集合同时并入重复上述操作直至则为的最小生成树从顶点往下找最小的权克鲁斯卡尔算法所有边按权值排序然后选择最小的当有循环时舍弃这条边当所有边连通时结束与算法不同的是他是按排序来找最小是依次选最小设连通网令最小生树初始状态为只有个顶点而无边的非连通图每个顶点自成一个连通分量在中选取代价最小的边若该边依附的顶点落在中不同的连通分量上即不能形成环则将此边加入到中否则舍去此边选取下一条代价最小的边依此类推直至中所有顶点都在同一连通分量上为止最小生成树可能不唯一两种比较最短路径定义最短路径与最小生成树不同路径上不一定包含个顶点也不一定包含条边单源最短路径迪杰斯特拉算法所有顶点间的最短路径弗洛伊德算法算法概述初始化先找出从源点到各终点的直达路径即通过一条弧到达的路径选择从这些路径中找出一条长度最短的路径更新然后对其余各条路径进行适当调整若在图中存在弧且则以路径代替在调整后的各条路径中再找长度最短的路径依此类推先找出直达的然后与不直达的比较有小的就更新被比较的具体按路径长度递增次序产生最短路径把分成两组辅助数组存放已求出最短路径的顶点的集合尚未确定最短路径的顶点集合将中顶点按最短路径递增的次序加入到中保证从源点到中各顶点的最短路径长度都不大于从到中任何顶点的最短路径长度每个顶点对应一个距离值中顶点从到此顶点的最短路径长度中顶点从到此顶点的只包括中顶点作中间顶点的最短路径长度弗洛伊德算法算法思想逐个顶点试探从到的所有可能存在的路径中选出一条长度最短的路径拓扑排序有向无环图无环的有向图简称一个结点可能有多个前驱但是没有回路网定义用一个有向图表示一个工程的各子工程及其相冥制约的关系其中以顶点表示活动弧表示活动之间的优先制约关系称这种有向图为顶点表示活动的网简称网特点若从到有一条有向路径则是的前驱是的后继若是网中有向边则是的直接前驱是的直接后继网中不允许有回路因为如果有回路存在则表明某项活动以自己为先决条件显然这是荒谬的检测网中是否存在环方法对有向图构造其顶点的拓扑有序序列若网中所有顶点都在它的拓扑有序序列中则该网必定不存在环网用一个有向图表承一个工程的各子工程及其相互制约的关系以弧表示活动以顶点表示活动的开始或结束事件称这种有向图为边表示活动的网简称为网拓扑排序在网没有回路的前提下我们将全部活动排列成一个线性序列使得若网中有弧存在则在这个序列甲一疋排仕的前面具有这种性质的线性序列称为拓扑有序序列相应的拓扑有序排序的算法称为拓扑排序关键路径对于网我们关心两个问题完成整项工程至少需要多少时间哪些活动是影响工程进度的关键关键路径路径长度最长的路径路径长度路径上各活动持续时间之和求解关键路径问题由若干个关键活动组成的就是关键路径最早开始时间从原点开始找到权的最大值最迟发生时间从汇点向前找到最小值具体计算就是弧尾的长度就是连接的是只用算就是路径上的权值就是的权讨论若网中有几条关键路径则需加快同时在几条关键路径上的关键活动如如果一个活动处于所有的关键路径上那么提高这个活动的速度就能缩短整个工程的完成时间如处于所有的关键路径上的活动完成时间不能缩短太多否则会使原来的关键路径变成不是关键路径这时必须重新寻找关键路径如由天变成天就会改变关键路径",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2025-03-02 17:44:23",postMainColor:"#5b697f"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:(e,t,a)=>{if(0===a)return;const o={value:t,expiry:Date.now()+864e5*a};localStorage.setItem(e,JSON.stringify(o))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const a=JSON.parse(t);if(!(Date.now()>a.expiry))return a.value;localStorage.removeItem(e)}},e.getScript=(e,t={})=>new Promise(((a,o)=>{const c=document.createElement("script");c.src=e,c.async=!0,c.onerror=o,c.onload=c.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(c.onload=c.onreadystatechange=null,a())},Object.keys(t).forEach((e=>{c.setAttribute(e,t[e])})),document.head.appendChild(c)})),e.getCSS=(e,t=!1)=>new Promise(((a,o)=>{const c=document.createElement("link");c.rel="stylesheet",c.href=e,t&&(c.id=t),c.onerror=o,c.onload=c.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(c.onload=c.onreadystatechange=null,a())},document.head.appendChild(c)})),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#18171d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#f7f9fe")};const t=saveToLocal.get("theme"),a=window.matchMedia("(prefers-color-scheme: dark)").matches,o=window.matchMedia("(prefers-color-scheme: light)").matches,c=window.matchMedia("(prefers-color-scheme: no-preference)").matches,n=!a&&!o&&!c;if(void 0===t){if(o)activateLightMode();else if(a)activateDarkMode();else if(c||n){const e=(new Date).getHours();e<=6||e>=18?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener((e=>{void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())}))}else"light"===t?activateLightMode():activateDarkMode();const d=saveToLocal.get("aside-status");void 0!==d&&("hide"===d?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="https://jsd-proxy.ygxz.in/npm/js-heo@1.0.11/poem/poem.min.css"><link rel="stylesheet" href="https://jsd-proxy.ygxz.in/npm/js-heo@1.0.11/mainColor/heoMainColor.min.css"><link rel="stylesheet" href="https://jsd-proxy.ygxz.in/gh/lyay23/blogstatic@v1.0.0/static/essay-style.min.css"><link rel="stylesheet" href="https://jsd-proxy.ygxz.in/gh/lyay23/blogstatic@v1.0.0/static/todolist.min.css"><link rel="stylesheet" href="https://jsd-proxy.ygxz.in/gh/lyay23/blogstatic@v1.0.1/static/custom-me.min.css"><link rel="stylesheet" href="https://jsd-proxy.ygxz.in/gh/lyay23/blogstatic@v1.0.0/static/imgloaded.min.css"><link rel="stylesheet" href="https://jsd-proxy.ygxz.in/gh/lyay23/blogstatic@v1.0.0/static/twikoo.min.css"><script async defer src="https://umami.baskly.fun/script.js" data-website-id="83445f1f-eab2-4423-b52a-d98fcec8638f"></script><meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:yellow;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://bu.dusays.com/2025/03/01/67c2609b7c10b.jpg"><div class="loading-image-dot"></div></div></div><script>const preloader={endLoading:()=>{document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",(()=>{preloader.endLoading()})),setTimeout((function(){preloader.endLoading()}),1e4),document.addEventListener("pjax:send",(()=>{preloader.initLoading()})),document.addEventListener("pjax:complete",(()=>{preloader.endLoading()}))</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"><script async src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">李阳的秘密小屋</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size:.9em"></i> <span>隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size:.9em"></i> <span>分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size:.9em"></i> <span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/charts/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tongji1"></use></svg> <span>统计</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=12781955100&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size:.9em"></i> <span>耳机分你一半</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size:.9em"></i> <span>留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/todolist/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zuji"></use></svg> <span>脚步</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/essay/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-taiyang"></use></svg> <span>小太阳</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-a-xiaoyangyang_huaban1"></use></svg> <span>了解我</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i> <span>搜索</span></a></div><input id="center-console" type="checkbox"><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole()"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title">最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/408/" style="font-size:1.05rem">408<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size:1.05rem">C语言<sup>1</sup></a><a href="/tags/java/" style="font-size:1.05rem">java<sup>1</sup></a><a href="/tags/javaweb/" style="font-size:1.05rem">javaweb<sup>9</sup></a><a href="/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/" style="font-size:1.05rem">力扣刷题<sup>1</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size:1.05rem">操作系统<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size:1.05rem">数据结构<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size:1.05rem">计算机组成原理<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size:1.05rem">计算机网络<sup>2</sup></a><a href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" style="font-size:1.05rem">软件工程<sup>1</sup></a></div></div><hr></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多"><i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/09/"><span class="card-archive-list-date">九月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">八月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">三月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li></ul></div><hr></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/408/" itemprop="url">408</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" tabindex="-1" itemprop="url"><span><i class="anzhiyufont anzhiyu-icon-hashtag"></i> 数据结构</span></a></span></div></div><h1 class="post-title" itemprop="name headline">数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-11-20T13:34:21.000Z" title="发表于 2024-11-20 21:34:21">2024-11-20</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-03-02T09:44:23.440Z" title="更新于 2025-03-02 17:44:23">2025-03-02</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">21.1k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>78分钟</span></span><span class="post-meta-separator"></span><span data-flag-title="数据结构"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="twikoo_visitors" title="访问量"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator"></span><span class="post-meta-position" title="作者IP属地为武汉"><i class="anzhiyufont anzhiyu-icon-location-dot"></i> 武汉</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/79666db/#post-comment" tabindex="-1"><span id="twikoo-count"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s58 18 88 18 58-18 88-18 58 18 88 18v44h-352Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://bu.dusays.com/2024/12/15/675eec5c414d7.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://blog.baskly.fun/posts/79666db/"><header><a class="post-meta-categories" href="/categories/408/" itemprop="url">408</a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" tabindex="-1" itemprop="url">数据结构</a><h1 id="CrawlerTitle" itemprop="name headline">数据结构</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">李阳</span><time itemprop="dateCreated datePublished" datetime="2024-11-20T13:34:21.000Z" title="发表于 2024-11-20 21:34:21">2024-11-20</time><time itemprop="dateCreated datePublished" datetime="2025-03-02T09:44:23.440Z" title="更新于 2025-03-02 17:44:23">2025-03-02</time></header><h1 id="C语言—数据结构"><a href="#C语言—数据结构" class="headerlink" title="C语言—数据结构"></a>C语言—数据结构</h1><blockquote><p><strong>故天将降大任于是人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为</strong></p><p>​ ——《孟子·告子章句下·第十五节》</p></blockquote><h2 id="一、数据结构之基础"><a href="#一、数据结构之基础" class="headerlink" title="一、数据结构之基础"></a>一、数据结构之基础</h2><h3 id="1-数据结构的三要素"><a href="#1-数据结构的三要素" class="headerlink" title="1.数据结构的三要素"></a>1.数据结构的三要素</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793b45b922.png" alt></p><p>1.若采用顺序存储，则各个数据元素在物理上必须是连续的;若采用非顺序存储，则各个数据元素在物理上可以是离散的。<br>2.数据的存储结构会影响存储空间分配的方便程度<br>3数椐的存储结构会影响对数据运算的速度</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793baf2244.png" alt></p><h4 id="数据的存储结构有几种"><a href="#数据的存储结构有几种" class="headerlink" title="数据的存储结构有几种"></a><strong>数据的存储结构有几种</strong></h4><p>​ 线性</p><p>​ 连续存储（数组）</p><p>​ 优点：存储速度很快</p><p>​ 缺点：插入和删除元素很慢，空间通常是有限的</p><p>​ 离散存储（链表）</p><p>​ 优点：空间没有限制，插入删除元素很快</p><p>​ 缺点：存取速度很慢</p><h3 id="2、存储结构"><a href="#2、存储结构" class="headerlink" title="2、存储结构"></a>2、存储结构</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793b5b1906.png" alt></p><h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><p>顺序存储,把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。</p><h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><p>链式存储，逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。（指针链接指针）</p><h4 id="索引存储"><a href="#索引存储" class="headerlink" title="索引存储"></a>索引存储</h4><p>索引存储。在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址)离散的</p><h4 id="散列存储"><a href="#散列存储" class="headerlink" title="散列存储"></a>散列存储</h4><p>散列存储。根据元素的夭键字直接计算出该元素的存储地址，又称哈希（Hash）存储</p><h3 id="3-算法特征："><a href="#3-算法特征：" class="headerlink" title="3.算法特征："></a>3.算法特征：</h3><p>确定性，可行性，输入，输出</p><h4 id="好算法特征："><a href="#好算法特征：" class="headerlink" title="好算法特征："></a>好算法特征：</h4><p>正确性，可读性，健壮性，高效率与低存储需求（时间，空间复杂度低）</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793b938586.png" alt></p><h2 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h2><h3 id="1-数组的优缺点："><a href="#1-数组的优缺点：" class="headerlink" title="1.数组的优缺点："></a>1.数组的优缺点：</h3><p>优点：存储速度快</p><p>缺点：需要一个连续很大的内存，插入和删除元素的效率很低</p><h3 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h3><p>优点：插入 删除元素效率高，不需要一个连续的很大内存</p><p>缺点：查找某个元素的效率低</p><h3 id="3-术语："><a href="#3-术语：" class="headerlink" title="3.术语："></a>3.术语：</h3><h4 id="首节点"><a href="#首节点" class="headerlink" title="首节点"></a><strong>首节点</strong></h4><ul><li>存放第一个有效数据的节点</li></ul><h4 id="尾节点"><a href="#尾节点" class="headerlink" title="尾节点"></a><strong>尾节点</strong></h4><ul><li>存放最后一个元素的有效数据节点</li></ul><h4 id="头结点："><a href="#头结点：" class="headerlink" title="头结点："></a><strong>头结点：</strong></h4><ol><li>头结点的数据类型和首节点的类型是一样的</li><li>头结点是首结点前面的那个节点</li><li>头结点里面不存放有效数据</li><li>设置结点是为了方便对链表经行操作</li></ol><h4 id="头指针"><a href="#头指针" class="headerlink" title="头指针"></a><strong>头指针</strong></h4><ul><li>存放头结点的地址的指针变量</li><li>可以通过头指针推算出链表的其他信息</li></ul><h3 id="4-链表的定义"><a href="#4-链表的定义" class="headerlink" title="4.链表的定义"></a>4.链表的定义</h3><ul><li>n个节点离散分配</li><li>彼此通过指针相连接</li><li>每个节点只有一个前驱节点和后驱节点</li><li>首节点没有前驱节点， 尾节点没有后续节点</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> date;<span class="comment">//数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span><span class="comment">//指向下一元素的指针域-递归（相同类型的指针)</span></span><br><span class="line">}Node,*pNode;<span class="comment">//node等价于struct Node,pNode等价于struct Node *</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-分类："><a href="#5-分类：" class="headerlink" title="5.分类："></a>5.分类：</h3><ul><li><p>单链表</p></li><li><p>双链表</p><p>​ 每一个节点都有两个指针域</p></li><li><p>循环链表</p><p>​ 能通过任何一个节点找到其他所有节点</p></li><li><p>非循环链表</p></li></ul><h3 id="6-算法"><a href="#6-算法" class="headerlink" title="6.算法"></a>6.算法</h3><p>遍历</p><p>查找</p><p>清空</p><p>销毁</p><p>排序</p><p>删除节点</p><p>插入节点</p><h3 id="7-创建带头单链表并遍历输出"><a href="#7-创建带头单链表并遍历输出" class="headerlink" title="7.创建带头单链表并遍历输出"></a>7.创建带头单链表并遍历输出</h3><p>郝斌老师代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Created by 李阳 on 2024/9/26.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数据结构之链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义单链表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span><span class="comment">//指向下一元素的指针域-递归（相同类型的指针)</span></span><br><span class="line">}Node,* pNode;<span class="comment">//node等价于struct Node,pNode等价于struct Node *</span></span><br><span class="line"></span><br><span class="line">pNode <span class="title function_">creat_list</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_list</span><span class="params">(pNode pNode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    pNode pHead =<span class="literal">NULL</span>;<span class="comment">//等价于struct Node * pHead =NULL;</span></span><br><span class="line">    pHead = creat_list();<span class="comment">//创建一个非循环的单链表，并将该链表的头结点的地址给pHead</span></span><br><span class="line">    traverse_list(pHead);<span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建单链表（带头）</span></span><br><span class="line"></span><br><span class="line">pNode <span class="title function_">creat_list</span><span class="params">()</span> {<span class="comment">//返回值是一个地址</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> val;<span class="comment">//用来临时存放用户输入的节点值</span></span><br><span class="line">  <span class="comment">//分配了一个不存放有效数据的头结点</span></span><br><span class="line">    pNode pHead =(pNode) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==pHead)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"内存分配失败"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    pNode pTail=pHead;<span class="comment">//定义了一个指针变量，首先分配一个头节点 pHead。然后，将 pTail 初始化为指向这个头节点。由于此时链表为空，头节点也是尾节点。</span></span><br><span class="line">    pTail-&gt;pNext=<span class="literal">NULL</span>;<span class="comment">//地址为空</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入链表的节点个数：len ="</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;len);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; len; ++i) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入第%d个节点的值"</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val);</span><br><span class="line">        pNode pNew =(pNode) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span>==pNew)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"内存分配失败"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line">        pNew-&gt;data=val;<span class="comment">//将临时val的值放给新创的节点</span></span><br><span class="line">        pTail-&gt;pNext=pNew;<span class="comment">// 设置为指向新节点的指针，这样新节点就被添加到了链表的末尾</span></span><br><span class="line">        pNew-&gt;pNext=<span class="literal">NULL</span>;</span><br><span class="line">        pTail=pNew;<span class="comment">//pTail 将指向链表的最后一个节点(更新，向后移）</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pHead ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历输出</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_list</span><span class="params">(pNode pHead)</span></span><br><span class="line">{</span><br><span class="line">      pNode p=pHead-&gt;pNext;<span class="comment">//定义了一个指针变量p，将链表的头指针给p</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span> !=p)<span class="comment">//p不为NULL时</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>,p-&gt;data);<span class="comment">//打印p的数据</span></span><br><span class="line">        p=p-&gt;pNext;<span class="comment">//p向后移</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-※链表的基本操作※"><a href="#8-※链表的基本操作※" class="headerlink" title="8.※链表的基本操作※"></a>8.※链表的基本操作※</h3><p>郝斌老师代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Created by 李阳 on 2024/9/26.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数据结构之单链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span><span class="comment">//指向下一元素的指针域-递归（相同类型的指针)</span></span><br><span class="line">}Node,* pNode;<span class="comment">//node等价于struct Node,pNode等价于struct Node *</span></span><br><span class="line"></span><br><span class="line">pNode <span class="title function_">creat_list</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_list</span><span class="params">(pNode pNode)</span>;<span class="comment">//遍历</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_empty</span><span class="params">(pNode pHead)</span>;<span class="comment">//是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">length_list</span><span class="params">(pNode)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">insert_list</span><span class="params">(pNode,<span class="type">int</span> ,<span class="type">int</span> )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">delete_list</span><span class="params">(pNode pHead,<span class="type">int</span> pos,<span class="type">int</span> *pval)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_list</span><span class="params">(pNode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    pNode pHead =<span class="literal">NULL</span>;<span class="comment">//等价于struct Node * pHead =NULL;</span></span><br><span class="line">    pHead = creat_list();<span class="comment">//创建一个非循环的单链表，并将该链表的头结点的地址给pHead</span></span><br><span class="line">    traverse_list(pHead);<span class="comment">//遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //判断链表是否为空</span></span><br><span class="line"><span class="comment">    if(is_empty(pHead))</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        printf("链表为空！\n");</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    else</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        printf("链表不空");</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //返回链表长度</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int len= length_list(pHead);</span></span><br><span class="line"><span class="comment">    printf("链表长度是 %d\n",len);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //排序</span></span><br><span class="line"><span class="comment">    printf("从小到大排序后的代码是：\n");</span></span><br><span class="line"><span class="comment">    sort_list(pHead);</span></span><br><span class="line"><span class="comment">    traverse_list(pHead);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //插入</span></span><br><span class="line"><span class="comment">    insert_list(pHead,3,44);</span></span><br><span class="line"><span class="comment">    traverse_list(pHead);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //删除</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    if(delete_list(pHead,3,&amp;val))</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        printf("删除成功，您删除的元素是%d\n",val);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    } else</span></span><br><span class="line"><span class="comment">        printf("删除未成功\n");</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    traverse_list(pHead);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">pNode <span class="title function_">creat_list</span><span class="params">()</span> {<span class="comment">//返回值是一个地址</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> val;<span class="comment">//用来临时存放用户输入的节点值</span></span><br><span class="line">  <span class="comment">//分配了一个不存放有效数据的头结点</span></span><br><span class="line">    pNode pHead =(pNode) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==pHead)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"内存分配失败"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    pNode pTail=pHead;<span class="comment">//定义了一个指针变量，首先分配一个头节点 pHead。然后，将 pTail 初始化为指向这个头节点。由于此时链表为空，头节点也是尾节点。</span></span><br><span class="line">    pTail-&gt;pNext=<span class="literal">NULL</span>;<span class="comment">//地址为空</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入链表的节点个数：len ="</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;len);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; len; ++i) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入第%d个节点的值"</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val);</span><br><span class="line">        pNode pNew =(pNode) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span>==pNew)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"内存分配失败"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line">        pNew-&gt;data=val;<span class="comment">//将临时val的值放给新创的节点</span></span><br><span class="line">        pTail-&gt;pNext=pNew;<span class="comment">// 设置为指向新节点的指针，这样新节点就被添加到了链表的末尾</span></span><br><span class="line">        pNew-&gt;pNext=<span class="literal">NULL</span>;</span><br><span class="line">        pTail=pNew;<span class="comment">//pTail 将指向链表的最后一个节点(更新，向后移）</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pHead ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_list</span><span class="params">(pNode pHead)</span></span><br><span class="line">{</span><br><span class="line">      pNode p=pHead-&gt;pNext;<span class="comment">//定义了一个指针变量p，将链表的头指针给p</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span> !=p)<span class="comment">//p不为NULL时</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>,p-&gt;data);<span class="comment">//打印p的数据</span></span><br><span class="line">        p=p-&gt;pNext;<span class="comment">//p向后移</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_empty</span><span class="params">(pNode pHead)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==pHead-&gt;pNext)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    } <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回链表长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">length_list</span><span class="params">(pNode pHead)</span></span><br><span class="line">{</span><br><span class="line">    pNode p=pHead-&gt;pNext;<span class="comment">//定义了一个指针变量p，将头节点的地址给他</span></span><br><span class="line">    <span class="type">int</span> len =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span>!=p)<span class="comment">//如果这里面是空的</span></span><br><span class="line">    {</span><br><span class="line">        ++len;<span class="comment">//++</span></span><br><span class="line">        p=p-&gt;pNext;<span class="comment">//p指向下一个元素</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_list</span><span class="params">(pNode pHead)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i,j,t;</span><br><span class="line"><span class="type">int</span> len = length_list(pHead);</span><br><span class="line">pNode p,q;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>,p=pHead-&gt;pNext; i &lt;len<span class="number">-1</span> ; ++i,p=p-&gt;pNext) {<span class="comment">//p放的是第一个元素，</span></span><br><span class="line">        <span class="keyword">for</span> (j = i+<span class="number">1</span>,q=p-&gt;pNext; j &lt;len ; ++j,q=q-&gt;pNext) {<span class="comment">//q放的是p的后面的一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;data &gt; q-&gt;data)</span><br><span class="line">            {</span><br><span class="line">                t=p-&gt;data;</span><br><span class="line">                p-&gt;data=q-&gt;data;</span><br><span class="line">                q-&gt;data=t;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入--在第pos的前面插入一个新的节点val，pos从1开始</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">insert_list</span><span class="params">(pNode pHead,<span class="type">int</span> pos,<span class="type">int</span> val)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    pNode p=pHead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span>!=p &amp;&amp; i&lt;pos<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">        p=p-&gt;pNext;</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(i&gt;pos<span class="number">-1</span> || <span class="literal">NULL</span> ==p)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pNode pNew =(pNode) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (Node));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==pNew)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"动态内存分配失败\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    pNew -&gt;data=val;<span class="comment">//定义了一个新节点，将val先放进去</span></span><br><span class="line">    pNode q=p-&gt;pNext;<span class="comment">//p此时已经来到了pos-1的地方，也就是他的前面，</span></span><br><span class="line">    p-&gt;pNext=pNew;<span class="comment">//将他的地址给pNew</span></span><br><span class="line">    pNew-&gt;pNext=q;<span class="comment">//再将pNew的下一元素的地址给next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">delete_list</span><span class="params">(pNode pHead,<span class="type">int</span> pos,<span class="type">int</span> * pval)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    pNode p=pHead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span>!=p-&gt;pNext &amp;&amp; i&lt;pos<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">        p=p-&gt;pNext;</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(i&gt;pos<span class="number">-1</span> || <span class="literal">NULL</span> ==p-&gt;pNext)<span class="comment">//pos-1:eg:删除第3个必须要知道第二个</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pNode q=p-&gt;pNext;<span class="comment">//第pos个节点</span></span><br><span class="line">    *pval=q-&gt;data;<span class="comment">//将要删除的节点保存下来</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除p节点后面的节点</span></span><br><span class="line">    p-&gt;pNext=p-&gt;pNext-&gt;pNext;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    q=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="9-李阳的线性表"><a href="#9-李阳的线性表" class="headerlink" title="9.李阳的线性表"></a>9.李阳的线性表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 李阳 on 2024/11/11.--线性表</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXNUM 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> DateType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    DateType data[MAXNUM];<span class="comment">//定义了一个数组</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//当前长度</span></span><br><span class="line">}SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initList</span> <span class="params">(SqList *L)</span>{</span><br><span class="line">      L-&gt;length=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListInsert</span><span class="params">(SqList *L,<span class="type">int</span> i,DateType d)</span><span class="comment">//第i位置插入d</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L-&gt;length+<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//插入位置不合法</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length&gt;MAXNUM)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//表满了</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = L-&gt;length; k &gt;=i ; k--) <span class="comment">//依次向后移</span></span><br><span class="line">    {</span><br><span class="line">        L-&gt;data[k]=L-&gt;data[k<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">    L-&gt;data[i<span class="number">-1</span>]=d;<span class="comment">//当用户输入在3的位置插入，其实是在索引2的位置，如果想</span></span><br><span class="line">    L-&gt;length++;<span class="comment">//修改，可以将k&gt;=i改为k&gt;i即可</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//删</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListDelete</span><span class="params">(SqList *L,<span class="type">int</span> i,DateType *d)</span><span class="comment">//删除第i个元素并保存在d中</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L-&gt;length)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    *d=L-&gt;data[i<span class="number">-1</span>];<span class="comment">//保存被删除的元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;L-&gt;length;k++)<span class="comment">//找到被删除元素位置</span></span><br><span class="line">    {</span><br><span class="line">       L-&gt;data[k<span class="number">-1</span>]= L-&gt;data[k];<span class="comment">//向前移</span></span><br><span class="line">    }</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TraverseList</span><span class="params">(SqList L)</span><span class="comment">//这里传的L而不是*L是值传递，不需要对数据进行修改</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; ++i) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,L.data[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前元素个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListLength</span><span class="params">(SqList L)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> L.length;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改指定位置元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListUpdate</span><span class="params">(SqList *L,<span class="type">int</span> i,DateType e)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;L-&gt;length)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    L-&gt;data[i<span class="number">-1</span>]=e;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找索引为i的指定元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListGit</span><span class="params">(SqList L,<span class="type">int</span> i,DateType *x)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;L.length)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    *x=L.data[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找元素的位置（返回第一个匹配元素的位置）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SqList L, DateType e)</span> {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) {</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] == e) {</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>; <span class="comment">// 返回的是位置索引，从1开始计数</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 未找到</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    SqList  L;</span><br><span class="line">    initList(&amp;L);<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    ListInsert(&amp;L,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    ListInsert(&amp;L,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">    ListInsert(&amp;L,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">    ListInsert(&amp;L,<span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line">    ListInsert(&amp;L,<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">    ListInsert(&amp;L,<span class="number">6</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    TraverseList(L);</span><br><span class="line"></span><br><span class="line">    DateType d;</span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    ListDelete(&amp;L,<span class="number">2</span>,&amp;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"删除的元素是：%d "</span>,d);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    TraverseList(L);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="10-李阳的带头单链表"><a href="#10-李阳的带头单链表" class="headerlink" title="10.李阳的带头单链表"></a>10.李阳的带头单链表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 李阳 on 2024/11/12.</span></span><br><span class="line"><span class="comment">//带头单链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">next</span>;</span></span><br><span class="line">}Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">Node * <span class="title function_">initList</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">     Node * head=(Node *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span>(!head)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"动态内存分配失败!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">instertATEnd</span><span class="params">(Node * head ,<span class="type">int</span> date)</span></span><br><span class="line">{</span><br><span class="line">    Node * newNode=(Node *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span>(!newNode)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"创建失败"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    newNode -&gt;data=date;</span><br><span class="line">    newNode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    Node *temp=head;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    temp-&gt;next=newNode;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertATHead</span><span class="params">(Node * head,<span class="type">int</span>  data)</span></span><br><span class="line">{</span><br><span class="line">    Node * newNode=(Node *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span>(!newNode)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"创建失败"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    newNode-&gt;data=data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    newNode-&gt;next=head-&gt;next;<span class="comment">//尾巴结点为NULL</span></span><br><span class="line">    head-&gt;next=newNode;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node * head)</span></span><br><span class="line">{</span><br><span class="line">    Node * temp=head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (temp!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>,temp-&gt;data);</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除指定元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteNode</span><span class="params">(Node * head, <span class="type">int</span> data)</span></span><br><span class="line">{</span><br><span class="line">    Node * temp=head;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next!=<span class="literal">NULL</span>&amp;&amp;temp-&gt;next-&gt;data!=data)</span><br><span class="line">    {</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(temp-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        Node * current=temp-&gt;next;</span><br><span class="line">        temp-&gt;next=current-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(current);</span><br><span class="line">    } <span class="keyword">else</span>{</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"没找到哦"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回指定元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getElement</span><span class="params">(Node* head, <span class="type">int</span> index)</span> {</span><br><span class="line">    Node* temp = head;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span> &amp;&amp; count &lt; index) {</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 检查是否越界</span></span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"索引 %d 越界\n"</span>, index);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>); <span class="comment">// 或者返回一个特殊值表示错误，比如 INT_MIN 或 -1（需要包含 &lt;limits.h&gt;）</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> temp-&gt;data;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 获取链表的长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getListLength</span><span class="params">(Node* head)</span> {</span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    Node* current = head-&gt;next; <span class="comment">// 不计算头结点</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) {</span><br><span class="line">        length++;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放链表内存的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeList</span><span class="params">(Node* head)</span> {</span><br><span class="line">    Node* current = head-&gt;next; <span class="comment">// 从头结点的下一个节点开始释放</span></span><br><span class="line">    Node* nextNode;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) {</span><br><span class="line">        nextNode = current-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(current);</span><br><span class="line">        current = nextNode;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(head); <span class="comment">// 最后释放头结点</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//在指定位置添加数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertList</span><span class="params">(Node * head,<span class="type">int</span> i,<span class="type">int</span> data)</span></span><br><span class="line">{</span><br><span class="line">    Node * newNode =(Node *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (!newNode) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"内存分配失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    Node * temp=head;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特殊情况：在头部插入</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) {</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        newNode-&gt;data = data;</span><br><span class="line">        head = newNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next!=<span class="literal">NULL</span> &amp;&amp; index&lt;i<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">        index++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index != i - <span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// 位置超出链表长度</span></span><br><span class="line">        <span class="built_in">free</span>(newNode);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"插入位置超出链表长度\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    newNode-&gt;data=data;</span><br><span class="line">    newNode-&gt;next=temp-&gt;next;</span><br><span class="line">    temp-&gt;next=newNode;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据索引删除元素，并将值保存在data中</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteList</span><span class="params">(Node* head,<span class="type">int</span> i,<span class="type">int</span> *data)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="comment">// 链表为空</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"链表为空，无法删除\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    Node * temp=head;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next!=<span class="literal">NULL</span>&amp;&amp; index&lt;i<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">        index++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index!=i<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除有误"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">      Node * current=temp-&gt;next;</span><br><span class="line">    *data=current-&gt;data;</span><br><span class="line"></span><br><span class="line">    temp-&gt;next=current-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(current);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    Node * head=initList();</span><br><span class="line"></span><br><span class="line">    instertATEnd(head,<span class="number">1</span>);</span><br><span class="line">    instertATEnd(head,<span class="number">2</span>);</span><br><span class="line">    instertATEnd(head,<span class="number">3</span>);</span><br><span class="line">    instertATEnd(head,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"尾插法"</span>);</span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"----------------------"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"头插法\n"</span>);</span><br><span class="line"></span><br><span class="line">    insertATHead(head,<span class="number">5</span>);</span><br><span class="line">    insertATHead(head,<span class="number">4</span>);</span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除元素</span></span><br><span class="line">    deleteNode(head,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取链表长度</span></span><br><span class="line">    <span class="type">int</span> length = getListLength(head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Linked list length: %d\n"</span>, length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放链表内存</span></span><br><span class="line">    freeList(head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="三、栈"><a href="#三、栈" class="headerlink" title="三、栈"></a>三、栈</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>​ 一种可以实现“先进后出”的存储结构</p><p>​ 栈类似于一个箱子，先放进去的后拿出来，后进去的先拿出来</p><h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h3><p>静态栈</p><p>动态栈</p><h3 id="3-算法"><a href="#3-算法" class="headerlink" title="3.算法"></a>3.算法</h3><p>​ 出栈</p><p>​ 压栈</p><p>郝斌老师代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据结构之栈 o.O</span></span><br><span class="line"><span class="comment"> *  Created by 李阳 on 2024/10/9.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">pNext</span>;</span></span><br><span class="line">}Node,*pNode;</span><br><span class="line"><span class="comment">//栈</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    pNode pTop;<span class="comment">//元素顶部</span></span><br><span class="line">    pNode pBottom;<span class="comment">//元素底部</span></span><br><span class="line">}sTack,*pStack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(pStack)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pushStack</span><span class="params">(pStack pS,<span class="type">int</span> val)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(pStack)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">popStack</span><span class="params">(pStack,<span class="type">int</span> *)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(pStack pS)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">(pStack pS)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">   sTack S;<span class="comment">//sTack等价于 struct Stack--建立了一个名为S的成员变量，里面有两个元素，ptop和pbottom，里面暂时没有有效数据</span></span><br><span class="line"></span><br><span class="line">   initStack(&amp;S);<span class="comment">//初始化-造出空栈</span></span><br><span class="line">   pushStack(&amp;S,<span class="number">1</span>);<span class="comment">//压栈</span></span><br><span class="line">    pushStack(&amp;S,<span class="number">2</span>);<span class="comment">//压栈</span></span><br><span class="line">    pushStack(&amp;S,<span class="number">3</span>);<span class="comment">//压栈</span></span><br><span class="line">    pushStack(&amp;S,<span class="number">4</span>);<span class="comment">//压栈</span></span><br><span class="line"></span><br><span class="line">    traverse(&amp;S);<span class="comment">//输出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">    clear(&amp;S);</span><br><span class="line">   <span class="comment">// traverse(&amp;S);//输出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">if</span>( popStack(&amp;S,&amp;val))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"出栈成功，出栈的元素是：%d\n"</span>,val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"出栈失败\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   traverse(&amp;S);<span class="comment">//输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(pStack pS)</span></span><br><span class="line">{</span><br><span class="line">    pS-&gt;pTop=(pNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (Node));<span class="comment">//将top指向一个新造的空节点</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==pS-&gt;pTop)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"内存分配失败\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        pS-&gt;pBottom=pS-&gt;pTop;<span class="comment">//地址都指向空节点</span></span><br><span class="line">        pS-&gt;pTop-&gt;pNext=<span class="literal">NULL</span>;<span class="comment">//将新造的节点的指针域为空--因为他是最后一个元素的下一个元素，因此没有指针域</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//压栈--进栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pushStack</span><span class="params">(pStack pS,<span class="type">int</span> val)</span></span><br><span class="line">{</span><br><span class="line">    pNode pNew=(pNode) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (Node));</span><br><span class="line">    pNew-&gt;data=val;</span><br><span class="line">    pNew-&gt;pNext=pS-&gt;pTop;<span class="comment">//此时ptoop里面放的是初始化时的临时变量地址，这里调用，将新建的栈的指针域指向初始化的元素地址</span></span><br><span class="line">    pS-&gt;pTop=pNew;<span class="comment">//再将新的节点地址给top</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(pStack pS)</span></span><br><span class="line">{</span><br><span class="line">    pNode p=pS-&gt;pTop;<span class="comment">//定义个临时指针变量p，将头的值给p，</span></span><br><span class="line">    <span class="keyword">while</span> (p!=pS-&gt;pBottom)<span class="comment">//当p为底部元素时程序终止</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,p-&gt;data);</span><br><span class="line">        p=p-&gt;pNext;<span class="comment">//p指向p的下一元素地址</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(pStack pS)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(pS-&gt;pTop==pS-&gt;pBottom)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="type">bool</span> <span class="title function_">popStack</span><span class="params">(pStack pS,<span class="type">int</span> * pVal)</span><span class="comment">//把ps所指向的栈出栈一次，并将出栈元素存入pval新参所指向的变量中，成功返回true，否则false</span></span><br><span class="line">{</span><br><span class="line">     <span class="keyword">if</span>(empty(pS))</span><br><span class="line">     {</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     {</span><br><span class="line">        pNode r=pS-&gt;pTop;<span class="comment">//定义一个变量r，将顶元素给r</span></span><br><span class="line">        *pVal=r-&gt;data;</span><br><span class="line">        pS-&gt;pTop=r-&gt;pNext;<span class="comment">//再将top指向下一元素，这样r就被孤立了</span></span><br><span class="line">         <span class="built_in">free</span>(r);</span><br><span class="line">         r=<span class="literal">NULL</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">(pStack pS)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(empty(pS))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">    pNode p=pS-&gt;pTop;</span><br><span class="line">    pNode q=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (p!=pS-&gt;pBottom)</span><br><span class="line">        {</span><br><span class="line">            q=p-&gt;pNext;<span class="comment">//q指向第二个</span></span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            p=q;<span class="comment">//p又指向了下一个元素了</span></span><br><span class="line">        }</span><br><span class="line">        pS-&gt;pTop=pS-&gt;pBottom;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-应用"><a href="#4-应用" class="headerlink" title="4.应用"></a>4.应用</h3><p>函数调用</p><p>中断</p><p>表达式求值</p><p>内存分配</p><p>缓存处理</p><p>迷宫</p><h3 id="5-栈的表达式求值—后缀表达式（逆波兰表达式）"><a href="#5-栈的表达式求值—后缀表达式（逆波兰表达式）" class="headerlink" title="5.栈的表达式求值—后缀表达式（逆波兰表达式）"></a>5.栈的表达式求值—后缀表达式（逆波兰表达式）</h3><p><strong>1.例如：1+2*3</strong></p><p>​ 后缀表达式为 1 2 3 * +</p><p>​ 遇到一个运算符他会在前面两个数字间运算</p><ol><li>​ 2 *3</li><li>然后向后移到+</li><li>6+1</li></ol><p><strong>2、(a + b) * (c - (d / e)) + f</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a b + c d e / - * f +</span><br></pre></td></tr></table></figure><p><strong>3.、a * (b + c) - (d / e)</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a b c + * d e / -</span><br></pre></td></tr></table></figure><p><strong>4、a + b * (c - d / e) ^ f</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a b c d e / - f ^ * +</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 操作数和运算符</span><br><span class="line">操作数（如变量和常数）直接添加到输出列表中。</span><br><span class="line">运算符则需要根据优先级和括号来决定是否入栈、弹出或保持在栈中。</span><br><span class="line">2. 运算符优先级</span><br><span class="line">运算符的优先级从高到低一般为：</span><br><span class="line">* 和 / （乘法和除法）优先级高</span><br><span class="line">+ 和 - （加法和减法）优先级低</span><br><span class="line">在遇到相同优先级的运算符时，按照左结合性处理（从左到右）。</span><br><span class="line">3. 括号的处理</span><br><span class="line">遇到左括号 ( 时，直接入栈。</span><br><span class="line">遇到右括号 ) 时，弹出栈中的运算符到输出，直到遇到对应的左括号为止，左括号被丢弃。</span><br><span class="line">4. 栈的使用</span><br><span class="line">当一个运算符被处理时，检查栈顶运算符的优先级：</span><br><span class="line">如果栈顶运算符的优先级高于或等于当前运算符，则弹出栈顶运算符到输出。</span><br><span class="line">否则，将当前运算符入栈。</span><br><span class="line">5. 表达式结束时的处理</span><br><span class="line">当整个中序表达式处理完毕后，仍有运算符在栈中时，将它们全部弹出到输出。</span><br><span class="line">6. 后缀表达式的特征</span><br><span class="line">后缀表达式不需要括号，因为运算符的顺序和位置已经明确了运算的优先级和关联性。</span><br></pre></td></tr></table></figure><p><strong>当一个运算符被处理时，检查栈顶运算符的优先级：</strong><br><strong>如果栈顶运算符的优先级高于或等于当前运算符，则弹出栈顶运算符到输出。</strong><br><strong>否则，将当前运算符入栈。</strong></p><p>总结：</p><ul><li>栈底部的运算符永远是最低的</li><li>遇到括号先输出括号里的运算符，但不保留括号</li><li>当有刚入栈的运算符小于或等于当前栈中的运算符，那直接将栈出到小于此运算符的位置</li><li>来看个小例子吧：</li><li>1.当栈低为+或-时，来了个*或/时可以留着栈中，当此时又来了一个新运算符，假设为-，此时栈中的为+和<em>，那么将\</em>和+直接出栈，-再放入栈中</li><li>2.假设栈底运算符为<em>或者/，当入栈为+或-时，那么将\</em>或\出栈，将+或-压入栈底部</li><li>3.当栈低为+和<em>时，此时入栈了一个/那么将\</em>出栈，+留在栈中，/也压入栈中</li></ul><p>特别注意：* / ^的运算符是在两个运算的字母后的</p><p>例题：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">eg:1. (A + B) * (C - D) / E ^ F </span><br><span class="line"> 遇到括号左括号进栈A输出+进栈B输出，扫描到右括号+出栈，此时为AB+</span><br><span class="line"> *入栈，左括号入栈C输出-入栈D输出右括号出栈，此时变为AB+CD-,栈低为*</span><br><span class="line"> 扫描/入栈，因为/的优先级不大于*，因此*出栈，此时变为AB+CD-*，栈低为/</span><br><span class="line"> E输出，^进栈^的优先级不大于/要出栈，但是因为我们的运算符要相匹配，因此F输出在依次输出栈/^,这里E F ^ 表示 E 和 F 进行指数运算。/ 表示乘法结果除以 E F ^ 的结果</span><br><span class="line"> AB+CD-*EF/^</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">2. A + B * (C ^ D - E) ^ F / G</span><br><span class="line">   输出A,+进栈，输出B，此时为AB，+在栈里面</span><br><span class="line">   扫描左括号入栈，C输出，^进栈D输出，-进栈，因为我们的-优先级低于^,所以^的位置上移动，出栈，E输出扫描到又括号^出栈，-出栈，栈低为+和*，此时为ABCD^E-</span><br><span class="line">   ^入栈,因为^的优先级不大于*，所以*出栈，^入栈，栈里为+^，F输出,/进栈，因为FG是个组合，所以输出*FG/^  </span><br><span class="line">   结果是ABCD^E-*FG/^  </span><br></pre></td></tr></table></figure><h3 id="6-后缀表达式转中缀"><a href="#6-后缀表达式转中缀" class="headerlink" title="6.后缀表达式转中缀"></a>6.后缀表达式转中缀</h3><p>我们学完了中缀转后缀下面来试一试后缀表达式转中缀吧！</p><p>我们先来看题吧</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AB+CD-*EF/^</span><br><span class="line"></span><br><span class="line">首先我们的ab进栈，这时我们扫描到运算符+，这时候就变成a+b，然后入栈（遇到运算符要与他的前两位进行计算）</span><br><span class="line">cd进栈，扫描到运算符-，就变成c-d然后入栈，此时栈里存放的是a+b 和c-d </span><br><span class="line">然后扫描到运算符* ，就变成 a+b * c-d ，因为我们左右两边是个整体，所以要加括号（a+b） * （c-d），然后再入栈</span><br><span class="line">EF进栈，扫描到/，就变成E/F,此时栈里存放的是（a+b） * （c-d） 和 （E/F）</span><br><span class="line">扫描到^ 就变成 （a+b） * （c-d） ^ （E/F）</span><br><span class="line">本题结束(●'◡'●)</span><br></pre></td></tr></table></figure><p>由此我们可以反推出 ：</p><p>字母总是两两存在的因此在中序转后缀需要考虑组合</p><p>后缀转中缀的是运算符之前的两位数字/字母进行计算</p><h3 id="7-李阳的栈"><a href="#7-李阳的栈" class="headerlink" title="7.李阳的栈"></a>7.李阳的栈</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 李阳 on 2024/11/13.--链式栈</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">next</span>;</span></span><br><span class="line">}Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义栈结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkedStack</span>{</span></span><br><span class="line">    Node * top;<span class="comment">//栈顶指针，初始化为NULL表示空栈</span></span><br><span class="line">} LinkedStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">LinkedStack * <span class="title function_">initStack</span><span class="params">()</span>{</span><br><span class="line">    LinkedStack * <span class="built_in">stack</span>=(LinkedStack *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedStack));</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top=<span class="literal">NULL</span>; <span class="comment">// 初始化栈顶指针为NULL</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(LinkedStack * <span class="built_in">stack</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top==<span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param stack</span></span><br><span class="line"><span class="comment"> * @param data</span></span><br><span class="line"><span class="comment"> * 解析：让我来为你解析吧！</span></span><br><span class="line"><span class="comment"> * 首先我们定义了一个链表，然后一个空栈，里面有一个top指向NULL</span></span><br><span class="line"><span class="comment"> * 然后我们传入一个元素假设为1</span></span><br><span class="line"><span class="comment"> * 然后newNode-&gt;next=stack-&gt;top;// 新节点的next指向当前栈顶</span></span><br><span class="line"><span class="comment">    stack-&gt;top=newNode;</span></span><br><span class="line"><span class="comment"> *这俩是核心代码 我们直接说这个</span></span><br><span class="line"><span class="comment"> * stack-&gt;top上面初始化为NULL</span></span><br><span class="line"><span class="comment"> * 所以newNode-&gt;next里面就是NULL</span></span><br><span class="line"><span class="comment"> * 然后newNode为指针类型的， stack-&gt;top=newNode;就是将top指向了他的指针</span></span><br><span class="line"><span class="comment"> * 我理解的是双胞胎，栈的top的指针就指向了NewNode</span></span><br><span class="line"><span class="comment"> * 假设我们现在又传入了一个2</span></span><br><span class="line"><span class="comment"> * newNode-&gt;next=stack-&gt;top</span></span><br><span class="line"><span class="comment"> * 2的next里面放的是1的地址</span></span><br><span class="line"><span class="comment"> * stack-&gt;top=newNode;</span></span><br><span class="line"><span class="comment"> * 我们又将2的地址给了top，类似top再向上移动</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(LinkedStack* <span class="built_in">stack</span>,<span class="type">int</span> data)</span>{</span><br><span class="line">    Node * newNode=(Node *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;data=data;</span><br><span class="line"></span><br><span class="line">    newNode-&gt;next=<span class="built_in">stack</span>-&gt;top;<span class="comment">// 新节点的next指向当前栈顶</span></span><br><span class="line">    <span class="built_in">stack</span>-&gt;top=newNode;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param stack</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> * 我又来啦，现在由李阳为你解析链栈的出栈</span></span><br><span class="line"><span class="comment"> * 我们这个是有返回值的，首先传入一个栈是毋庸置疑的</span></span><br><span class="line"><span class="comment"> * 还需要一个小小的判断-如果栈里面没有元素呢</span></span><br><span class="line"><span class="comment"> * -------核心代码----</span></span><br><span class="line"><span class="comment"> * 首先我们定义了一个临时变量temp用于存放栈顶，</span></span><br><span class="line"><span class="comment"> * 这里top里面放的是最后一个元素的地址</span></span><br><span class="line"><span class="comment"> * 根据地址可以找到元素没问题吧</span></span><br><span class="line"><span class="comment"> * 然后我们再将栈顶的元素的下一个地址重新给top</span></span><br><span class="line"><span class="comment"> * 我们之前top里面放的是栈顶的地址，现在我们变成传入栈顶</span></span><br><span class="line"><span class="comment"> * 的下一元素的地址，也就是将top向下移动</span></span><br><span class="line"><span class="comment"> * o.O</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(LinkedStack * <span class="built_in">stack</span>)</span>{</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(<span class="built_in">stack</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈是空的"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    Node * temp=<span class="built_in">stack</span>-&gt;top;</span><br><span class="line">    <span class="type">int</span>  popData=temp-&gt;data;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top=temp-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> popData;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(LinkedStack *<span class="built_in">stack</span>)</span></span><br><span class="line">{</span><br><span class="line">    Node *temp=<span class="built_in">stack</span>-&gt;top;</span><br><span class="line">    <span class="keyword">while</span> (temp!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>,temp-&gt;data);</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"NULL\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出栈顶元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StackTop</span><span class="params">(LinkedStack*<span class="built_in">stack</span>)</span></span><br><span class="line">{</span><br><span class="line">    Node * temp=<span class="built_in">stack</span>-&gt;top;</span><br><span class="line">    <span class="keyword">if</span>(temp==<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈为空"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> topdata=temp-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> topdata;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeStack</span><span class="params">(LinkedStack * <span class="built_in">stack</span>)</span></span><br><span class="line">{</span><br><span class="line">      Node * temp=<span class="built_in">stack</span>-&gt;top;</span><br><span class="line">      Node *nextNode;<span class="comment">//下一个元素</span></span><br><span class="line">    <span class="keyword">while</span> (temp!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        nextNode=temp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        temp=nextNode;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//来检验一下吧^_^</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    LinkedStack *<span class="built_in">stack</span>=initStack();<span class="comment">//初始化</span></span><br><span class="line">    push(<span class="built_in">stack</span>,<span class="number">1</span>);</span><br><span class="line">    push(<span class="built_in">stack</span>,<span class="number">2</span>);</span><br><span class="line">    push(<span class="built_in">stack</span>,<span class="number">3</span>);</span><br><span class="line">    push(<span class="built_in">stack</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    printStack(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> a=  StackTop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"栈顶元素是：%d "</span>,a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="type">int</span> b= pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d出栈了"</span>,a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    printStack(<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line">    freeStack(<span class="built_in">stack</span>);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、队列"><a href="#四、队列" class="headerlink" title="四、队列"></a>四、队列</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p>​ 一种可以实现“先进先出”的存储结构—排队买票进站</p><h3 id="2-分类-1"><a href="#2-分类-1" class="headerlink" title="2.分类"></a>2.分类</h3><p>​ 链式队列（链表）</p><p>​ 静态队列（数组）</p><p>​ 静态队列通常都必须是循环队列</p><p>​ <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793bca624b.png" alt></p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>郝斌老师代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Created by 李阳 on 2024/10/14.</span></span><br><span class="line"><span class="comment"> * 数据结构之静态循环队列o.O</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> *pBase;</span><br><span class="line">    <span class="type">int</span> front;<span class="comment">//首</span></span><br><span class="line">    <span class="type">int</span> rear;<span class="comment">//尾</span></span><br><span class="line">} QUEUE;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(QUEUE *)</span>;<span class="comment">//改变实参的值所以要加*</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">en_queue</span><span class="params">(QUEUE *,<span class="type">int</span>)</span>;<span class="comment">//入队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_queue</span><span class="params">(QUEUE *)</span>;<span class="comment">//遍历</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">full_queue</span><span class="params">(QUEUE *)</span>;<span class="comment">//判断是否满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">out_queue</span><span class="params">(QUEUE *,<span class="type">int</span> *pVal)</span>;<span class="comment">//出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">emput_queue</span><span class="params">(QUEUE *)</span>;<span class="comment">//判断是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    QUEUE Q;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    init(&amp;Q);<span class="comment">//调用初始化函数</span></span><br><span class="line">    en_queue(&amp;Q,<span class="number">1</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">2</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">3</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">4</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">5</span>);</span><br><span class="line">    traverse_queue(&amp;Q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (out_queue(&amp;Q, &amp;val)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"出队成功: %d\n"</span>, val); <span class="comment">// 修正输出格式</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"出队失败\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    traverse_queue(&amp;Q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(QUEUE *pQ)</span></span><br><span class="line">{</span><br><span class="line">    pQ-&gt;pBase=(<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (<span class="type">int</span>)*<span class="number">6</span>);<span class="comment">//定义了6个数据的数组</span></span><br><span class="line">    pQ-&gt;front=pQ-&gt;rear=<span class="number">0</span>;<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">en_queue</span><span class="params">(QUEUE *pQ,<span class="type">int</span> val)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(full_queue(pQ))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列满啦"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    } <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        pQ-&gt;pBase[pQ-&gt;rear]=val;<span class="comment">//将值放入尾部，并且尾部要+1</span></span><br><span class="line">        pQ-&gt;rear=(pQ-&gt;rear+<span class="number">1</span>)%<span class="number">6</span>;<span class="comment">//尾部+1--因为是循环队列，当他满的时候会又从0开始</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">full_queue</span><span class="params">(QUEUE *pQ)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>((pQ-&gt;rear+<span class="number">1</span>)%<span class="number">6</span>==pQ-&gt;front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_queue</span><span class="params">(QUEUE *pQ)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i=pQ-&gt;front;</span><br><span class="line">    <span class="keyword">while</span> ((i!=pQ-&gt;rear))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,pQ-&gt;pBase[i]);</span><br><span class="line">        i=(i+<span class="number">1</span>)%<span class="number">6</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">emput_queue</span><span class="params">(QUEUE * pQ)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(pQ-&gt;front==pQ-&gt;rear)</span><br><span class="line">    {</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    } <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">out_queue</span><span class="params">(QUEUE * pQ,<span class="type">int</span> *pVal)</span><span class="comment">//因为要带回来值，所以要*</span></span><br><span class="line">{</span><br><span class="line">   <span class="keyword">if</span>(emput_queue(pQ))</span><br><span class="line">   {</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"表是空的"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   } <span class="keyword">else</span></span><br><span class="line">   {</span><br><span class="line">     *pVal=pQ-&gt;pBase[pQ-&gt;front];</span><br><span class="line">     pQ-&gt;front=(pQ-&gt;front+<span class="number">1</span>)%<span class="number">6</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="4-队列的操作"><a href="#4-队列的操作" class="headerlink" title="4.队列的操作"></a>4.队列的操作</h3><p>所有和时间有关的操作</p><h3 id="5-李阳的队列"><a href="#5-李阳的队列" class="headerlink" title="5.李阳的队列"></a>5.李阳的队列</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 李阳 on 2024/11/13.--链式队列</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> {</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">} Node;</span><br><span class="line"><span class="comment">// 定义队列结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkedQueue</span> {</span></span><br><span class="line">    Node* front;  <span class="comment">// 队头指针</span></span><br><span class="line">    Node* rear;   <span class="comment">// 队尾指针</span></span><br><span class="line">} LinkedQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">LinkedQueue * <span class="title function_">initQueue</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    LinkedQueue * <span class="built_in">queue</span>=(LinkedQueue*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedQueue));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front=<span class="built_in">queue</span>-&gt;rear=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="comment">//返回0为空，1不为空所以为int类型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(LinkedQueue* <span class="built_in">queue</span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;front == <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span> <span class="params">(LinkedQueue * <span class="built_in">queue</span>,<span class="type">int</span> data)</span></span><br><span class="line">{</span><br><span class="line">    Node *newNode=(Node* ) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;data=data;</span><br><span class="line">    newNode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isEmpty(<span class="built_in">queue</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front=<span class="built_in">queue</span>-&gt;rear=newNode;</span><br><span class="line">    } <span class="keyword">else</span>{</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear-&gt;next=newNode;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear=newNode;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dequeue</span><span class="params">(LinkedQueue * <span class="built_in">queue</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(<span class="built_in">queue</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列是空的"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node *temp=<span class="built_in">queue</span>-&gt;front;<span class="comment">//先进先出</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">deque</span>=temp-&gt;data;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front=<span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>-&gt;front==<span class="literal">NULL</span>){</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear=<span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">deque</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(LinkedQueue*<span class="built_in">queue</span>)</span></span><br><span class="line">{</span><br><span class="line">    Node *temp=<span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    <span class="keyword">while</span> (temp!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,temp-&gt;data);</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"NUll\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeQueue</span><span class="params">(LinkedQueue*<span class="built_in">queue</span>)</span></span><br><span class="line">{</span><br><span class="line">    Node * temp=<span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    Node * nextNode;</span><br><span class="line">    <span class="keyword">while</span> (temp!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        nextNode=temp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        temp=nextNode;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//取队头元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getFront</span><span class="params">(LinkedQueue*<span class="built_in">queue</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(<span class="built_in">queue</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列为空"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    } <span class="keyword">else</span>{</span><br><span class="line">        <span class="type">int</span> temp=<span class="built_in">queue</span>-&gt;front-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    LinkedQueue* <span class="built_in">queue</span> = initQueue();</span><br><span class="line"></span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">10</span>);</span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">20</span>);</span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    printQueue(<span class="built_in">queue</span>);  <span class="comment">// 打印队列内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="type">int</span> temp = getFront(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"队头%d \n"</span>,temp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Dequeued: %d\n"</span>, dequeue(<span class="built_in">queue</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Dequeued: %d\n"</span>, dequeue(<span class="built_in">queue</span>));</span><br><span class="line"></span><br><span class="line">    printQueue(<span class="built_in">queue</span>);  <span class="comment">// 再次打印队列内容</span></span><br><span class="line"></span><br><span class="line">    freeQueue(<span class="built_in">queue</span>);  <span class="comment">// 释放队列内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="6-李阳的循环队列"><a href="#6-李阳的循环队列" class="headerlink" title="6.李阳的循环队列"></a>6.李阳的循环队列</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 李阳 on 2024/11/16.-循环队列</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义循环队列结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">int</span> *data;  <span class="comment">// 指向队列数组的指针</span></span><br><span class="line">    <span class="type">int</span> max_size;  <span class="comment">// 队列的最大容量</span></span><br><span class="line">    <span class="type">int</span> front;  <span class="comment">// 队头索引</span></span><br><span class="line">    <span class="type">int</span> rear;  <span class="comment">// 队尾索引（指向下一个入队位置）</span></span><br><span class="line">    <span class="type">int</span> size;  <span class="comment">// 队列中当前元素的数量</span></span><br><span class="line">} CircularQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化循环队列</span></span><br><span class="line">CircularQueue* <span class="title function_">create_circular_queue</span><span class="params">(<span class="type">int</span> max_size)</span> {</span><br><span class="line">    CircularQueue *<span class="built_in">queue</span> = (CircularQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CircularQueue));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">queue</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"内存分配失败\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">queue</span>-&gt;max_size = max_size;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(max_size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">queue</span>-&gt;data) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"内存分配失败\n"</span>);</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_empty</span><span class="params">(CircularQueue *<span class="built_in">queue</span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查队列是否已满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_full</span><span class="params">(CircularQueue *<span class="built_in">queue</span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size == <span class="built_in">queue</span>-&gt;max_size;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">enqueue</span><span class="params">(CircularQueue *<span class="built_in">queue</span>, <span class="type">int</span> value)</span> {</span><br><span class="line">    <span class="keyword">if</span> (is_full(<span class="built_in">queue</span>)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列已满，无法入队\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (is_empty(<span class="built_in">queue</span>)) {</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = (<span class="built_in">queue</span>-&gt;rear + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;max_size;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;data[<span class="built_in">queue</span>-&gt;rear] = value;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">dequeue</span><span class="params">(CircularQueue *<span class="built_in">queue</span>, <span class="type">int</span> *value)</span> {</span><br><span class="line">    <span class="keyword">if</span> (is_empty(<span class="built_in">queue</span>)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列为空，无法出队\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    *value = <span class="built_in">queue</span>-&gt;data[<span class="built_in">queue</span>-&gt;front];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;front == <span class="built_in">queue</span>-&gt;rear) {</span><br><span class="line">        <span class="comment">// 队列中只有一个元素，出队后队列为空</span></span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear = <span class="number">-1</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = (<span class="built_in">queue</span>-&gt;front + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;max_size;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印队列中的所有元素（用于调试）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_queue</span><span class="params">(CircularQueue *<span class="built_in">queue</span>)</span> {</span><br><span class="line">    <span class="keyword">if</span> (is_empty(<span class="built_in">queue</span>)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列为空\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> count = <span class="number">0</span>; count &lt; <span class="built_in">queue</span>-&gt;size; count++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, <span class="built_in">queue</span>-&gt;data[i]);</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;max_size;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放队列占用的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_circular_queue</span><span class="params">(CircularQueue *<span class="built_in">queue</span>)</span> {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;data) {</span><br><span class="line">            <span class="built_in">free</span>(<span class="built_in">queue</span>-&gt;data);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    CircularQueue *<span class="built_in">queue</span> = create_circular_queue(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">10</span>);</span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">20</span>);</span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">30</span>);</span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    print_queue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    dequeue(<span class="built_in">queue</span>, &amp;value);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"出队元素: %d\n"</span>, value);</span><br><span class="line"></span><br><span class="line">    print_queue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">50</span>);</span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">60</span>);  <span class="comment">// 这将导致队列满</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试再次入队会失败，因为队列已满</span></span><br><span class="line">    <span class="comment">// enqueue(queue, 70);</span></span><br><span class="line"></span><br><span class="line">    print_queue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    free_circular_queue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="五、递归"><a href="#五、递归" class="headerlink" title="五、递归"></a>五、递归</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793c331bfe.png" alt></p><h3 id="1-简单应用—阶层"><a href="#1-简单应用—阶层" class="headerlink" title="1.简单应用—阶层"></a>1.简单应用—阶层</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数据结构之递归</span></span><br><span class="line"><span class="comment"> * Created by 李阳 on 2024/10/15.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//demo1--求阶层</span></span><br><span class="line"><span class="comment">/* for循环版</span></span><br><span class="line"><span class="comment">int jiec(int a)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">    int b=1;</span></span><br><span class="line"><span class="comment">    int i;</span></span><br><span class="line"><span class="comment">    for ( i=1; i &lt;=a; ++i)</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        b=b*i;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    return b;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int main()</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">    int b=5;</span></span><br><span class="line"><span class="comment">    int a= jiec(b);</span></span><br><span class="line"><span class="comment">    printf("%d 的阶层是 %d",b,a);</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归版</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">f</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>==n)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> f(n<span class="number">-1</span>)*n;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">   <span class="type">long</span> a,b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要求的阶层"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">    b= f(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld 的阶层是 %ld"</span>,a,b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归实现1+2+...</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> sum(n<span class="number">-1</span>)+n;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="2-定义，要求，意义"><a href="#2-定义，要求，意义" class="headerlink" title="2.定义，要求，意义"></a>2.定义，要求，意义</h3><h4 id="①定义："><a href="#①定义：" class="headerlink" title="①定义："></a>①<strong>定义：</strong></h4><p>一个函数间接或直接调用自己</p><h4 id="②递归需要满足的三个条件"><a href="#②递归需要满足的三个条件" class="headerlink" title="②递归需要满足的三个条件"></a>②<strong>递归需要满足的三个条件</strong></h4><ol><li>递归必须要有一个明确的终止条件</li><li>该函数所处理的数据规模必须在递减</li><li>这个转化必须是可解的</li></ol><h4 id="③意义"><a href="#③意义" class="headerlink" title="③意义"></a>③<strong>意义</strong></h4><p>优点：易于理解</p><p>缺点：速度慢，存储空间大</p><h4 id="④循环："><a href="#④循环：" class="headerlink" title="④循环："></a>④<strong>循环</strong>：</h4><p>不易理解，速度快，存储空间小</p><h2 id="六、串、数组和广义表"><a href="#六、串、数组和广义表" class="headerlink" title="六、串、数组和广义表"></a>六、串、数组和广义表</h2><h3 id="一、串（string）"><a href="#一、串（string）" class="headerlink" title="一、串（string）"></a>一、串（string）</h3><p>0个或多个任意字符组成的有限序列</p><h4 id="1-子串的定义"><a href="#1-子串的定义" class="headerlink" title="1.子串的定义"></a>1.子串的定义</h4><p>一个串中任意个连续字符组成的子序列（含空串）称为该串的子串</p><p>例如：“abcd”的子串有</p><p>“ ”，“a”,”ab”,”abc”,”abcd”</p><p><strong>真子串</strong>：是指不包含自身的所有子串</p><p><strong>主串</strong>:包含子串的串相应的称为主串</p><p><strong>字符位置</strong>:字符在序列中的序号为该字符串中的位置</p><p><strong>子串位置</strong>：子串第一个字符在主串中的位置</p><p><strong>空格串：</strong>由一个或多个空格组成的串，与空串不同</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793b0437c6.png" alt></p><p><strong>串相等:</strong>当且仅当两个串的长度相等并且各个对应立置上的字符都相同时，这两个串才是相等的。</p><h4 id="2-串的类型定义、存储结构及运算"><a href="#2-串的类型定义、存储结构及运算" class="headerlink" title="2.串的类型定义、存储结构及运算"></a>2.串的类型定义、存储结构及运算</h4><p>顺序存储结构-顺序串</p><p>链式存储结构-链式串</p><h4 id="3-串的表示"><a href="#3-串的表示" class="headerlink" title="3.串的表示"></a>3.串的表示</h4><h5 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串的顺序存储结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN+<span class="number">1</span>];<span class="comment">//存储串的一维数组1-255</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//串的当前长度</span></span><br><span class="line">}SString;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="链式存储-1"><a href="#链式存储-1" class="headerlink" title="链式存储"></a>链式存储</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串的链式存储结构--块链结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE 80</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> {</span></span><br><span class="line">    <span class="type">char</span> ch[CHUNKSIZE]; <span class="comment">// 存储字符块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> *<span class="title">next</span>;</span>  <span class="comment">// 指向下一个块的指针</span></span><br><span class="line">} Chunk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    Chunk *head;  <span class="comment">// 串的首指针</span></span><br><span class="line">    Chunk *tail;  <span class="comment">// 串的尾指针</span></span><br><span class="line">    <span class="type">int</span> curlen;   <span class="comment">// 串的当前长度</span></span><br><span class="line">} LString;</span><br></pre></td></tr></table></figure><h4 id="4-串的模式匹配"><a href="#4-串的模式匹配" class="headerlink" title="4.串的模式匹配"></a>4.串的模式匹配</h4><h5 id="1-BF算法（穷举法）"><a href="#1-BF算法（穷举法）" class="headerlink" title="1.BF算法（穷举法）"></a>1.BF算法（穷举法）</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">index_BF</span><span class="params">(SString S,SString T)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=S.length&amp;&amp;j&lt;=T.length)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i]==T.ch[j])</span><br><span class="line">        {</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        } <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            i=(i-j)+<span class="number">2</span>;j=<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">  <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">      <span class="keyword">return</span> i-T.length;<span class="comment">//匹配成功</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793d4c791c.png" alt></p><h5 id="2-※※※-KMP算法"><a href="#2-※※※-KMP算法" class="headerlink" title="2.※※※ KMP算法"></a>2.<strong>※※※ KMP</strong>算法</h5><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793d5eed9f.png" alt></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算模式串 T 的 next 数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(SString T, <span class="type">int</span> next[])</span> {</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;  <span class="comment">// T 的当前位置</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;  <span class="comment">// 前缀的长度</span></span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// next[0] 通常设为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; T.length) {</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T.ch[i] == T.ch[j]) {</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j; <span class="comment">// 注意：next[i] 是 i 位置的前缀长度</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            j = next[j - <span class="number">1</span>]; <span class="comment">// 使用 next 数组回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP 算法实现，返回模式串 T 在主串 S 中首次出现的位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(SString S, SString T, <span class="type">int</span> next[])</span> {</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;  <span class="comment">// S 的当前位置</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;  <span class="comment">// T 的当前位置</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length) {</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || S.ch[i] == T.ch[j]) { <span class="comment">// j = -1 表示需要跳过</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            j = next[j]; <span class="comment">// 使用 next 数组回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (j == T.length) <span class="keyword">return</span> i - T.length; <span class="comment">// 匹配成功，返回匹配位置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 匹配失败，返回 -1</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h5 id="3-KMP算法改进"><a href="#3-KMP算法改进" class="headerlink" title="3.KMP算法改进"></a>3.KMP算法改进</h5><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793dc31080.png" alt></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_nextval</span><span class="params">(SString T, <span class="type">int</span> nextval[])</span> {</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;  <span class="comment">// T 的当前位置</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;  <span class="comment">// 前缀的长度</span></span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// next[0] 通常设为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; T.length) {</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T.ch[i] == T.ch[j]) {</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span>(T.ch[i]!=T.ch[j])</span><br><span class="line">                nextval[i]=j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextval[i]=nextval[j];</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            j = nextval[j]; <span class="comment">// 使用 next 数组回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="二、数组"><a href="#二、数组" class="headerlink" title="二、数组"></a>二、数组</h3><h4 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h4><p>按照一点格式排列起来的具有相同的数据元素集合</p><p><strong>一维数组</strong>：若线性表中的元素为非结构的简单元素，则称为一维数组（线性结构，定长的线性表）</p><p><strong>二维数组</strong>：若一维数组中的元素又是一维数组结构，则称为二维数组</p><p><strong>二维数组逻辑结构：</strong></p><ul><li>非线性结构： 每一个元素既在一个行表中，又在一个列表中</li><li>线性结构：该线性表的每一个元素也是一个定长的线性表</li></ul><p><strong>数组特点</strong>：结构固定—定义后，维度和为界不再改变</p><p><strong>结论</strong>:</p><ul><li>线性表结构是数组的一个特例</li><li>而数组结构又是线性表结构的扩展</li></ul><p><strong>基本操作</strong>：除了结构的初始化和销毁之外，只有取元素和修改元素值的操作</p><p>一般采用顺序结构来表示数组</p><h4 id="2-存储位置"><a href="#2-存储位置" class="headerlink" title="2.存储位置"></a>2.存储位置</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793ddb69e3.png" alt></p><p>数组元素a[i] [j] 的存储位置是 LOC(i,j)=LOC(0,0)+n <em>i+j</em> L(L是存储每个元素所需要L个存储单元)</p><h4 id="3-压缩存储"><a href="#3-压缩存储" class="headerlink" title="3.压缩存储"></a>3.压缩存储</h4><ol><li>什么是压缩存储?<br>若多个数据元素的值都相同，则只分配一个元素值的存储空间，且零元素不占存储空间</li><li>什么样的矩阵能够压缩?<br>一些特殊矩阵，如:对称矩阵，对角矩阵，三角矩阵，稀疏矩阵等。</li><li>什么叫稀疏矩阵?<br>矩阵中非零元素的个数较少（一般小于5%)</li></ol><h5 id="1-对称矩阵"><a href="#1-对称矩阵" class="headerlink" title="1.对称矩阵"></a><strong>1.对称矩阵</strong></h5><ol><li><h6 id="特点"><a href="#特点" class="headerlink" title="[特点]"></a>[特点]</h6><p>沿着对角线对称</p><p>在nxn的矩阵a中，满足如下性质: aij=aji (1 ≤i, j &lt;n)</p></li><li><h6 id="存储方法"><a href="#存储方法" class="headerlink" title="[存储方法]"></a>[存储方法]</h6><p>只存储下(或者上)三角(包括主对角线)的数据元素。共占用n(n+1)/2个元素空间。</p></li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793deea555.png" alt></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793e02b547.png" alt></p><h5 id="2-三角矩阵"><a href="#2-三角矩阵" class="headerlink" title="2.三角矩阵"></a><strong>2.三角矩阵</strong></h5><ol><li><h6 id="特点-1"><a href="#特点-1" class="headerlink" title="[特点]"></a>[特点]</h6><p>对角线以下(或者以上)的数据元素(不包括对角线)全部为常数co</p></li><li><h6 id="存储方法-1"><a href="#存储方法-1" class="headerlink" title="[存储方法]"></a>[存储方法]</h6><p>重复元素c共享一个元素存储空间，共占用n(n+1)/2+1个元素空间: sa[1.. n(n+1)/2+1]</p></li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793e262d84.png" alt></p><h5 id="3-对角矩阵（带状矩阵）"><a href="#3-对角矩阵（带状矩阵）" class="headerlink" title="3.对角矩阵（带状矩阵）"></a><strong>3.对角矩阵（带状矩阵）</strong></h5><p>[特点]在nxn的方阵中，所有非零元素都集中在以主对角线为中心的带状区域中，区域外的值全为0，则称为对角矩阵。常见的有三对角矩阵、五对角矩阵、七对角矩阵等。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793d3a20dc.png" alt></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793dfa0c39.png" alt></p><h5 id="4-稀疏矩阵"><a href="#4-稀疏矩阵" class="headerlink" title="4.稀疏矩阵"></a><strong>4.稀疏矩阵</strong></h5><p>稀疏矩阵:设在mxn的矩阵中有t个非零元素。<br>令ɸ= t/(mxn)<br>当ɸ≤0.05时称为稀疏矩阵。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793e169ac6.png" alt></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793e30dc88.png" alt></p><p>三元组顺序表又称有序的双下标法。</p><ol><li><p>三元组顺序表的优点:非零元在表中按行序有序存储，因此便于进</p><p>行依行顺序处理的矩阵运算。</p></li><li><p>三元组顺序表的缺点:不能随机存取。若按行号存取某一行中的非</p><p>零元，则需从头开始进行查找。</p></li></ol><h6 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a><strong>十字链表</strong></h6><p>优点:它能够灵活地插入因运算而产生的新的非零元素，删除因运算而产生的新的零元素，实现矩阵的各种运算<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793e472a54.png" alt></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793e5c8f27.png" alt></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793e73a771.png" alt></p><h3 id="三-广义表"><a href="#三-广义表" class="headerlink" title="三.广义表"></a>三.广义表</h3><h4 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h4><p>广义表 （又称列表Lists）是n≧0个元素 a0,a1…..an-1的有限序列，其中每一个ai或者是原子，或者是一个广义表</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793e9b3087.png" alt></p><ul><li><p>广义表通常记作:Ls=(a1, a2,..，an)</p><p>其中:LS为表名，n为表的长度，每一个ai为表的元素</p></li><li><p>习惯上，一般用<strong>大写字母</strong>表示<strong>广义表</strong>，<strong>小写字母</strong>表示<strong>原子。</strong></p></li><li><p><strong>表头：</strong>若LS非空(n≥1)，则其第一个元素a1就是表头。<br>记作head(LS) = a1。<strong>注</strong>:表头可以是原子，也可以是子表。</p></li><li><p><strong>表尾</strong>：除<strong>表头</strong>之外的<strong>其它元素</strong>组成的<strong>表</strong>。</p><p>​ 记作tail(LS） = (a2, …. an)。</p><p>​ 注:表尾不是最后一个元素，而是一个<strong>子表。</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793de7e485.png" alt></p></li></ul><h4 id="2-性质"><a href="#2-性质" class="headerlink" title="2.性质"></a>2.性质</h4><ul><li><p>(1)广义表中的数据元素有相对<strong>次序;一个直接前驱和一个直接后驱</strong></p></li><li><p>(2)广义表的<strong>长度</strong>定义为最外层所包含元素的个数;</p><p>​ 如: C=(a (b, q))是长度为2的广义表。</p></li><li><p>(3)广义表的<strong>深度</strong>定义为该广义表<strong>展开后所含括号的重数</strong>;</p><p>​ A=(b ,c)的深度为1,B=(A,d)的深度为2，C=(f, B,h)的深度为3。</p><p>​ <strong>注意</strong>:“原子”的深度为0;“空表”的深度为1。</p></li><li><p>广义表可以为其他广义表<strong>共享</strong>，如：广义表B就共享了广义表A。在b中不必列出A的值，而是通过名称来引用，B=(A)</p></li><li><p>广义表可以是一个递归的表。如：F=（a,F=(a,(a,(a,…)))</p></li></ul><p>​ 注意：递归表的深度是无穷值，长度是有限值，这里长度是2</p><ul><li>广义表是多层次结构，广义表的元素可以是单元素，也可以是子表，而子表的元素还可以是子表，….。<br>可以用图形象地表示。<br>例:D=(E，F）其中:E=(a, (b,c)）F=(d,(e))</li></ul><h4 id="3-广义表和线性表的区别"><a href="#3-广义表和线性表的区别" class="headerlink" title="3.广义表和线性表的区别"></a>3.广义表和线性表的区别</h4><ol><li>广义表可以看成是线性表的推广，线性表是广义表的特例。</li><li>广义表的结构相当灵活，在某种前提下，它可以兼容线性表、数组、树和有向图等各种常用的数据结构。</li><li>当二维数组的每行(或每列)作为子表处理时，二维数组即为一个广义表。</li><li>另外，树和有向图也可以用广义表来表示。</li><li>由于广义表不仅集中了线性表、数组、树和有向图等常见数据结构的特点，而且可有效地利用存储空间，因此在计算机的许多应用领域都有成功使用广义表的实例。</li></ol><h4 id="4-广义表的基本运算"><a href="#4-广义表的基本运算" class="headerlink" title="4.广义表的基本运算"></a>4.广义表的基本运算</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793e83be46.png" alt></p><p>案例分析</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793eadac15.png" alt></p><p>代码实现</p><h2 id="七、树"><a href="#七、树" class="headerlink" title="七、树"></a>七、树</h2><h3 id="1-树的定义"><a href="#1-树的定义" class="headerlink" title="1.树的定义"></a>1.树的定义</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793ec1da50.png" alt></p><h4 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h4><p><strong>树</strong>(Tree)是n (n≥0)个结点的有限集。(递归)<br>若n =0，称为<strong>空树</strong>;<br>若n &gt;0，则它满足如下两个条件:<br>(1)<strong>有且仅有一个</strong>特定的称为<strong>根</strong>(Root)的结点;<br>(2)<strong>其余结点</strong>可分为m (m≥0)个互不相交的<strong>有限集</strong>T1,T2,T3,…Tm，其中每一个集合本身又是一棵树，并称为根的<strong>子树</strong>(SubTree)。</p><h4 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h4><p><strong>结点</strong>：数据元素以及指向树的分支</p><p><strong>根结点</strong>：非空树中无前驱点的结点</p><p><strong>结点的度</strong>：结点拥有的子树数</p><p>​ eg: A 3,B 2,F 0</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793ee926ad.png" alt></p><p><strong>树的度</strong>： 数内各结点的度的最大值</p><p><strong>叶子结点</strong>:终端结点（度为0）</p><p>​ eg: k L G M J</p><p><strong>分支结点</strong>:非终端结点</p><p>​ eg: B,C,D…</p><p><strong>内部结点</strong>:根节点以外的分支结点称为内部结点</p><p><strong>孩子结点</strong>：结点的子树的根称为孩子</p><p><strong>双亲结点</strong>：孩子结点的前驱</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793ee926ad.png" alt></p><p>​ eg: BCD是A的孩子结点，A是bcd的双亲结点</p><p><strong>兄弟结点</strong>：同级的结点</p><p><strong>祖先结点</strong>：从根到该结点所经分支上的所有结点</p><p>​ eg: M的祖先结点为H,D,A</p><p><strong>子孙结点</strong>:从某结点为根的子树的任意结点</p><p>​ eg: D的孙子有HM</p><p><strong>树的深度</strong>：树中结点的最大层次</p><p><strong>有序树</strong>：树中的各子树从左至右有次序(最左边为第一个孩子)</p><p><strong>无序树</strong>：树中结点的各子树无次序</p><p><strong>森林</strong>：是m（m&gt;=0)棵互不相交的树的集合</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793efe3519.png" alt></p><p>​ 树一定是森林，森林不一定是树</p><h4 id="树结构和线性结构的比较"><a href="#树结构和线性结构的比较" class="headerlink" title="树结构和线性结构的比较"></a>树结构和线性结构的比较</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793f14bdb5.png" alt></p><h3 id="2-二叉树的定义"><a href="#2-二叉树的定义" class="headerlink" title="2.二叉树的定义"></a>2.二叉树的定义</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793e5c621a.png" alt></p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>​ 二叉树是n(n&gt;=0)个结点的有限集，它或者是空集(n= 0),或者由一个根结点及两棵互不相交的分别称作这个根的左子树和右子树的二叉树组成。</p><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ol><li>每个结点最多有俩孩子(二叉树中不存在度大于2的结点)。</li><li>子树有左右之分，其次序不能颠倒。</li><li>二叉树可以是空集合，根可以有空的左子树或空的右子树。</li></ol><h4 id="树和二叉树区别"><a href="#树和二叉树区别" class="headerlink" title="树和二叉树区别"></a><strong>树和二叉树区别</strong></h4><ul><li>二叉树不是树的特殊情况，它们是两个概念</li><li>二叉树结点的子树要区分左子树和右子树，即使只有一棵子树也经行区分，说明它是左子树，还是右子树。</li><li>树当结点只有一个孩子时，就无须区分它是左还是右的次序。因此二者是不同的。这是二叉树与树的最主要的差别。</li><li>(也就是二叉树每个结点位置或者次序都是固定的，可以是空，但是个可以说它没有位置，而树的结点位置是相对于别的结点来说的，没有别的结点时.它就无所谓左右了)</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793f3454a1.png" alt></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793f47ae50.png" alt></p><h3 id="3-案例引用"><a href="#3-案例引用" class="headerlink" title="3.案例引用"></a>3.案例引用</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793f5d89ac.png" alt></p><h3 id="4-树和二叉树的抽象数据类型定义"><a href="#4-树和二叉树的抽象数据类型定义" class="headerlink" title="4.树和二叉树的抽象数据类型定义"></a>4.树和二叉树的抽象数据类型定义</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793f728f2f.png" alt></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793f8eefe9.png" alt></p><h3 id="5-二叉树的性质和存储结构"><a href="#5-二叉树的性质和存储结构" class="headerlink" title="5.二叉树的性质和存储结构"></a>5.二叉树的性质和存储结构</h3><h4 id="1-性质"><a href="#1-性质" class="headerlink" title="1.性质"></a>1.性质</h4><h5 id="满二叉树与完全二叉树"><a href="#满二叉树与完全二叉树" class="headerlink" title="满二叉树与完全二叉树"></a>满二叉树与完全二叉树</h5><p><strong>满二叉树</strong>：一颗深度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.025ex" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686 294 679 244 477 194 279 194 272 213 282 223 291 247 309 292 354T362 415Q402 442 438 442 468 442 485 423T503 369Q503 344 496 327T477 302 456 291 438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316 228 255Q230 254 243 252T267 246 293 238 320 224 342 206 359 180 365 147Q365 130 360 106T354 66Q354 26 381 26 429 26 459 145 461 153 479 153H483Q499 153 499 144 499 139 496 130 455-11 378-11 333-11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206 200 217 182 220H180Q168 178 159 139T145 81 136 44 129 20 122 7 111-2Q98-11 83-11 66-11 57-1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640 121 647Z"/></g></g></g></svg></mjx-container>且有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.186ex" xmlns="http://www.w3.org/2000/svg" width="6.049ex" height="2.117ex" role="img" focusable="false" viewbox="0 -853.7 2673.8 935.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315 301 241Q265 210 201 149L142 93 218 92Q375 92 385 97 392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19 31Q50 38 56 46T86 81Q115 113 136 137 145 147 170 174T204 211 233 244 261 278 284 308 305 340 320 369 333 401 340 431 343 464Q343 527 309 573T212 619Q179 619 154 602T119 569 109 550Q109 549 114 549 132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686 294 679 244 477 194 279 194 272 213 282 223 291 247 309 292 354T362 415Q402 442 438 442 468 442 485 423T503 369Q503 344 496 327T477 302 456 291 438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316 228 255Q230 254 243 252T267 246 293 238 320 224 342 206 359 180 365 147Q365 130 360 106T354 66Q354 26 381 26 429 26 459 145 461 153 479 153H483Q499 153 499 144 499 139 496 130 455-11 378-11 333-11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206 200 217 182 220H180Q168 178 159 139T145 81 136 44 129 20 122 7 111-2Q98-11 83-11 66-11 57-1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640 121 647Z"/></g></g><g data-mml-node="mo" transform="translate(1173.6,0)"><path data-c="2212" d="M84 237T84 250 98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2173.8,0)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g></g></g></svg></mjx-container>个结点的二叉树就叫满二叉树</p><p><strong>完全二叉树</strong>：深度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.025ex" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686 294 679 244 477 194 279 194 272 213 282 223 291 247 309 292 354T362 415Q402 442 438 442 468 442 485 423T503 369Q503 344 496 327T477 302 456 291 438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316 228 255Q230 254 243 252T267 246 293 238 320 224 342 206 359 180 365 147Q365 130 360 106T354 66Q354 26 381 26 429 26 459 145 461 153 479 153H483Q499 153 499 144 499 139 496 130 455-11 378-11 333-11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206 200 217 182 220H180Q168 178 159 139T145 81 136 44 129 20 122 7 111-2Q98-11 83-11 66-11 57-1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640 121 647Z"/></g></g></g></svg></mjx-container>的具有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.025ex" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>个结点的二叉树，当且仅当每一个结点都与深度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.025ex" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686 294 679 244 477 194 279 194 272 213 282 223 291 247 309 292 354T362 415Q402 442 438 442 468 442 485 423T503 369Q503 344 496 327T477 302 456 291 438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316 228 255Q230 254 243 252T267 246 293 238 320 224 342 206 359 180 365 147Q365 130 360 106T354 66Q354 26 381 26 429 26 459 145 461 153 479 153H483Q499 153 499 144 499 139 496 130 455-11 378-11 333-11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206 200 217 182 220H180Q168 178 159 139T145 81 136 44 129 20 122 7 111-2Q98-11 83-11 66-11 57-1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640 121 647Z"/></g></g></g></svg></mjx-container>的<strong>满二叉树</strong>中的<strong>编号</strong>为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.025ex" xmlns="http://www.w3.org/2000/svg" width="3.054ex" height="1.532ex" role="img" focusable="false" viewbox="0 -666 1350 677"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g><g data-mml-node="mtext" transform="translate(500,0)"><path data-c="A0" d=""/></g><g data-mml-node="mi" transform="translate(750,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>的结点一一对应时，称为<strong>完全二叉树</strong>（叶子结点的编号是连续的,<strong>左侧树必须满元素</strong>)</p><ul><li>叶子只可能分布在层次最大的两层上，</li><li>对任意结点，如果其右子树的最大层次为i，则其左子树的最大层次必为i或i+1</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793fba882e.png" alt></p><h6 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h6><p>​ 在二叉树的第i层上至多有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:0" xmlns="http://www.w3.org/2000/svg" width="3.915ex" height="1.887ex" role="img" focusable="false" viewbox="0 -833.9 1730.6 833.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315 301 241Q265 210 201 149L142 93 218 92Q375 92 385 97 392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19 31Q50 38 56 46T86 81Q115 113 136 137 145 147 170 174T204 211 233 244 261 278 284 308 305 340 320 369 333 401 340 431 343 464Q343 527 309 573T212 619Q179 619 154 602T119 569 109 550Q109 549 114 549 132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(345,0)"><path data-c="2212" d="M84 237T84 250 98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1123,0)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g></g></g></g></g></svg></mjx-container>个结点</p><h6 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h6><p>​ 深度为k的二叉树至多有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.186ex" xmlns="http://www.w3.org/2000/svg" width="6.049ex" height="2.117ex" role="img" focusable="false" viewbox="0 -853.7 2673.8 935.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315 301 241Q265 210 201 149L142 93 218 92Q375 92 385 97 392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19 31Q50 38 56 46T86 81Q115 113 136 137 145 147 170 174T204 211 233 244 261 278 284 308 305 340 320 369 333 401 340 431 343 464Q343 527 309 573T212 619Q179 619 154 602T119 569 109 550Q109 549 114 549 132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686 294 679 244 477 194 279 194 272 213 282 223 291 247 309 292 354T362 415Q402 442 438 442 468 442 485 423T503 369Q503 344 496 327T477 302 456 291 438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316 228 255Q230 254 243 252T267 246 293 238 320 224 342 206 359 180 365 147Q365 130 360 106T354 66Q354 26 381 26 429 26 459 145 461 153 479 153H483Q499 153 499 144 499 139 496 130 455-11 378-11 333-11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206 200 217 182 220H180Q168 178 159 139T145 81 136 44 129 20 122 7 111-2Q98-11 83-11 66-11 57-1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640 121 647Z"/></g></g><g data-mml-node="mo" transform="translate(1173.6,0)"><path data-c="2212" d="M84 237T84 250 98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2173.8,0)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g></g></g></svg></mjx-container>个结点(k&gt;=1)</p><h6 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h6><p>​ 对任何一个二叉树<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.339ex" xmlns="http://www.w3.org/2000/svg" width="2.309ex" height="1.871ex" role="img" focusable="false" viewbox="0 -677 1020.6 827"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445 21 450 37 501T71 602L88 651Q93 669 101 677H569 659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437 640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631 469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46 418 46 427 45T436 36Q436 31 433 22 429 4 424 1L422 0Q419 0 415 0 410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83 94Q174 46 189 55 190 56 191 56 196 59 201 76T241 233Q258 301 269 344 339 619 339 625 339 630 310 630H279Q212 630 191 624 146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mn" transform="translate(617,-150) scale(0.707)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g></g></g></g></svg></mjx-container>,如果其叶子为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.375ex" xmlns="http://www.w3.org/2000/svg" width="2.345ex" height="1.375ex" role="img" focusable="false" viewbox="0 -442 1036.6 607.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666 297 666 345 640T423 548Q460 465 460 320 460 165 417 83 397 41 362 16T301-15 250-22Q224-22 198-16T137 16 82 83Q39 165 39 320 39 494 96 585ZM321 597Q291 629 250 629 208 629 178 597 153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16 290 16 318 46 347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></g></svg></mjx-container>,度为2的结点为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.339ex" xmlns="http://www.w3.org/2000/svg" width="2.345ex" height="1.339ex" role="img" focusable="false" viewbox="0 -442 1036.6 592"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315 301 241Q265 210 201 149L142 93 218 92Q375 92 385 97 392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19 31Q50 38 56 46T86 81Q115 113 136 137 145 147 170 174T204 211 233 244 261 278 284 308 305 340 320 369 333 401 340 431 343 464Q343 527 309 573T212 619Q179 619 154 602T119 569 109 550Q109 549 114 549 132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></g></svg></mjx-container>，\则<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.375ex" xmlns="http://www.w3.org/2000/svg" width="11.604ex" height="1.881ex" role="img" focusable="false" viewbox="0 -666 5129.1 831.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666 297 666 345 640T423 548Q460 465 460 320 460 165 417 83 397 41 362 16T301-15 250-22Q224-22 198-16T137 16 82 83Q39 165 39 320 39 494 96 585ZM321 597Q291 629 250 629 208 629 178 597 153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16 290 16 318 46 347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(1314.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347 722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153 722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(2370.1,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315 301 241Q265 210 201 149L142 93 218 92Q375 92 385 97 392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19 31Q50 38 56 46T86 81Q115 113 136 137 145 147 170 174T204 211 233 244 261 278 284 308 305 340 320 369 333 401 340 431 343 464Q343 527 309 573T212 619Q179 619 154 602T119 569 109 550Q109 549 114 549 132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(3628.9,0)"><path data-c="2B" d="M56 237T56 250 70 270H369V420L370 570Q380 583 389 583 402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401-82 391-82H389 387Q375-82 369-68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(4629.1,0)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g></g></g></svg></mjx-container></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793fa360f5.png" alt></p><p>​ eg:这里叶子结点7 8 9 10 11 12有6个,度为2的有1 2 3 4 5 有五个</p><p>总结点数n<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.339ex" xmlns="http://www.w3.org/2000/svg" width="20.578ex" height="1.846ex" role="img" focusable="false" viewbox="0 -666 9095.6 816"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(877.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347 722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153 722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(1933.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315 301 241Q265 210 201 149L142 93 218 92Q375 92 385 97 392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19 31Q50 38 56 46T86 81Q115 113 136 137 145 147 170 174T204 211 233 244 261 278 284 308 305 340 320 369 333 401 340 431 343 464Q343 527 309 573T212 619Q179 619 154 602T119 569 109 550Q109 549 114 549 132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mi" transform="translate(2970.1,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442 467 442 494 420T522 361Q522 332 508 314T481 292 458 288Q439 288 427 299T415 328Q415 374 465 391 454 404 425 404 412 404 406 402 368 386 350 336 290 115 290 78 290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145 504 144 502 134 486 77 440 33T333-11Q263-11 227 52 186-10 133-10H127Q78-10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101 142 81 130 66T107 46 94 41L91 40Q91 39 97 36T113 29 132 26Q168 26 194 71 203 87 217 139T245 247 261 313Q266 340 266 352 266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mn" transform="translate(3542.1,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315 301 241Q265 210 201 149L142 93 218 92Q375 92 385 97 392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19 31Q50 38 56 46T86 81Q115 113 136 137 145 147 170 174T204 211 233 244 261 278 284 308 305 340 320 369 333 401 340 431 343 464Q343 527 309 573T212 619Q179 619 154 602T119 569 109 550Q109 549 114 549 132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(4264.3,0)"><path data-c="2B" d="M56 237T56 250 70 270H369V420L370 570Q380 583 389 583 402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401-82 391-82H389 387Q375-82 369-68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msub" transform="translate(5264.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g></g><g data-mml-node="mi" transform="translate(6301.1,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442 467 442 494 420T522 361Q522 332 508 314T481 292 458 288Q439 288 427 299T415 328Q415 374 465 391 454 404 425 404 412 404 406 402 368 386 350 336 290 115 290 78 290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145 504 144 502 134 486 77 440 33T333-11Q263-11 227 52 186-10 133-10H127Q78-10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101 142 81 130 66T107 46 94 41L91 40Q91 39 97 36T113 29 132 26Q168 26 194 71 203 87 217 139T245 247 261 313Q266 340 266 352 266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mn" transform="translate(6873.1,0)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g><g data-mml-node="mo" transform="translate(7595.3,0)"><path data-c="2B" d="M56 237T56 250 70 270H369V420L370 570Q380 583 389 583 402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401-82 391-82H389 387Q375-82 369-68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(8595.6,0)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g></g></g></svg></mjx-container>又<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.375ex" xmlns="http://www.w3.org/2000/svg" width="16.941ex" height="1.694ex" role="img" focusable="false" viewbox="0 -583 7488.1 748.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(877.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347 722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153 722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(1933.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315 301 241Q265 210 201 149L142 93 218 92Q375 92 385 97 392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19 31Q50 38 56 46T86 81Q115 113 136 137 145 147 170 174T204 211 233 244 261 278 284 308 305 340 320 369 333 401 340 431 343 464Q343 527 309 573T212 619Q179 619 154 602T119 569 109 550Q109 549 114 549 132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(3192.3,0)"><path data-c="2B" d="M56 237T56 250 70 270H369V420L370 570Q380 583 389 583 402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401-82 391-82H389 387Q375-82 369-68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msub" transform="translate(4192.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(5451.3,0)"><path data-c="2B" d="M56 237T56 250 70 270H369V420L370 570Q380 583 389 583 402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401-82 391-82H389 387Q375-82 369-68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msub" transform="translate(6451.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666 297 666 345 640T423 548Q460 465 460 320 460 165 417 83 397 41 362 16T301-15 250-22Q224-22 198-16T137 16 82 83Q39 165 39 320 39 494 96 585ZM321 597Q291 629 250 629 208 629 178 597 153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16 290 16 318 46 347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></g></svg></mjx-container></p><p>总边个数B<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.186ex" xmlns="http://www.w3.org/2000/svg" width="9.989ex" height="1.731ex" role="img" focusable="false" viewbox="0 -683 4415 765"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682 206 683 335 683 594 683 608 681 671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0 42 0 39 2 35 5 35 10 35 17 37 24 42 43 47 45 51 46 62 46H68Q95 46 128 49 142 52 147 61 150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637 473 637 451 637T416 636H403Q388 635 384 626 382 622 352 506 352 503 351 500L320 374H401Q482 374 494 376 554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337 311 337 310 336 310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47 491 54 543 105T595 229Z"/></g><g data-mml-node="mo" transform="translate(1036.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347 722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153 722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(2092.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2914.8,0)"><path data-c="2212" d="M84 237T84 250 98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(3915,0)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g></g></g></svg></mjx-container>=<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.339ex" xmlns="http://www.w3.org/2000/svg" width="17.041ex" height="1.885ex" role="img" focusable="false" viewbox="0 -683 7532.1 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682 206 683 335 683 594 683 608 681 671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0 42 0 39 2 35 5 35 10 35 17 37 24 42 43 47 45 51 46 62 46H68Q95 46 128 49 142 52 147 61 150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637 473 637 451 637T416 636H403Q388 635 384 626 382 622 352 506 352 503 351 500L320 374H401Q482 374 494 376 554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337 311 337 310 336 310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47 491 54 543 105T595 229Z"/></g><g data-mml-node="mo" transform="translate(1036.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347 722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153 722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(2092.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315 301 241Q265 210 201 149L142 93 218 92Q375 92 385 97 392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19 31Q50 38 56 46T86 81Q115 113 136 137 145 147 170 174T204 211 233 244 261 278 284 308 305 340 320 369 333 401 340 431 343 464Q343 527 309 573T212 619Q179 619 154 602T119 569 109 550Q109 549 114 549 132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mi" transform="translate(3129.1,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442 467 442 494 420T522 361Q522 332 508 314T481 292 458 288Q439 288 427 299T415 328Q415 374 465 391 454 404 425 404 412 404 406 402 368 386 350 336 290 115 290 78 290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145 504 144 502 134 486 77 440 33T333-11Q263-11 227 52 186-10 133-10H127Q78-10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101 142 81 130 66T107 46 94 41L91 40Q91 39 97 36T113 29 132 26Q168 26 194 71 203 87 217 139T245 247 261 313Q266 340 266 352 266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mn" transform="translate(3701.1,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315 301 241Q265 210 201 149L142 93 218 92Q375 92 385 97 392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19 31Q50 38 56 46T86 81Q115 113 136 137 145 147 170 174T204 211 233 244 261 278 284 308 305 340 320 369 333 401 340 431 343 464Q343 527 309 573T212 619Q179 619 154 602T119 569 109 550Q109 549 114 549 132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(4423.3,0)"><path data-c="2B" d="M56 237T56 250 70 270H369V420L370 570Q380 583 389 583 402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401-82 391-82H389 387Q375-82 369-68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msub" transform="translate(5423.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g></g><g data-mml-node="mi" transform="translate(6460.1,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442 467 442 494 420T522 361Q522 332 508 314T481 292 458 288Q439 288 427 299T415 328Q415 374 465 391 454 404 425 404 412 404 406 402 368 386 350 336 290 115 290 78 290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145 504 144 502 134 486 77 440 33T333-11Q263-11 227 52 186-10 133-10H127Q78-10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101 142 81 130 66T107 46 94 41L91 40Q91 39 97 36T113 29 132 26Q168 26 194 71 203 87 217 139T245 247 261 313Q266 340 266 352 266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mn" transform="translate(7032.1,0)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g></g></g></svg></mjx-container></p><h6 id="性质4"><a href="#性质4" class="headerlink" title="性质4"></a>性质4</h6><p>具有n个结点的<strong>完全二叉树</strong>的深度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.669ex" xmlns="http://www.w3.org/2000/svg" width="7.895ex" height="2.239ex" role="img" focusable="false" viewbox="0 -694 3489.7 989.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26 179 26 205 131 211 151 215 152 217 153 225 153H229Q238 153 241 153T246 151 248 144Q247 138 245 128T234 90 214 43 183 6 137-11Q101-11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623 167 626 166 628T162 632 157 634 149 635 141 636 132 637 122 637Q112 637 109 637T101 638 95 641 94 647Q94 649 96 661 101 680 107 682T179 688Q194 689 213 690T243 693 254 694Q266 694 266 686 266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D45C" d="M201-11Q126-11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441 333 441 341 440 354 437 367 433T402 417 438 387 464 338 476 268Q476 161 390 75T201-11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375 346 405 306 405 243 405 195 347 158 303 140 230T121 120Z"/></g><g data-mml-node="msubsup" transform="translate(783,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412 431 419 447 422Q461 422 470 413T480 394Q480 379 423 152T363-80Q345-134 286-169T151-205Q10-205 10-137 10-111 28-91T74-71Q89-71 102-80T116-111Q116-121 114-130T107-144 99-154 92-162L90-164H91Q101-167 151-167 189-167 211-155 234-144 254-122T282-75Q288-56 298-13 311 35 311 43ZM384 328 380 339Q377 350 375 354T369 368 359 382 346 393 328 402 306 405Q262 405 221 352 191 313 171 233T151 117Q151 38 213 38 269 38 323 108L331 118 384 328Z"/></g><g data-mml-node="mi" transform="translate(510,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(510,-295.7) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315 301 241Q265 210 201 149L142 93 218 92Q375 92 385 97 392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19 31Q50 38 56 46T86 81Q115 113 136 137 145 147 170 174T204 211 233 244 261 278 284 308 305 340 320 369 333 401 340 431 343 464Q343 527 309 573T212 619Q179 619 154 602T119 569 109 550Q109 549 114 549 132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(1989.5,0)"><path data-c="2B" d="M56 237T56 250 70 270H369V420L370 570Q380 583 389 583 402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401-82 391-82H389 387Q375-82 369-68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(2989.7,0)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g></g></g></svg></mjx-container></p><h6 id="性质5"><a href="#性质5" class="headerlink" title="性质5"></a>性质5</h6><p>如果有一颗<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.025ex" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>个结点的<strong>完全二叉树(</strong>深度为 [<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.669ex" xmlns="http://www.w3.org/2000/svg" width="8.524ex" height="2.366ex" role="img" focusable="false" viewbox="0 -750 3767.7 1045.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26 179 26 205 131 211 151 215 152 217 153 225 153H229Q238 153 241 153T246 151 248 144Q247 138 245 128T234 90 214 43 183 6 137-11Q101-11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623 167 626 166 628T162 632 157 634 149 635 141 636 132 637 122 637Q112 637 109 637T101 638 95 641 94 647Q94 649 96 661 101 680 107 682T179 688Q194 689 213 690T243 693 254 694Q266 694 266 686 266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D45C" d="M201-11Q126-11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441 333 441 341 440 354 437 367 433T402 417 438 387 464 338 476 268Q476 161 390 75T201-11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375 346 405 306 405 243 405 195 347 158 303 140 230T121 120Z"/></g><g data-mml-node="msubsup" transform="translate(783,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412 431 419 447 422Q461 422 470 413T480 394Q480 379 423 152T363-80Q345-134 286-169T151-205Q10-205 10-137 10-111 28-91T74-71Q89-71 102-80T116-111Q116-121 114-130T107-144 99-154 92-162L90-164H91Q101-167 151-167 189-167 211-155 234-144 254-122T282-75Q288-56 298-13 311 35 311 43ZM384 328 380 339Q377 350 375 354T369 368 359 382 346 393 328 402 306 405Q262 405 221 352 191 313 171 233T151 117Q151 38 213 38 269 38 323 108L331 118 384 328Z"/></g><g data-mml-node="mi" transform="translate(510,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(510,-295.7) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315 301 241Q265 210 201 149L142 93 218 92Q375 92 385 97 392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19 31Q50 38 56 46T86 81Q115 113 136 137 145 147 170 174T204 211 233 244 261 278 284 308 305 340 320 369 333 401 340 431 343 464Q343 527 309 573T212 619Q179 619 154 602T119 569 109 550Q109 549 114 549 132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(1767.3,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(2267.5,0)"><path data-c="2B" d="M56 237T56 250 70 270H369V420L370 570Q380 583 389 583 402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401-82 391-82H389 387Q375-82 369-68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(3267.7,0)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g></g></g></svg></mjx-container>)的结点按层编号(从第1层到第[<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.669ex" xmlns="http://www.w3.org/2000/svg" width="8.524ex" height="2.366ex" role="img" focusable="false" viewbox="0 -750 3767.7 1045.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26 179 26 205 131 211 151 215 152 217 153 225 153H229Q238 153 241 153T246 151 248 144Q247 138 245 128T234 90 214 43 183 6 137-11Q101-11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623 167 626 166 628T162 632 157 634 149 635 141 636 132 637 122 637Q112 637 109 637T101 638 95 641 94 647Q94 649 96 661 101 680 107 682T179 688Q194 689 213 690T243 693 254 694Q266 694 266 686 266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D45C" d="M201-11Q126-11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441 333 441 341 440 354 437 367 433T402 417 438 387 464 338 476 268Q476 161 390 75T201-11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375 346 405 306 405 243 405 195 347 158 303 140 230T121 120Z"/></g><g data-mml-node="msubsup" transform="translate(783,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412 431 419 447 422Q461 422 470 413T480 394Q480 379 423 152T363-80Q345-134 286-169T151-205Q10-205 10-137 10-111 28-91T74-71Q89-71 102-80T116-111Q116-121 114-130T107-144 99-154 92-162L90-164H91Q101-167 151-167 189-167 211-155 234-144 254-122T282-75Q288-56 298-13 311 35 311 43ZM384 328 380 339Q377 350 375 354T369 368 359 382 346 393 328 402 306 405Q262 405 221 352 191 313 171 233T151 117Q151 38 213 38 269 38 323 108L331 118 384 328Z"/></g><g data-mml-node="mi" transform="translate(510,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(510,-295.7) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315 301 241Q265 210 201 149L142 93 218 92Q375 92 385 97 392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19 31Q50 38 56 46T86 81Q115 113 136 137 145 147 170 174T204 211 233 244 261 278 284 308 305 340 320 369 333 401 340 431 343 464Q343 527 309 573T212 619Q179 619 154 602T119 569 109 550Q109 549 114 549 132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(1767.3,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(2267.5,0)"><path data-c="2B" d="M56 237T56 250 70 270H369V420L370 570Q380 583 389 583 402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401-82 391-82H389 387Q375-82 369-68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(3267.7,0)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g></g></g></svg></mjx-container>层，每层从左到右)，对<strong>任一结点i</strong>(1&lt;=<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.025ex" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewbox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>&lt;=n),有</p><ol><li>如果<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.025ex" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewbox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>=1，则结点i是二叉树的根，无双亲;如果i&gt;1，则其<strong>双亲是结点[i /2]。</strong></li><li>如果2<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.09ex" xmlns="http://www.w3.org/2000/svg" width="5.155ex" height="1.586ex" role="img" focusable="false" viewbox="0 -661 2278.6 701"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(622.8,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107-40H101Q83-38 83-20 83-19 83-17 82-10 98-1 117 9 248 71 326 108 378 132L626 250 378 368Q90 504 86 509 84 513 84 520Z"/></g><g data-mml-node="mi" transform="translate(1678.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>，则结点i为叶子结点，无左孩子;否则，<br>其<strong>左孩子是结点2i。</strong></li><li>如果<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.186ex" xmlns="http://www.w3.org/2000/svg" width="10.183ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 4501 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315 301 241Q265 210 201 149L142 93 218 92Q375 92 385 97 392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19 31Q50 38 56 46T86 81Q115 113 136 137 145 147 170 174T204 211 233 244 261 278 284 308 305 340 320 369 333 401 340 431 343 464Q343 527 309 573T212 619Q179 619 154 602T119 569 109 550Q109 549 114 549 132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1067.2,0)"><path data-c="2B" d="M56 237T56 250 70 270H369V420L370 570Q380 583 389 583 402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401-82 391-82H389 387Q375-82 369-68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(2067.4,0)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g><g data-mml-node="mo" transform="translate(2845.2,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107-40H101Q83-38 83-20 83-19 83-17 82-10 98-1 117 9 248 71 326 108 378 132L626 250 378 368Q90 504 86 509 84 513 84 520Z"/></g><g data-mml-node="mi" transform="translate(3901,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>，则结点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.025ex" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewbox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>无右孩子;否则，其<strong>右孩</strong><br><strong>子是结点2i + 1。</strong></li></ol><p><strong>总结</strong>: 编号为i，他的父结点为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="3.043ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1345 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(345,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92-240Q85-250 75-250 68-250 62-245T56-231Q56-221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mn" transform="translate(845,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315 301 241Q265 210 201 149L142 93 218 92Q375 92 385 97 392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19 31Q50 38 56 46T86 81Q115 113 136 137 145 147 170 174T204 211 233 244 261 278 284 308 305 340 320 369 333 401 340 431 343 464Q343 527 309 573T212 619Q179 619 154 602T119 569 109 550Q109 549 114 549 132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></svg></mjx-container>,左结点为2i，右节点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.186ex" xmlns="http://www.w3.org/2000/svg" width="5.809ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 2567.4 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315 301 241Q265 210 201 149L142 93 218 92Q375 92 385 97 392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19 31Q50 38 56 46T86 81Q115 113 136 137 145 147 170 174T204 211 233 244 261 278 284 308 305 340 320 369 333 401 340 431 343 464Q343 527 309 573T212 619Q179 619 154 602T119 569 109 550Q109 549 114 549 132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1067.2,0)"><path data-c="2B" d="M56 237T56 250 70 270H369V420L370 570Q380 583 389 583 402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401-82 391-82H389 387Q375-82 369-68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(2067.4,0)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g></g></g></svg></mjx-container></p><h4 id="2-存储结构"><a href="#2-存储结构" class="headerlink" title="2.存储结构"></a>2.存储结构</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793f16773a.png" alt></p><h5 id="1-二叉树的顺序存储结构"><a href="#1-二叉树的顺序存储结构" class="headerlink" title="1.二叉树的顺序存储结构"></a>1.二叉树的顺序存储结构</h5><ul><li><p>实现：按满二叉树的结点层次编号，依次存放在二叉树的数据元素</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">int</span> SqBiTree[MAXTSIZE];</span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793f96d783.png" alt></p></li><li><p>缺点： <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793faa55fc.png" alt></p><p>结点间的关系蕴含在其存储位置中，浪费空间，适合满二叉树和完全二叉树</p></li></ul><h5 id="2-二叉树的链式存储结构"><a href="#2-二叉树的链式存储结构" class="headerlink" title="2.二叉树的链式存储结构"></a>2.二叉树的链式存储结构</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">lchild</span>,*<span class="title">rchile</span>;</span><span class="comment">//左右孩子</span></span><br><span class="line">}BiNode,*BiTree;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793fbdd8c3.png" alt></p><p>在n个结点的二叉链表中，有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.186ex" xmlns="http://www.w3.org/2000/svg" width="5.254ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 2322.4 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(822.2,0)"><path data-c="2B" d="M56 237T56 250 70 270H369V420L370 570Q380 583 389 583 402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401-82 391-82H389 387Q375-82 369-68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(1822.4,0)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g></g></g></svg></mjx-container>个空指针域</p><p>必有2n个链域，除根节点外，每个结点有且仅有一个双亲，所有只会有n-1个结点的链域存放指针，指向非空子女结点</p><h5 id="3-三叉链表"><a href="#3-三叉链表" class="headerlink" title="3.三叉链表"></a>3.三叉链表</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span>{</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span> *<span class="title">Ichild</span>,*<span class="title">parent</span>,*<span class="title">rchild</span>;</span><span class="comment">//指向双亲结点</span></span><br><span class="line">}TriTNode,*TriTree;</span><br></pre></td></tr></table></figure><h4 id="3-遍历二叉树和线索二叉树"><a href="#3-遍历二叉树和线索二叉树" class="headerlink" title="3.遍历二叉树和线索二叉树"></a>3.遍历二叉树和线索二叉树</h4><h5 id="1-类型"><a href="#1-类型" class="headerlink" title="1.类型"></a>1.类型</h5><p>先序遍历：根左右</p><p>中序遍历：左根右</p><p>后续遍历：左右根</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793fd73789.png" alt></p><h6 id="先—根左右"><a href="#先—根左右" class="headerlink" title="先—根左右"></a>先—根左右</h6><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793ff4435f.png" alt></p><p>ABELDHMIJ</p><h6 id="中—左根右"><a href="#中—左根右" class="headerlink" title="中—左根右"></a>中—左根右</h6><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787940079abe.png" alt></p><p>ELBAMHIDJ</p><h6 id="后—左右根"><a href="#后—左右根" class="headerlink" title="后—左右根"></a>后—左右根</h6><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67879401b3d88.png" alt></p><p>LEBMIHJDA</p><p>实例：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793b295ce2.png" alt></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793f789feb.png" alt></p><h5 id="2-根据遍历序列确定二叉树（先-中-后序）"><a href="#2-根据遍历序列确定二叉树（先-中-后序）" class="headerlink" title="2.根据遍历序列确定二叉树（先 中 后序）"></a>2.根据遍历序列确定二叉树（先 中 后序）</h5><ul><li><p>若二叉树中的各结点均不相同，则二叉树结点的先徐序列、中序序列和后序序列都是唯一的</p></li><li><p>由二叉树的先序和中序序列，或由二叉树的后序和中序序列可以确定唯一一颗二叉树</p></li></ul><h6 id="实例1：先序-中序"><a href="#实例1：先序-中序" class="headerlink" title="实例1：先序+中序"></a>实例1：先序+中序</h6><p>先：A B C D E F G H I</p><p>中：C D B F E A I H G J</p><p>解题思路</p><ol><li><p>由先知A必为根，B必为左 由中知 CDBFE在左部，IHGJ在右边</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793ff8cfa7.png" alt></p></li><li><p>由先序知道B为根，由中序知道CD为左子树，FE为右子树</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67879400a8d73.png" alt></p></li><li><p>由先序知道G是根，那么I H为左子树，J为右子树</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67879401ea578.png" alt></p></li><li><p>由中序CD左根右知道，c为左，d为右，先序知道E为根，中序知道F为左</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67879403211f7.png" alt></p></li><li><p>由中序知道I为左子树</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67879404469d0.png" alt></p></li></ol><h6 id="实例2—中序-后续"><a href="#实例2—中序-后续" class="headerlink" title="实例2—中序+后续"></a>实例2—中序+后续</h6><ol><li>中序序列:BDCEAFHG</li><li>后序序列:DECBHGFA</li><li>由中序后续知道根为A，BDCE为左根 FHG为右根</li><li>后序知道B为根，中序推出没有左根，c为下一个根</li><li>左右根D为左，E为右边</li><li>后序知道F为根</li><li>由中序知道F没有左，那么H为左，G为根</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678794060d8ea.png" alt></p><h5 id="3-遍历的算法实现-先序遍历"><a href="#3-遍历的算法实现-先序遍历" class="headerlink" title="3.遍历的算法实现-先序遍历"></a>3.遍历的算法实现-先序遍历</h5><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787940838536.png" alt></p><h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">PerOrderTraverse</span><span class="params">(BiTree T)</span><span class="comment">//指向根节点的指针T</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>,T-&gt;data);</span><br><span class="line">        <span class="comment">// visit(T)</span></span><br><span class="line">        PerOrderTraverse(T-&gt;lchild);</span><br><span class="line">        PerOrderTraverse(T-&gt;rchile);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h6 id="递归代码解释"><a href="#递归代码解释" class="headerlink" title="递归代码解释"></a>递归代码解释</h6><ol><li><p>首先进入函数，此时T为传入的根结点</p></li><li><p>打印根节点</p></li><li><p>第一次调用：<strong>根左右</strong>函数指向根B</p></li><li><p>进入第二层循环 遍历左，左为空此时返回</p></li><li><p>回到第二层循环此时 PerOrderTraverse(T-&gt;lchild);为空，那么自动执行下一条语句PerOrderTraverse(T-&gt;rchile);</p></li><li><p>进入循环，执行到D</p></li><li><p>再向下执行为空返回到第一次循环</p></li><li><p>再执行C</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678793fe73288.png" alt></p></li></ol><p>(●ˇ∀ˇ●)明白了吗！</p><h5 id="4-遍历的算法实现-中序遍历"><a href="#4-遍历的算法实现-中序遍历" class="headerlink" title="4.遍历的算法实现-中序遍历"></a>4.遍历的算法实现-中序遍历</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">PerOrderTraverse</span><span class="params">(BiTree T)</span><span class="comment">//指向根节点的指针T</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>){</span><br><span class="line">       </span><br><span class="line">        PerOrderTraverse(T-&gt;lchild);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d\t"</span>,T-&gt;data);<span class="comment">//可替换(访问根节点)</span></span><br><span class="line">        <span class="comment">// visit(T)</span></span><br><span class="line">        PerOrderTraverse(T-&gt;rchile);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h5 id="5-历的算法实现-后序遍历"><a href="#5-历的算法实现-后序遍历" class="headerlink" title="5.历的算法实现-后序遍历"></a>5.历的算法实现-后序遍历</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">PerOrderTraverse</span><span class="params">(BiTree T)</span><span class="comment">//指向根节点的指针T</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>){</span><br><span class="line">       </span><br><span class="line">        PerOrderTraverse(T-&gt;lchild);</span><br><span class="line">         </span><br><span class="line">        PerOrderTraverse(T-&gt;rchile);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>,T-&gt;data);<span class="comment">//可替换(访问根节点)</span></span><br><span class="line">        <span class="comment">// visit(T)</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h5 id="6-二叉树遍历小总结"><a href="#6-二叉树遍历小总结" class="headerlink" title="6.二叉树遍历小总结"></a>6.二叉树遍历小总结</h5><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787940737cbf.png" alt></p><p>时间复杂度O(n)//每个结点只访问一次</p><p>空间复杂度O(n)//栈占用的最大辅助空间</p><h5 id="7-中序遍历非递归算法-栈"><a href="#7-中序遍历非递归算法-栈" class="headerlink" title="7.中序遍历非递归算法-栈"></a>7.中序遍历非递归算法-栈</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse</span><span class="params">(BiTree T)</span>{</span><br><span class="line">    BiTree P;</span><br><span class="line">    InitStack(S);<span class="comment">//初始化</span></span><br><span class="line">    P=T;</span><br><span class="line">    <span class="keyword">while</span> (p||StackEmpty(S))<span class="comment">//遇到的是根的时候</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(P)<span class="comment">//不为空</span></span><br><span class="line">        {</span><br><span class="line">            Push(S,p);<span class="comment">//入栈</span></span><br><span class="line">            p=p-&gt;Ichild;<span class="comment">//访问左子树</span></span><br><span class="line">        } <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            Pop(S,q);<span class="comment">//出栈</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,q-&gt;data);<span class="comment">//输出根</span></span><br><span class="line">            p=q-&gt;rchild;</span><br><span class="line">        }<span class="comment">//while</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h5 id="8-二叉树的层次遍历"><a href="#8-二叉树的层次遍历" class="headerlink" title="8.二叉树的层次遍历"></a>8.二叉树的层次遍历</h5><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787940947692.png" alt></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787940a797fa.png" alt></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队列定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line">    BTNode data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> front,rar;</span><br><span class="line">    </span><br><span class="line">}SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BTNode *b)</span></span><br><span class="line">{</span><br><span class="line">    BTNode *p;</span><br><span class="line">    SqQueue *qu;</span><br><span class="line">    initQueue(qu);<span class="comment">//初始化</span></span><br><span class="line">    enQuenue(qu,b);<span class="comment">//根节点指针进入队列</span></span><br><span class="line">    <span class="keyword">while</span>(!QueueEmpty(qu)){<span class="comment">//队不为空则循环</span></span><br><span class="line">        deQueue(qu,p);<span class="comment">//出栈结点p</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,p-&gt;data);访问结点p</span><br><span class="line">        <span class="title function_">if</span><span class="params">(p-&gt;Ichild!=<span class="literal">NULL</span>)</span><span class="title function_">enQueue</span><span class="params">(qu,p-&gt;Ichild)</span>;<span class="comment">//有左孩子时将其进队</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)enqueue(qu,p-&gt;rchild);<span class="comment">//有右孩子时将其进队</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h5 id="9-二叉树遍历算法的应用"><a href="#9-二叉树遍历算法的应用" class="headerlink" title="9.二叉树遍历算法的应用"></a>9.二叉树遍历算法的应用</h5><h6 id="1-二叉树的建立"><a href="#1-二叉树的建立" class="headerlink" title="1.二叉树的建立"></a>1.二叉树的建立</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateBiTree</span><span class="params">(BiTree &amp;T)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line"><span class="built_in">scanf</span>(&amp;ch);</span><br><span class="line"><span class="keyword">if</span>(ch==<span class="string">"#"</span>) T=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">    <span class="keyword">if</span>(!(T=(BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode))))</span><br><span class="line">        <span class="built_in">exit</span>(OVRTFLOW);</span><br><span class="line">    T-&gt;data=ch;<span class="comment">//生成根节点</span></span><br><span class="line"></span><br><span class="line">CreateBiTree(T-&gt;Ichild);<span class="comment">//构造左子树</span></span><br><span class="line"></span><br><span class="line">CreateBiTree(T-&gt;rchild);<span class="comment">//构造右子树</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}<span class="comment">//CreateBiTree</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787940bb6eaf.png" alt></p><h6 id="2-复制二叉树"><a href="#2-复制二叉树" class="headerlink" title="2.复制二叉树"></a>2.复制二叉树</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Copy</span><span class="params">(BiTree T,BiTree &amp;newT)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line">        NewT=<span class="literal">NULL</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">        NewT=new BiTNode;</span><br><span class="line">        NewT-&gt;data=T-&gt;data;</span><br><span class="line"></span><br><span class="line">        Copy(T-&gt;lchild,NewT-&gt;lchild);</span><br><span class="line">        Copy(T-&gt;rchild,NewT-&gt;rchild);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h6 id="3-计算二叉树的深度"><a href="#3-计算二叉树的深度" class="headerlink" title="3.计算二叉树的深度"></a>3.计算二叉树的深度</h6><ul><li><p>如果是空树，则深度为0</p></li><li><p>否则，递归计算左子树的深度计为m，递归计算右子树的深度计为n，二叉树的深度则为m与n的较大者<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.186ex" xmlns="http://www.w3.org/2000/svg" width="2.891ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 1278 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2B" d="M56 237T56 250 70 270H369V420L370 570Q380 583 389 583 402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401-82 391-82H389 387Q375-82 369-68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g></g></g></svg></mjx-container></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Depth</span><span class="params">(BiTree T)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        m= Depth(T-&gt;lchild);</span><br><span class="line">        n= Depth(T-&gt;rchile);</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> (m+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (n+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h6 id="4-计算二叉树的结点总数"><a href="#4-计算二叉树的结点总数" class="headerlink" title="4.计算二叉树的结点总数"></a>4.计算二叉树的结点总数</h6><ul><li>如果为空树则结点为0</li><li>否则，结点个数为左子树个数+右子树结点个数再+1</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">NodeCount</span><span class="params">(Bitree T)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> NodeCount(T-&gt;lchild)+ NodeCount(T-&gt;rchild)+<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h6 id="5-计算叶子结点的个数"><a href="#5-计算叶子结点的个数" class="headerlink" title="5.计算叶子结点的个数"></a>5.计算叶子结点的个数</h6><ul><li>如果是空树返回0</li><li>否则，为左子树的叶子结点+右子树的叶子结点</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LeafCount</span><span class="params">(BiTree T)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)<span class="comment">//空树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild==<span class="literal">NULL</span>&amp;&amp;T-&gt;rchile==<span class="literal">NULL</span>)<span class="comment">//如果是叶子结点返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> LeafCount(T-&gt;lchild)+leafCount(T-&gt;rchile);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h5 id="10-线索二叉树"><a href="#10-线索二叉树" class="headerlink" title="10.线索二叉树"></a>10.线索二叉树</h5><ul><li>如果某个结点的左孩子为空，则将空的左孩子指针域改为<strong>指向其前驱</strong>；</li><li>如果某孩子的右结点为空，则将空的右孩子的指针域改为<strong>指向其后继</strong>；</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787940e8ceda.png" alt></p><p>这里是依照遍历来判断前驱后继，而不是图</p><h6 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1.定义"></a>1.定义</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThNode</span>{</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> ltag,rtag;<span class="comment">//0表示是左/右孩子，1表示是前/后继</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    </span><br><span class="line">};</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787940fee958.png" alt></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678794113afb7.png" alt></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678794055bd17.png" alt></p><hr><h6 id="2-线索二叉树画法"><a href="#2-线索二叉树画法" class="headerlink" title="2.线索二叉树画法"></a>2.线索二叉树画法</h6><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787940f274bd.png" alt></p><h6 id="3-遍历算法"><a href="#3-遍历算法" class="headerlink" title="3.遍历算法"></a>3.遍历算法</h6><p>408不要求掌握</p><h5 id="11-李阳的交换左右子树"><a href="#11-李阳的交换左右子树" class="headerlink" title="11.李阳的交换左右子树"></a>11.李阳的交换左右子树</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 李阳 on 2024/11/14.树的交换左右子树</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>{</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line"></span><br><span class="line">}TreeNode;</span><br><span class="line"></span><br><span class="line">TreeNode * <span class="title function_">creatNode</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">{</span><br><span class="line">    TreeNode * newNode=(TreeNode*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    <span class="keyword">if</span>(!newNode)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"失败的树 "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    newNode-&gt;val=val;</span><br><span class="line">    newNode-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换左右子树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swaplr</span><span class="params">(TreeNode * root)</span>{</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    TreeNode * temp=root-&gt;left;</span><br><span class="line">    root-&gt;left=root-&gt;right;</span><br><span class="line">    root-&gt;right=temp;</span><br><span class="line">    swaplr(root-&gt;left);<span class="comment">//交换左半树</span></span><br><span class="line">    swaplr(root-&gt;right);<span class="comment">//右半边树</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历打印二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrderTraversal</span><span class="params">(TreeNode*root)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;val);</span><br><span class="line">    preOrderTraversal(root-&gt;left);</span><br><span class="line">    preOrderTraversal(root-&gt;right);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放二叉树内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeTree</span><span class="params">(TreeNode* root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    freeTree(root-&gt;left);</span><br><span class="line">    freeTree(root-&gt;right);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    TreeNode * root=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建一个简单的二叉树</span></span><br><span class="line">    <span class="comment">//       1</span></span><br><span class="line">    <span class="comment">//      / \</span></span><br><span class="line"><span class="comment">    //     2   3</span></span><br><span class="line">    <span class="comment">//    / \</span></span><br><span class="line"><span class="comment">    //   4   5</span></span><br><span class="line"></span><br><span class="line">    root= creatNode(<span class="number">1</span>);</span><br><span class="line">    root-&gt;left = creatNode(<span class="number">2</span>);</span><br><span class="line">    root-&gt;right = creatNode(<span class="number">3</span>);</span><br><span class="line">    root-&gt;left-&gt;left = creatNode(<span class="number">4</span>);</span><br><span class="line">    root-&gt;left-&gt;right = creatNode(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    preOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    swaplr(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Pre-order traversal after swapping:\n"</span>);</span><br><span class="line">    preOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    freeTree(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-树和森林"><a href="#6-树和森林" class="headerlink" title="6.树和森林"></a>6.树和森林</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">408要求</span><br><span class="line">2森林与二叉树的转换</span><br><span class="line">3树和森林的遍历</span><br></pre></td></tr></table></figure><h4 id="1-定义-4"><a href="#1-定义-4" class="headerlink" title="1.定义"></a>1.定义</h4><p><strong>森林</strong>：是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="11.642ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5145.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341 56 388 88 425 132 442 175 435 205 417 221 395 229 376L231 369Q231 367 232 367L243 378Q303 442 384 442 401 442 415 440T441 433 460 423 475 411 485 398 493 385 497 373 500 364 502 357L510 367Q573 442 659 442 713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145 857 144 853 130 845 101 831 73T785 17 716-10Q669-10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291 466 157Q433 26 428 16 415-11 385-11 372-11 364-4T353 8 350 18Q350 29 384 161L420 307Q423 322 423 345 423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 181 151 335 151 342 154 357 154 369 154 405 129 405 107 405 92 377T69 316 57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(878,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488 164 576 202 643 244 695 277 729 302 750H315 319Q333 750 333 741 333 738 316 720T275 667 226 581 184 443 167 250 184 58 225-81 274-167 316-220 333-241Q333-250 318-250H315 302L274-226Q180-141 137-14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1267,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341 56 388 88 425 132 442 175 435 205 417 221 395 229 376L231 369Q231 367 232 367L243 378Q303 442 384 442 401 442 415 440T441 433 460 423 475 411 485 398 493 385 497 373 500 364 502 357L510 367Q573 442 659 442 713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145 857 144 853 130 845 101 831 73T785 17 716-10Q669-10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291 466 157Q433 26 428 16 415-11 385-11 372-11 364-4T353 8 350 18Q350 29 384 161L420 307Q423 322 423 345 423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 181 151 335 151 342 154 357 154 369 154 405 129 405 107 405 92 377T69 316 57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2422.8,0)"><g data-mml-node="text"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107-40H101Q83-38 83-20 83-19 83-17 82-10 98-1 117 9 248 71 326 108 378 132L626 250 378 368Q90 504 86 509 84 513 84 520Z"/></g><g data-mml-node="text" transform="translate(778,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347 722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153 722 140 707 133H70Q56 140 56 153Z"/></g></g><g data-mml-node="mn" transform="translate(4256.6,0)"><path data-c="30" d="M96 585Q152 666 249 666 297 666 345 640T423 548Q460 465 460 320 460 165 417 83 397 41 362 16T301-15 250-22Q224-22 198-16T137 16 82 83Q39 165 39 320 39 494 96 585ZM321 597Q291 629 250 629 208 629 178 597 153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16 290 16 318 46 347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(4756.6,0)"><path data-c="29" d="M60 749 64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12 224-76 186-143 145-194 113-227 90-246Q87-249 86-250H74Q66-250 63-250T58-247 55-238Q56-237 66-225 221-64 221 250T66 725Q56 737 55 738 55 746 60 749Z"/></g></g></g></svg></mjx-container>棵互不相交的树的集合</p><h4 id="2-双亲表示法"><a href="#2-双亲表示法" class="headerlink" title="2.双亲表示法"></a>2.双亲表示法</h4><ul><li><p><strong>实现</strong>：定义结构数组</p><p>​ 存放树的结点</p><p>​ 每个结点含两个域</p></li><li><p><strong>数据域</strong>：存放结点本身信息</p></li><li><p><strong>双亲域</strong>：指示本结点的双亲结点在数组中的位置</p></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67879410bb21f.png" alt></p><p><strong>特点</strong>：找双亲容易，找孩子难</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span>{</span><span class="comment">//树的结点定义</span></span><br><span class="line">    TElemType data;<span class="comment">//数据元素</span></span><br><span class="line">    <span class="type">int</span> parent;<span class="comment">//双亲位置域</span></span><br><span class="line">}PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span><span class="comment">//树的类型定义</span></span><br><span class="line">    PTNode nodes[MAXTSIZE];<span class="comment">//双亲表示</span></span><br><span class="line">    <span class="type">int</span> n,r;<span class="comment">//节点数,根节点位置</span></span><br><span class="line">}PTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-孩子链表"><a href="#3-孩子链表" class="headerlink" title="3.孩子链表"></a>3.孩子链表</h4><p>把每个结点的孩子结点排列起来，看成是一个线性表， 用单链表存储，则n个结点有n个孩子链表(叶子的孩子链表为空表)。而n个头指针又组成一个线性表，用顺序表(含n个元素的结构数组)存储。</p><p><strong>解释</strong>：每个结点都有一个单链表，叶子节点的单链表是空表，然后再将这些链表的头指针存放在数组中</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67879412467ec.png" alt></p><p>孩子结点结构</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>{</span></span><br><span class="line">    <span class="type">int</span> child;<span class="comment">//整数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span><span class="comment">//下一个孩子的地址</span></span><br><span class="line">}* ChildPrt;</span><br></pre></td></tr></table></figure><p>双亲结点结构</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    TElemType data;<span class="comment">//数据元素</span></span><br><span class="line">    ChildPrt firstchild;<span class="comment">//孩子链表头指针</span></span><br><span class="line">}CTBox;</span><br></pre></td></tr></table></figure><p>树结构</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    CTBox nodes[MAXTSIZE];<span class="comment">//头指针数组</span></span><br><span class="line">    <span class="type">int</span> n,r;<span class="comment">//节点数和根节点位置下标</span></span><br><span class="line">}CTree;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>:找孩子容易，找双亲难</p><h4 id="4-孩子兄弟表示法（二叉树表示法，二叉链表表示法）"><a href="#4-孩子兄弟表示法（二叉树表示法，二叉链表表示法）" class="headerlink" title="4.*孩子兄弟表示法（二叉树表示法，二叉链表表示法）"></a>4.*孩子兄弟表示法（二叉树表示法，二叉链表表示法）</h4><h5 id="1-定义-5"><a href="#1-定义-5" class="headerlink" title="1.定义"></a>1.定义</h5><p><strong>实现</strong>：用二叉链表作树的存储结构，链表中的美观结点的指针域分别指向其<strong>第一个孩子节点</strong>和<strong>下一个兄弟节点</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>{</span></span><br><span class="line">    ELemtype data;<span class="comment">//元素类型 数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span><span class="comment">//第一个孩子，下一个兄弟</span></span><br><span class="line">}CSNode,*CSTree;</span><br></pre></td></tr></table></figure><p>左孩子 右兄弟，是兄弟的就来砍我</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678794137fe5d.png" alt></p><p>特点：找孩子，找兄弟简单，找双亲难</p><h4 id="5-树与二叉树的转换"><a href="#5-树与二叉树的转换" class="headerlink" title="5.*树与二叉树的转换"></a>5.*树与二叉树的转换</h4><h5 id="1-定义-6"><a href="#1-定义-6" class="headerlink" title="1.定义"></a>1.定义</h5><ul><li>将树转化为二叉树，利用二叉树的算法实现对树的操作</li><li>由于树和二叉树都可以用二叉链表作存储结构，则以二叉树链表作媒介可以导出树与二叉树之间的对应关系</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67879414bfc3e.png" alt></p><h5 id="2-操作"><a href="#2-操作" class="headerlink" title="2.操作"></a>2.操作</h5><h6 id="1-将树转为二叉树"><a href="#1-将树转为二叉树" class="headerlink" title="1.将树转为二叉树"></a>1.将树转为二叉树</h6><ol><li><p>加线:在兄弟之间加一连线</p></li><li><p>抹线:对每个结点，除了其左孩子外，去除其与其余孩子之间的关系</p></li><li>旋转:以树的根结点为轴心，将整树顺时针转45°</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787941618c4c.png" alt></p><h6 id="2-将二叉树转为树"><a href="#2-将二叉树转为树" class="headerlink" title="2.将二叉树转为树"></a>2.将二叉树转为树</h6><ol><li>加线:若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩….沿分支找到的所有右孩子，都与p的双亲用线连起来</li><li>抹线:抹掉原二叉树中双亲与右孩子之间的连线</li><li>调整:将结点按层次排列，形成树结构</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787941753ecd.png" alt></p><h4 id="6-森林和二叉树的转换（二叉树与多棵树之间的关系"><a href="#6-森林和二叉树的转换（二叉树与多棵树之间的关系" class="headerlink" title="6.*森林和二叉树的转换（二叉树与多棵树之间的关系)"></a>6.*森林和二叉树的转换（二叉树与多棵树之间的关系)</h4><h5 id="1-森林转化为二叉树"><a href="#1-森林转化为二叉树" class="headerlink" title="1.森林转化为二叉树"></a>1.森林转化为二叉树</h5><ol><li><p>将各棵树分别转换成二叉树</p></li><li><p>将每棵树的根结点用线相连</p></li><li><p>以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构</p></li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67879418b7625.png" alt></p><h5 id="2-二叉树转为森林"><a href="#2-二叉树转为森林" class="headerlink" title="2.二叉树转为森林"></a>2.二叉树转为森林</h5><ol><li><p>抹线:将二叉树中根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二又树（去掉全部右孩线）</p></li><li><p>还原:将孤立的二又树还原成树（孤立二叉再还原)</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67879419ef799.png" alt></p></li></ol><h4 id="7-树与森林的遍历"><a href="#7-树与森林的遍历" class="headerlink" title="7.树与森林的遍历"></a>7.树与森林的遍历</h4><h5 id="1-树的遍历的三种方式-先根（次序-，后根，层次遍历"><a href="#1-树的遍历的三种方式-先根（次序-，后根，层次遍历" class="headerlink" title="1.树的遍历的三种方式{先根（次序)，后根，层次遍历}"></a>1.树的遍历的三种方式{先根（次序)，后根，层次遍历}</h5><ul><li><p>先根遍历（次序）</p><p>​ 若树不空，则先访问根结点，然后依次先根遍历各棵子树</p></li><li><p>后根遍历（次序）</p><p>​ 若树不空，则先依次后根遍历各棵子树，然后访问根结点</p></li><li><p>层次遍历</p><p>​ 若树不空，则至上而下自左至右访问树的每个结点</p></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787941cd46df.png" alt></p><h5 id="2-森林的遍历"><a href="#2-森林的遍历" class="headerlink" title="2.森林的遍历"></a>2.森林的遍历</h5><p>将森林看作3部分构成</p><ol><li>森林中第一棵树的根结点;</li><li>森林中第一棵树的子树森林，</li><li>森林中其它树构成的森林。</li></ol><h6 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1.先序遍历"></a>1.先序遍历</h6><p>若森林不空 则：</p><ol><li>访问森林中第一棵树的<strong>根结点;</strong></li><li><strong>先序遍历</strong>森林中第一棵树的子树森林;</li><li><strong>先序遍历</strong>森林中(除第一棵树之外)其余树构成的森林。</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678794219b79f.png" alt></p><h6 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2.中序遍历"></a>2.中序遍历</h6><p>若森林不空，则</p><p>​ 1.<strong>中序遍历</strong>森林中第一棵树的子树森林;</p><p>​ 2.访问森林中第一棵树的<strong>根结点;</strong></p><p>​ 3.<strong>中序遍历</strong>森林中(除第一棵树之外)其余树构成的森林。</p><p>对应：213</p><h6 id="3-小案例"><a href="#3-小案例" class="headerlink" title="3.小案例"></a>3.小案例</h6><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787940cc49c2.png" alt></p><h3 id="7-哈夫曼树及其应用"><a href="#7-哈夫曼树及其应用" class="headerlink" title="7.*哈夫曼树及其应用"></a>7.*哈夫曼树及其应用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">408要求：</span><br><span class="line">1．哈夫曼（Huffman）树和哈夫曼编码</span><br><span class="line"></span><br><span class="line">2．并查集及其应用</span><br><span class="line"></span><br><span class="line">3．堆及其应用（25新增）</span><br></pre></td></tr></table></figure><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h4><p><strong>路径</strong>：从树中的一个结点到另一个结点之间的分支构成这两个结点间的路径</p><p><strong>结点路径的长度</strong>:两结点间的路径上的分支数</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678794168d823.png" alt></p><p><strong>树的路径长度</strong>：从树根到每一个结点的路径长度之和，记作TL</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787941811996.png" alt></p><p>结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树</p><p><strong>权</strong>：将树中结点赋给一个有着某种含义的数值，则这个数值称为该<strong>结点的权</strong></p><p><strong>结点的带权路径长度</strong>：从<strong>根节点</strong>到该结点之间的<strong>路径长度</strong>与该结点的<strong>权</strong>的<strong>乘积</strong></p><p><strong>树的带权的路径长度</strong>：树中的所有<strong>叶子</strong>结点<strong>带权路径长度之和</strong>(WPL)</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787941979edb.png" alt></p><p><strong>最优树</strong>：带权路径最短的树（最优树）度要相同</p><p><strong>最优二叉树</strong>：带权路径长度(WPL)最短的二叉树</p><p>满二叉树不一定是哈夫曼树</p><p>具有相同带权结点的哈夫曼树不唯一</p><p><strong>贪心算法</strong>：构造哈夫曼树时首先选择权最小的叶子结点</p><h4 id="2-哈夫曼算法"><a href="#2-哈夫曼算法" class="headerlink" title="2.哈夫曼算法"></a>2.哈夫曼算法</h4><h5 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1.构造方法"></a>1.构造方法</h5><ol><li><p>根据<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.025ex" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>个给定的权值<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.439ex" xmlns="http://www.w3.org/2000/svg" width="14.571ex" height="1.984ex" role="img" focusable="false" viewbox="0 -683 6440.4 877"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674 695 670 692 659 687 641 683 639T661 637Q636 636 621 632T600 624 597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170 666 200 690 241 720 295 759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647 817 650 819 660 823 676 825 679T839 682Q842 682 856 682T895 682 949 681Q1015 681 1034 683 1048 683 1048 672 1048 666 1045 655T1038 640 1028 637Q1006 637 988 631T958 617 939 600 927 584L923 578 754 282Q586-14 585-15 579-22 561-22 546-22 542-17 539-14 523 229T506 480L494 462Q472 425 366 239 222-13 220-15T215-19Q210-22 197-22 178-22 176-15 176-12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648 52 671 64 683H76Q118 680 176 680 301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620 262 160 266 136L501 550 499 587Q496 629 489 632 483 636 447 637 428 637 422 639T416 648Q416 650 418 660 419 664 420 669T421 676 424 680 428 682 436 683Z"/></g><g data-mml-node="mn" transform="translate(977,-150) scale(0.707)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(1380.6,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1825.2,0)"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674 695 670 692 659 687 641 683 639T661 637Q636 636 621 632T600 624 597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170 666 200 690 241 720 295 759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647 817 650 819 660 823 676 825 679T839 682Q842 682 856 682T895 682 949 681Q1015 681 1034 683 1048 683 1048 672 1048 666 1045 655T1038 640 1028 637Q1006 637 988 631T958 617 939 600 927 584L923 578 754 282Q586-14 585-15 579-22 561-22 546-22 542-17 539-14 523 229T506 480L494 462Q472 425 366 239 222-13 220-15T215-19Q210-22 197-22 178-22 176-15 176-12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648 52 671 64 683H76Q118 680 176 680 301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620 262 160 266 136L501 550 499 587Q496 629 489 632 483 636 447 637 428 637 422 639T416 648Q416 650 418 660 419 664 420 669T421 676 424 680 428 682 436 683Z"/></g><g data-mml-node="mn" transform="translate(977,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315 301 241Q265 210 201 149L142 93 218 92Q375 92 385 97 392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19 31Q50 38 56 46T86 81Q115 113 136 137 145 147 170 174T204 211 233 244 261 278 284 308 305 340 320 369 333 401 340 431 343 464Q343 527 309 573T212 619Q179 619 154 602T119 569 109 550Q109 549 114 549 132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(3205.8,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g><g data-mml-node="mo" transform="translate(3650.4,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0 96 17 78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0 543 17 525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0 990 17 972 60Z"/></g><g data-mml-node="msub" transform="translate(4989.1,0)"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674 695 670 692 659 687 641 683 639T661 637Q636 636 621 632T600 624 597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170 666 200 690 241 720 295 759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647 817 650 819 660 823 676 825 679T839 682Q842 682 856 682T895 682 949 681Q1015 681 1034 683 1048 683 1048 672 1048 666 1045 655T1038 640 1028 637Q1006 637 988 631T958 617 939 600 927 584L923 578 754 282Q586-14 585-15 579-22 561-22 546-22 542-17 539-14 523 229T506 480L494 462Q472 425 366 239 222-13 220-15T215-19Q210-22 197-22 178-22 176-15 176-12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648 52 671 64 683H76Q118 680 176 680 301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620 262 160 266 136L501 550 499 587Q496 629 489 632 483 636 447 637 428 637 422 639T416 648Q416 650 418 660 419 664 420 669T421 676 424 680 428 682 436 683Z"/></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></g></svg></mjx-container>构成的<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.025ex" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>棵二叉树的森林<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.439ex" xmlns="http://www.w3.org/2000/svg" width="16.839ex" height="1.977ex" role="img" focusable="false" viewbox="0 -680 7442.9 874"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11 31 13 34 25 38 41 42 43T65 46Q92 46 125 49 139 52 144 61 146 66 215 342T285 622Q285 629 281 629 273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669 749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453 683 454 686 477T689 530Q689 560 682 579T663 610 626 626 575 633 503 634H480Q398 633 393 631 388 629 386 623 385 622 352 492L320 363H375Q378 363 398 363T426 364 448 367 472 374 489 386Q502 398 511 419T524 457 529 475Q532 480 548 480H560Q567 475 567 470 567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212 463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60 245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2 120 2 86 2T48 1Z"/></g><g data-mml-node="mo" transform="translate(1026.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347 722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153 722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2082.6,0)"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445 21 450 37 501T71 602L88 651Q93 669 101 677H569 659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437 640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631 469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46 418 46 427 45T436 36Q436 31 433 22 429 4 424 1L422 0Q419 0 415 0 410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83 94Q174 46 189 55 190 56 191 56 196 59 201 76T241 233Q258 301 269 344 339 619 339 625 339 630 310 630H279Q212 630 191 624 146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mn" transform="translate(617,-150) scale(0.707)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(1020.6,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1465.2,0)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445 21 450 37 501T71 602L88 651Q93 669 101 677H569 659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437 640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631 469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46 418 46 427 45T436 36Q436 31 433 22 429 4 424 1L422 0Q419 0 415 0 410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83 94Q174 46 189 55 190 56 191 56 196 59 201 76T241 233Q258 301 269 344 339 619 339 625 339 630 310 630H279Q212 630 191 624 146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mn" transform="translate(617,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315 301 241Q265 210 201 149L142 93 218 92Q375 92 385 97 392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19 31Q50 38 56 46T86 81Q115 113 136 137 145 147 170 174T204 211 233 244 261 278 284 308 305 340 320 369 333 401 340 431 343 464Q343 527 309 573T212 619Q179 619 154 602T119 569 109 550Q109 549 114 549 132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2485.8,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g><g data-mml-node="mo" transform="translate(2930.4,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0 96 17 78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0 543 17 525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0 990 17 972 60Z"/></g><g data-mml-node="msub" transform="translate(4269.1,0)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445 21 450 37 501T71 602L88 651Q93 669 101 677H569 659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437 640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631 469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46 418 46 427 45T436 36Q436 31 433 22 429 4 424 1L422 0Q419 0 415 0 410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83 94Q174 46 189 55 190 56 191 56 196 59 201 76T241 233Q258 301 269 344 339 619 339 625 339 630 310 630H279Q212 630 191 624 146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></g></svg></mjx-container>,其中<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.357ex" xmlns="http://www.w3.org/2000/svg" width="2.061ex" height="1.889ex" role="img" focusable="false" viewbox="0 -677 911 834.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445 21 450 37 501T71 602L88 651Q93 669 101 677H569 659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437 640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631 469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46 418 46 427 45T436 36Q436 31 433 22 429 4 424 1L422 0Q419 0 415 0 410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83 94Q174 46 189 55 190 56 191 56 196 59 201 76T241 233Q258 301 269 344 339 619 339 625 339 630 310 630H279Q212 630 191 624 146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>只有一个带权为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.357ex" xmlns="http://www.w3.org/2000/svg" width="2.875ex" height="1.902ex" role="img" focusable="false" viewbox="0 -683 1271 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674 695 670 692 659 687 641 683 639T661 637Q636 636 621 632T600 624 597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170 666 200 690 241 720 295 759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647 817 650 819 660 823 676 825 679T839 682Q842 682 856 682T895 682 949 681Q1015 681 1034 683 1048 683 1048 672 1048 666 1045 655T1038 640 1028 637Q1006 637 988 631T958 617 939 600 927 584L923 578 754 282Q586-14 585-15 579-22 561-22 546-22 542-17 539-14 523 229T506 480L494 462Q472 425 366 239 222-13 220-15T215-19Q210-22 197-22 178-22 176-15 176-12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648 52 671 64 683H76Q118 680 176 680 301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620 262 160 266 136L501 550 499 587Q496 629 489 632 483 636 447 637 428 637 422 639T416 648Q416 650 418 660 419 664 420 669T421 676 424 680 428 682 436 683Z"/></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>的根节点</p><p>​ 构造森林全是根</p></li><li><p>在<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:0" xmlns="http://www.w3.org/2000/svg" width="1.695ex" height="1.538ex" role="img" focusable="false" viewbox="0 -680 749 680"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11 31 13 34 25 38 41 42 43T65 46Q92 46 125 49 139 52 144 61 146 66 215 342T285 622Q285 629 281 629 273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669 749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453 683 454 686 477T689 530Q689 560 682 579T663 610 626 626 575 633 503 634H480Q398 633 393 631 388 629 386 623 385 622 352 492L320 363H375Q378 363 398 363T426 364 448 367 472 374 489 386Q502 398 511 419T524 457 529 475Q532 480 548 480H560Q567 475 567 470 567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212 463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60 245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2 120 2 86 2T48 1Z"/></g></g></g></svg></mjx-container>中选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。</p><p>​ 选用两小造新树</p></li><li><p>在<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:0" xmlns="http://www.w3.org/2000/svg" width="1.695ex" height="1.538ex" role="img" focusable="false" viewbox="0 -680 749 680"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11 31 13 34 25 38 41 42 43T65 46Q92 46 125 49 139 52 144 61 146 66 215 342T285 622Q285 629 281 629 273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669 749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453 683 454 686 477T689 530Q689 560 682 579T663 610 626 626 575 633 503 634H480Q398 633 393 631 388 629 386 623 385 622 352 492L320 363H375Q378 363 398 363T426 364 448 367 472 374 489 386Q502 398 511 419T524 457 529 475Q532 480 548 480H560Q567 475 567 470 567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212 463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60 245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2 120 2 86 2T48 1Z"/></g></g></g></svg></mjx-container>中删除这两棵树，同时将新得到的二叉校加入森林中。·</p></li></ol><p>​ 删除两小添新人</p><p>​ 4. 重复2，3剩单根</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787941c36cdb.png" alt></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787941f33a5b.png" alt></p><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><ol><li>哈夫曼树的结点只有度为0或2的没有度为1的结点</li><li>包含n各叶子结点的哈夫曼树共有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.186ex" xmlns="http://www.w3.org/2000/svg" width="6.386ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 2822.4 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315 301 241Q265 210 201 149L142 93 218 92Q375 92 385 97 392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19 31Q50 38 56 46T86 81Q115 113 136 137 145 147 170 174T204 211 233 244 261 278 284 308 305 340 320 369 333 401 340 431 343 464Q343 527 309 573T212 619Q179 619 154 602T119 569 109 550Q109 549 114 549 132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1322.2,0)"><path data-c="2212" d="M84 237T84 250 98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2322.4,0)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g></g></g></svg></mjx-container>个结点</li><li>包含n棵树的森林要经过n-1次合并才能形成哈夫曼树，共产生n-1个新结点</li><li>在哈夫曼算法中，初始时有n棵二叉树，要经过n-1次合并最终形成哈夫曼树。</li><li>经过n-1次合并产生n-1个新结点，且这n-1个新结点都是具有两个孩子的分支结点。</li><li>可见:哈夫曼树中共有n+n-1 = 2n-1个结点，且其所有的分支结点的度均不为1。</li></ol><h5 id="2-哈夫曼树的算法"><a href="#2-哈夫曼树的算法" class="headerlink" title="2.哈夫曼树的算法"></a>2.哈夫曼树的算法</h5><h6 id="顺序结构（一维数组）"><a href="#顺序结构（一维数组）" class="headerlink" title="顺序结构（一维数组）"></a>顺序结构（一维数组）</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> weight;<span class="comment">//权值</span></span><br><span class="line">    <span class="type">int</span> parent,lch,rch;<span class="comment">//双亲，左孩子，右孩子</span></span><br><span class="line">}HTNode,*HUffmanTree;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67879422dbcff.png" alt></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreatHuffmanTree</span> <span class="params">(HuffmanTree &amp;HT, <span class="type">int</span> n)</span>{<span class="comment">//构造哈夫曼树——哈夫曼算法</span></span><br><span class="line">    <span class="type">int</span> m,i;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    m=<span class="number">2</span>*n<span class="number">-1</span>;<span class="comment">//数组共2n-1个元素</span></span><br><span class="line">    HT=new HTNode[m+<span class="number">1</span>];<span class="comment">//0号单元未用，HT[m]表示根结点</span></span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;++i){<span class="comment">//将2n-1个元素的Ich、rch、parent置为O</span></span><br><span class="line">    HT[i].lch=<span class="number">0</span>; HT[i].rch=<span class="number">0</span>; HT[i].parent=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">cin</span>&gt;&gt;HT[i].weight;<span class="comment">//输入前n个元素的weight值</span></span><br><span class="line"><span class="comment">// 初始化结束，下面开始建立哈夫曼树</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( i=n+<span class="number">1</span>;i&lt;=m; i++){<span class="comment">//合并产生n-1个结点——构造Huffman树</span></span><br><span class="line">     Select(HT, i<span class="number">-1</span>,s1,s2);<span class="comment">//在HT[k](1≤ksi-1)中选择两个其双亲域为0，</span></span><br><span class="line">                           <span class="comment">//且权值最小的结点,并返回它们在HT中的序号s1和s2</span></span><br><span class="line">HT[s1].parent=i; HT[s2] .parent=i;<span class="comment">//表示从F中删除s1,s2</span></span><br><span class="line">HT[i].llch=s1;HT[i].rch=s2;<span class="comment">//s1,s2分别作为i的左右孩子</span></span><br><span class="line">HT[i].weight=HT[s1].weight + HT[s2].weight;<span class="comment">//i的权值为左右孩子权值之和</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ol><li>初始化HT[1…….2n-1]: lch=rch=parent=0</li><li>输入初始n个叶子结点:置HT[1…..n]的weight值;</li><li>进行以下n-1次合并，依次产生n-1个结点HT[i], i=n+1…..2n-1:</li></ol><ul><li>a)在HT[1..i-1]中选两个未被选过(从parent ==0的结点中选)的weight最小的两个结点HT[s1]和HT[s2], s1、s2为两个最小结点下标;</li><li>b)修改HT[s1]和HT[s2]的parent的值：HT[s1].parent=i;HT[s2].parent=i;</li><li>c)修改新产生的HT[i]:<br>.HT[i].weight=HT[s1].weight + HT[s2].weight;. HT[i]. Ich=s1; HT[i]. rch=s2;</li></ul><h4 id="3-哈夫曼编码"><a href="#3-哈夫曼编码" class="headerlink" title="3.哈夫曼编码"></a>3.哈夫曼编码</h4><p>前缀编码：任意一字符不是另一个字符的前缀</p><h5 id="1-方法"><a href="#1-方法" class="headerlink" title="1.方法"></a>1.方法</h5><p>1、统计字符集中每个字符在电文中出现的平均概率 (概率越大，<br>要求编码越短)。<br>2、利用哈夫曼树的特点:权越大的叶子离根越近;将每个字符的概率值作为权值，构造哈夫曼树。则概率越大的结点，路径越短。<br>3、在哈夫曼树的每个分支上标上O或1:<br>结点的左分支标0，右分支标1<br>把从根到每个吐子的路径上的标号连接起来，作为该叶子代表的字符的编码。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787942485bbc.png" alt></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678794150563d.png" alt></p><p>左分支标记0，右分支标记1</p><h6 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h6><p>1.为什么哈夫曼编码能够保证是前缀编码?</p><p>因为没有一片树叶是另一片树叶的祖先，所以每个叶结点的编码就不可能是其它叶结点编码的前缀</p><p>2.为什么哈夫曼编码能够保证字符编码总长最短?<br>因为哈夫曼树的带权路径长度最短，故字符编码的总长最短。</p><p><strong>性质</strong>1：哈夫曼编码是前缀编码</p><p><strong>性质</strong>2：哈夫曼编码是最优前缀码</p><h5 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreatHuffmanCode</span><span class="params">(HuffmanTree HT, HuffmanCode &amp; HC, <span class="type">int</span> n)</span>{</span><br><span class="line">    <span class="comment">//从叶子到根逆向求每个字符的哈夫曼编码，存储在编码表HC中</span></span><br><span class="line">    <span class="type">int</span> i,cd,start;</span><br><span class="line">    HC=new <span class="type">char</span> *[n+<span class="number">1</span>];<span class="comment">//分配n个字符编码的头指针矢量</span></span><br><span class="line"></span><br><span class="line">    cd=new <span class="type">char</span> [n];<span class="comment">//分配临时存放编码的动态数组空间</span></span><br><span class="line"></span><br><span class="line">    cd[n<span class="number">-1</span>]=<span class="string">'\0’;//编码结束符</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    for(i=1; i&lt;=n; ++i){//逐个字符求哈夫曼编码</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    start=n-1; c=i; f=HT[i].parent;</span></span><br><span class="line"><span class="string">    while(f!=O){//从叶子结点开始向上回溯，直到根结点</span></span><br><span class="line"><span class="string">    --start;//回溯一次start向前指一个位置</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (HT[f].Ichild= =c) cd[start]= '</span>O<span class="string">' ;//结点c是f的左孩子，则生成代码O</span></span><br><span class="line"><span class="string">    else cd[start]= '</span><span class="number">1</span><span class="string">' ;//结点c是f的右孩子，则生成代码1</span></span><br><span class="line"><span class="string">    c=f; f=HT[f].parent;//继续向上回溯</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">//求出第i个字符的编码</span></span><br><span class="line"><span class="string">HC[i]= new char [n-start];//为第i个字符串编码分配空间</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">strcpy(HC[i],&amp;cd[start]);//将求得的编码从临时空间cd复制到HC的当前行中</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">delete cd;//释放临时空间</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">}// CreatHuffanCode</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787941e3c433.png" alt></p><h4 id="4-编码的实现"><a href="#4-编码的实现" class="headerlink" title="4.编码的实现"></a>4.编码的实现</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787942204abe.png" alt></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="/posts/79666db/image-20241107140705475.png" alt="image-20241107140705475"></p><h2 id="八、图"><a href="#八、图" class="headerlink" title="八、图"></a>八、图</h2><h3 id="1-图的定义和基本术语"><a href="#1-图的定义和基本术语" class="headerlink" title="1.图的定义和基本术语"></a>1.图的定义和基本术语</h3><h4 id="1-图的定义"><a href="#1-图的定义" class="headerlink" title="1.图的定义"></a>1.图的定义</h4><p><strong>图</strong>：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="11.03ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4875.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641 490 704Q580 704 633 653 642 643 648 636T656 626L657 623Q660 623 684 649 691 655 699 663T715 679 725 690L740 705H746Q760 705 760 698 760 694 728 561 692 422 692 421 690 416 687 415T669 413H653Q647 419 647 422 647 423 648 429T650 449 651 481Q651 552 619 605T510 659Q492 659 471 656T418 643 357 615 294 567 236 496 189 394 158 260Q156 242 156 221 156 173 170 136T206 79 256 45 308 28 353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271 634 271 659 271T695 272 707 272Q721 272 721 263 721 261 719 249 714 230 709 228 706 227 694 227 674 227 653 224 646 221 643 215T629 164Q620 131 614 108 589 6 586 3 584 1 581 1 571 1 553 21T530 52Q530 53 528 52T522 47Q448-22 322-22 201-22 126 55T50 252Z"/></g><g data-mml-node="mo" transform="translate(1063.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347 722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153 722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(2119.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488 164 576 202 643 244 695 277 729 302 750H315 319Q333 750 333 741 333 738 316 720T275 667 226 581 184 443 167 250 184 58 225-81 274-167 316-220 333-241Q333-250 318-250H315 302L274-226Q180-141 137-14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2508.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mo" transform="translate(3277.6,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(3722.2,0)"><path data-c="1D438" d="M492 213Q472 213 472 226 472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272 690 274 698 274 718 274 718 261 613 7 608 2 605 0 322 0H133Q31 0 31 11 31 13 34 25 38 41 42 43T65 46Q92 46 125 49 139 52 144 61 146 66 215 342T285 622Q285 629 281 629 273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669 764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528 704 558 697 578T678 609 643 625 596 632 532 634H485Q397 633 392 631 388 629 386 622 385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492 572 491 574 487 577 483L544 351Q511 218 508 216 505 213 492 213Z"/></g><g data-mml-node="mo" transform="translate(4486.2,0)"><path data-c="29" d="M60 749 64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12 224-76 186-143 145-194 113-227 90-246Q87-249 86-250H74Q66-250 63-250T58-247 55-238Q56-237 66-225 221-64 221 250T66 725Q56 737 55 738 55 746 60 749Z"/></g></g></g></svg></mjx-container></p><p>​ V:顶点（数据元素）的有穷非空集合</p><p>​ E:边的有穷集合</p><p><strong>无向图</strong>：每条边都没有方向</p><p><strong>有向图</strong>:每条边都有方向</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67879425ebfd5.png" alt></p><p><strong>完全图</strong>：任意两个点都有一条边相连</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678794278b7c5.png" alt></p><p><strong>稀疏图</strong>：有很少边或弧的图（e&lt;nlogn)</p><p><strong>稠密图</strong>：有较多边或弧的图</p><p><strong>网</strong>：边/弧带权的图</p><p><strong>邻接</strong>:有边/弧相连的两个顶点之间的关系。</p><p>​ 存在<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.666ex" xmlns="http://www.w3.org/2000/svg" width="6.547ex" height="2.363ex" role="img" focusable="false" viewbox="0 -750 2893.9 1044.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488 164 576 202 643 244 695 277 729 302 750H315 319Q333 750 333 741 333 738 316 720T275 667 226 581 184 443 167 250 184 58 225-81 274-167 316-220 333-241Q333-250 318-250H315 302L274-226Q180-141 137-14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405 130 405 104 376T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287 21 294 29 316T53 368 97 419 160 441Q202 441 225 417T249 361Q249 344 246 335 246 329 231 291T200 202 182 113Q182 86 187 69 200 26 250 26 287 26 319 60T369 139 398 222 409 277Q409 300 401 317T383 343 365 361 357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159 347 40 241-11Q177-11 139 22 102 54 102 117 102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(1201,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1645.6,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405 130 405 104 376T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287 21 294 29 316T53 368 97 419 160 441Q202 441 225 417T249 361Q249 344 246 335 246 329 231 291T200 202 182 113Q182 86 187 69 200 26 250 26 287 26 319 60T369 139 398 222 409 277Q409 300 401 317T383 343 365 361 357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159 347 40 241-11Q177-11 139 22 102 54 102 117 102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405 240 405 220 393T185 362 161 325 144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432 341 418 354 401T367 348V332L318 133Q267-67 264-75 246-125 194-164T75-204Q25-204 7-183T-12-137Q-12-110 7-91T53-71Q70-71 82-81T95-112Q95-148 63-167 69-168 77-168 111-168 139-140T182-74L193-32Q204 11 219 72T251 197 278 308 289 365Q289 372 288 376Z"/></g></g><g data-mml-node="mo" transform="translate(2504.9,0)"><path data-c="29" d="M60 749 64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12 224-76 186-143 145-194 113-227 90-246Q87-249 86-250H74Q66-250 63-250T58-247 55-238Q56-237 66-225 221-64 221 250T66 725Q56 737 55 738 55 746 60 749Z"/></g></g></g></svg></mjx-container>，则称<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.357ex" xmlns="http://www.w3.org/2000/svg" width="1.837ex" height="1.359ex" role="img" focusable="false" viewbox="0 -443 812 600.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405 130 405 104 376T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287 21 294 29 316T53 368 97 419 160 441Q202 441 225 417T249 361Q249 344 246 335 246 329 231 291T200 202 182 113Q182 86 187 69 200 26 250 26 287 26 319 60T369 139 398 222 409 277Q409 300 401 317T383 343 365 361 357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159 347 40 241-11Q177-11 139 22 102 54 102 117 102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.666ex" xmlns="http://www.w3.org/2000/svg" width="1.944ex" height="1.668ex" role="img" focusable="false" viewbox="0 -443 859.3 737.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405 130 405 104 376T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287 21 294 29 316T53 368 97 419 160 441Q202 441 225 417T249 361Q249 344 246 335 246 329 231 291T200 202 182 113Q182 86 187 69 200 26 250 26 287 26 319 60T369 139 398 222 409 277Q409 300 401 317T383 343 365 361 357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159 347 40 241-11Q177-11 139 22 102 54 102 117 102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405 240 405 220 393T185 362 161 325 144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432 341 418 354 401T367 348V332L318 133Q267-67 264-75 246-125 194-164T75-204Q25-204 7-183T-12-137Q-12-110 7-91T53-71Q70-71 82-81T95-112Q95-148 63-167 69-168 77-168 111-168 139-140T182-74L193-32Q204 11 219 72T251 197 278 308 289 365Q289 372 288 376Z"/></g></g></g></g></svg></mjx-container>;互为<strong>邻接点</strong>;(无向图)</p><p>​ 存在$<v_i , v_j>$，则称v<strong>邻接到</strong><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.666ex" xmlns="http://www.w3.org/2000/svg" width="1.944ex" height="1.668ex" role="img" focusable="false" viewbox="0 -443 859.3 737.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405 130 405 104 376T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287 21 294 29 316T53 368 97 419 160 441Q202 441 225 417T249 361Q249 344 246 335 246 329 231 291T200 202 182 113Q182 86 187 69 200 26 250 26 287 26 319 60T369 139 398 222 409 277Q409 300 401 317T383 343 365 361 357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159 347 40 241-11Q177-11 139 22 102 54 102 117 102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405 240 405 220 393T185 362 161 325 144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432 341 418 354 401T367 348V332L318 133Q267-67 264-75 246-125 194-164T75-204Q25-204 7-183T-12-137Q-12-110 7-91T53-71Q70-71 82-81T95-112Q95-148 63-167 69-168 77-168 111-168 139-140T182-74L193-32Q204 11 219 72T251 197 278 308 289 365Q289 372 288 376Z"/></g></g></g></g></svg></mjx-container>,<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.666ex" xmlns="http://www.w3.org/2000/svg" width="1.944ex" height="1.668ex" role="img" focusable="false" viewbox="0 -443 859.3 737.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405 130 405 104 376T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287 21 294 29 316T53 368 97 419 160 441Q202 441 225 417T249 361Q249 344 246 335 246 329 231 291T200 202 182 113Q182 86 187 69 200 26 250 26 287 26 319 60T369 139 398 222 409 277Q409 300 401 317T383 343 365 361 357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159 347 40 241-11Q177-11 139 22 102 54 102 117 102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405 240 405 220 393T185 362 161 325 144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432 341 418 354 401T367 348V332L318 133Q267-67 264-75 246-125 194-164T75-204Q25-204 7-183T-12-137Q-12-110 7-91T53-71Q70-71 82-81T95-112Q95-148 63-167 69-168 77-168 111-168 139-140T182-74L193-32Q204 11 219 72T251 197 278 308 289 365Q289 372 288 376Z"/></g></g></g></g></svg></mjx-container><strong>邻接于</strong><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.357ex" xmlns="http://www.w3.org/2000/svg" width="1.837ex" height="1.359ex" role="img" focusable="false" viewbox="0 -443 812 600.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405 130 405 104 376T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287 21 294 29 316T53 368 97 419 160 441Q202 441 225 417T249 361Q249 344 246 335 246 329 231 291T200 202 182 113Q182 86 187 69 200 26 250 26 287 26 319 60T369 139 398 222 409 277Q409 300 401 317T383 343 365 361 357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159 347 40 241-11Q177-11 139 22 102 54 102 117 102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>(有向图)</v_i></p><p><strong>关联</strong>：边/弧与顶点的关系</p><p>​ 存在$(V_i,V_j)/<v_i ,v_j><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="19.231ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 8500 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">称</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">为</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">该</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">边</text></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(4000,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92-240Q85-250 75-250 68-250 62-245T56-231Q56-221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mi" transform="translate(4500,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">弧</text></g><g data-mml-node="mi" transform="translate(5500,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">关</text></g><g data-mml-node="mi" transform="translate(6500,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">联</text></g><g data-mml-node="mi" transform="translate(7500,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">于</text></g></g></g></svg></mjx-container>v_i<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.452ex" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="2.149ex" role="img" focusable="false" viewbox="0 -750 1000 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">和</text></g></g></g></svg></mjx-container>v_j$</v_i></p><p><strong>顶点的度</strong>:与该顶点相关联的边的数目，记为TD(v)</p><p>在有向图中，顶点的度等于该顶点的入度与出度之和。</p><p>顶点v的入度是以v为终点的有向边的条数,记作ID(v)</p><p>顶点v的出度是以v为始点的有向边的条数,记作OD(v)</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787942ab13d1.png" alt></p><p><strong>路径</strong>：接续的边构成的顶点序列</p><p><strong>路径长度</strong>:路径上边或弧的数目/权值之和。<br><strong>回路(环)</strong>:第一个顶点和最后一个顶点相同的路径。<br><strong>简单路径</strong>:除路径起点和终点可以相同外，其余顶点均不相同的路径。</p><p><strong>简单回路(简单环)</strong>:除路径起点和终点相同外，其余顶点均不相同的路径。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787942d83864.png" alt></p><p><strong>连通图(强连通图)</strong><br>在无(有)向图<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="11.03ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4875.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641 490 704Q580 704 633 653 642 643 648 636T656 626L657 623Q660 623 684 649 691 655 699 663T715 679 725 690L740 705H746Q760 705 760 698 760 694 728 561 692 422 692 421 690 416 687 415T669 413H653Q647 419 647 422 647 423 648 429T650 449 651 481Q651 552 619 605T510 659Q492 659 471 656T418 643 357 615 294 567 236 496 189 394 158 260Q156 242 156 221 156 173 170 136T206 79 256 45 308 28 353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271 634 271 659 271T695 272 707 272Q721 272 721 263 721 261 719 249 714 230 709 228 706 227 694 227 674 227 653 224 646 221 643 215T629 164Q620 131 614 108 589 6 586 3 584 1 581 1 571 1 553 21T530 52Q530 53 528 52T522 47Q448-22 322-22 201-22 126 55T50 252Z"/></g><g data-mml-node="mo" transform="translate(1063.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347 722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153 722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(2119.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488 164 576 202 643 244 695 277 729 302 750H315 319Q333 750 333 741 333 738 316 720T275 667 226 581 184 443 167 250 184 58 225-81 274-167 316-220 333-241Q333-250 318-250H315 302L274-226Q180-141 137-14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2508.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mo" transform="translate(3277.6,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3722.2,0)"><g data-mml-node="mi"><path data-c="1D438" d="M492 213Q472 213 472 226 472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272 690 274 698 274 718 274 718 261 613 7 608 2 605 0 322 0H133Q31 0 31 11 31 13 34 25 38 41 42 43T65 46Q92 46 125 49 139 52 144 61 146 66 215 342T285 622Q285 629 281 629 273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669 764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528 704 558 697 578T678 609 643 625 596 632 532 634H485Q397 633 392 631 388 629 386 622 385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492 572 491 574 487 577 483L544 351Q511 218 508 216 505 213 492 213Z"/></g></g><g data-mml-node="mo" transform="translate(4486.2,0)"><path data-c="29" d="M60 749 64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12 224-76 186-143 145-194 113-227 90-246Q87-249 86-250H74Q66-250 63-250T58-247 55-238Q56-237 66-225 221-64 221 250T66 725Q56 737 55 738 55 746 60 749Z"/></g></g></g></svg></mjx-container>中，若对任何两个顶点v、u都右在从v至到u的路径称G是连通图(裾连通图)</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787941b2437f.png" alt></p><p><strong>权与网</strong><br>图中边或弧所具有的相关数称为<strong>权</strong>。表明从一个顶点到另一个顶点的距离或耗费。<br>带权的图称为<strong>网</strong>。</p><p><strong>子图</strong><br>设有两个图G= (V，{E})、G1= (V1，{E1})，若V1⊆V,E1⊆E,则称G1是G的子图</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787942529a87.png" alt></p><p><strong>连通分量（强连通分量)</strong><br>无向图G的<strong>极大连通子图</strong>称为G的<strong>连通分量</strong>。<br>极大连通子图意思是:该子图是G连通子图，将G的任何不在该子图中的顶点加入，子图不再连通。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67879426d0a67.png" alt></p><p>有向图G的极大强连通子图称为G的<strong>强连通分量</strong></p><p>极大强连通子图意思是:该子图是G的强连通子图，将D的任何不在该子图中的顶点加入，子图不再是强连通的。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787942986223.png" alt></p><p><strong>极小连通子图:</strong>该子图是G的连通子图，在该子图中删除任何一天边子图不再连通。<br><strong>生成树:</strong>包含无向图G所有顶点的极小连通子图。<br><strong>生成森林:</strong>对非连通图，由各个连通分量的生成树的集合。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787942c4d4bf.png" alt></p><h3 id="2-图的类型定义"><a href="#2-图的类型定义" class="headerlink" title="2.图的类型定义"></a>2.图的类型定义</h3><h4 id="1-图的抽象数据类型定义如下"><a href="#1-图的抽象数据类型定义如下" class="headerlink" title="1.图的抽象数据类型定义如下:"></a>1.图的抽象数据类型定义如下:</h4><p>ADT Graph{<br><strong>数据对象V</strong>:具有相同特性的数据元素的集合，称为<strong>顶点集。</strong><br><strong>数据关系R:</strong> R={VR}<br>VR={<v ,w>|<v ,w>| v,w⊆V ^ p(v,w),<br><v ,w>表示从v到w的弧，P(v,w)定义了弧<v ,w>的信息</v></v></v></v></p><p>}</p><h4 id="2-图的操作"><a href="#2-图的操作" class="headerlink" title="2. 图的操作"></a>2. 图的操作</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787942e7d7a5.png" alt></p><h4 id="3-图的存储结构"><a href="#3-图的存储结构" class="headerlink" title="3.图的存储结构"></a>3.图的存储结构</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67879430f2beb.png" alt></p><h5 id="1-数组（邻接矩阵）表示法"><a href="#1-数组（邻接矩阵）表示法" class="headerlink" title="1.数组（邻接矩阵）表示法"></a>1.数组（邻接矩阵）表示法</h5><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67879433a04b1.png" alt></p><h6 id="无向图邻接矩阵"><a href="#无向图邻接矩阵" class="headerlink" title="无向图邻接矩阵"></a>无向图邻接矩阵</h6><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787942388289.png" alt></p><p>分析1：无向图的邻接矩阵是对称的</p><p>分析2：顶点i的度=第i行（列）中的1的个数</p><p>特别：完全的邻接矩阵中，对角元素为0，其余为1</p><h6 id="有向图的邻接矩阵"><a href="#有向图的邻接矩阵" class="headerlink" title="有向图的邻接矩阵"></a>有向图的邻接矩阵</h6><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787942b60b70.png" alt></p><p>分析1：有向图的邻接矩阵可能不是对称的</p><p>分析2：顶点的出度=第i行元素之和（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.339ex" xmlns="http://www.w3.org/2000/svg" width="2.307ex" height="1.885ex" role="img" focusable="false" viewbox="0 -683 1019.6 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mn" transform="translate(616,-150) scale(0.707)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g></g></g></g></svg></mjx-container>指向&amp;V_2&amp; 和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.375ex" xmlns="http://www.w3.org/2000/svg" width="2.307ex" height="1.92ex" role="img" focusable="false" viewbox="0 -683 1019.6 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mn" transform="translate(616,-150) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664 351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336 375 315Q457 262 457 175 457 96 395 37T238-22Q158-22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94 148 82 136 74 126 70 118 67L114 66Q165 21 238 21 293 21 321 74 338 107 338 175V195Q338 290 274 322 259 328 213 329L171 330 168 332Q166 335 166 348 166 366 174 366 202 366 232 371 266 376 294 413T322 525V533Q322 590 287 612 265 626 240 626 208 626 181 615T143 592 132 580H135Q138 579 143 578T153 573 165 566 175 555 183 540 186 520Q186 498 172 481T127 463Z"/></g></g></g></g></svg></mjx-container>）</p><p>顶点的出度=第i列元素之和</p><p>​ 顶点的度=第i行元素之和+第i列元素之和</p><h5 id="有向网的邻接矩阵"><a href="#有向网的邻接矩阵" class="headerlink" title="有向网的邻接矩阵"></a>有向网的邻接矩阵</h5><p>网（即有权图)的邻接矩阵表示法</p><p>定义为</p><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="20.403ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 9018 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46 272 46 272 35 272 34 270 22 267 8 264 4T251 0Q249 0 239 0T205 1 141 2Q70 2 50 0H42Q35 7 35 11 37 38 48 46H62Q132 49 164 96 170 102 345 401T523 704Q530 716 547 716H555 572Q578 707 578 706L606 383Q634 60 636 57 641 46 701 46 726 46 726 36 726 34 723 22 720 7 718 4T704 0Q701 0 690 0T651 1 578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260 413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(750,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0 96 17 78 60Z"/></g><g data-mml-node="mi" transform="translate(1194.7,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392 386 422 416 422 429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35 443 55 463 131 469 151 473 152 475 153 483 153H487Q506 153 506 144 506 138 501 117T481 63 449 13Q436 0 417-8 409-10 393-10 359-10 336 5T306 36L300 51Q299 52 296 50 294 48 292 46 233-10 172-10 117-10 75 30T33 157ZM351 328Q351 334 346 350T323 385 277 405Q242 405 210 374T160 293Q131 214 119 129 119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(1723.7,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317 38 348 53 381 73 411 99 433 132 442Q161 442 183 430T214 408 225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400 430 381 430 363 430 333 417 315T391 292 366 288Q346 288 334 299T322 328Q322 376 378 392 356 405 342 405 286 405 239 331 229 315 224 298T190 165Q156 25 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 114 189T154 366Q154 405 128 405 107 405 92 377T68 316 57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(2174.7,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325 330 359 352 380 366 386H367Q367 388 361 392T340 400 306 404Q276 404 249 390 228 381 206 359 162 315 142 235T121 119Q121 73 147 50 169 26 205 26H209Q321 26 394 111 403 121 406 121 410 121 419 112T429 98 420 83 391 55 346 25 282 0 202-11Q127-11 81 37T34 159Z"/></g><g data-mml-node="mi" transform="translate(2607.7,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415 300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372 367 378Q368 378 368 379 368 382 361 388T336 399 297 405Q249 405 227 379T204 326Q204 301 223 291T278 274 330 259Q396 230 396 163 396 135 385 107T352 51 289 7 195-10Q118-10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34 201 27Q237 27 263 38T301 66 318 97 323 122Q323 150 302 164T254 181 195 196 148 231Q131 256 131 289Z"/></g><g data-mml-node="mo" transform="translate(3076.7,0)"><path data-c="5B" d="M118-250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(3354.7,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3699.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(3977.7,0)"><path data-c="5B" d="M118-250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(4255.7,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405 240 405 220 393T185 362 161 325 144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432 341 418 354 401T367 348V332L318 133Q267-67 264-75 246-125 194-164T75-204Q25-204 7-183T-12-137Q-12-110 7-91T53-71Q70-71 82-81T95-112Q95-148 63-167 69-168 77-168 111-168 139-140T182-74L193-32Q204 11 219 72T251 197 278 308 289 365Q289 372 288 376Z"/></g><g data-mml-node="mo" transform="translate(4667.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(5223.4,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347 722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153 722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(6279.2,0)"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674 695 670 692 659 687 641 683 639T661 637Q636 636 621 632T600 624 597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170 666 200 690 241 720 295 759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647 817 650 819 660 823 676 825 679T839 682Q842 682 856 682T895 682 949 681Q1015 681 1034 683 1048 683 1048 672 1048 666 1045 655T1038 640 1028 637Q1006 637 988 631T958 617 939 600 927 584L923 578 754 282Q586-14 585-15 579-22 561-22 546-22 542-17 539-14 523 229T506 480L494 462Q472 425 366 239 222-13 220-15T215-19Q210-22 197-22 178-22 176-15 176-12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648 52 671 64 683H76Q118 680 176 680 301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620 262 160 266 136L501 550 499 587Q496 629 489 632 483 636 447 637 428 637 422 639T416 648Q416 650 418 660 419 664 420 669T421 676 424 680 428 682 436 683Z"/></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mi" transform="translate(7550.2,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405 240 405 220 393T185 362 161 325 144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432 341 418 354 401T367 348V332L318 133Q267-67 264-75 246-125 194-164T75-204Q25-204 7-183T-12-137Q-12-110 7-91T53-71Q70-71 82-81T95-112Q95-148 63-167 69-168 77-168 111-168 139-140T182-74L193-32Q204 11 219 72T251 197 278 308 289 365Q289 372 288 376Z"/></g><g data-mml-node="mo" transform="translate(8240,0)"><path data-c="3C" d="M694-11T694-19 688-33 678-40Q671-40 524 29T234 166L90 235Q83 240 83 250 83 261 91 266 664 540 678 540 681 540 687 534T694 519 687 505Q686 504 417 376L151 250 417 124Q686-4 687-5 694-11 694-19Z"/></g></g></g></svg></mjx-container>V_i<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.439ex" xmlns="http://www.w3.org/2000/svg" width="0.629ex" height="0.713ex" role="img" focusable="false" viewbox="0 -121 278 315"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g></g></g></svg></mjx-container>V_j<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="5.531ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2444.8 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107-40H101Q83-38 83-20 83-19 83-17 82-10 98-1 117 9 248 71 326 108 378 132L626 250 378 368Q90 504 86 509 84 513 84 520Z"/></g><g data-mml-node="mi" transform="translate(1055.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">或</text></g><g data-mml-node="mo" transform="translate(2055.8,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488 164 576 202 643 244 695 277 729 302 750H315 319Q333 750 333 741 333 738 316 720T275 667 226 581 184 443 167 250 184 58 225-81 274-167 316-220 333-241Q333-250 318-250H315 302L274-226Q180-141 137-14T94 250Z"/></g></g></g></svg></mjx-container>V_i,V_j<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="6.951ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3072.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="29" d="M60 749 64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12 224-76 186-143 145-194 113-227 90-246Q87-249 86-250H74Q66-250 63-250T58-247 55-238Q56-237 66-225 221-64 221 250T66 725Q56 737 55 738 55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(666.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">∊</text></g><g data-mml-node="mi" transform="translate(1544.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(2313.6,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682 206 683 378 683 550 682 564 680 620 672 658 652T712 606 733 563 739 529Q739 484 710 445T643 385 576 351 538 338L545 333Q612 295 612 223 612 212 607 162T602 80V71Q602 53 603 43T614 25 640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93 755 75 731 36 693-21 641-21H632Q571-21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313 459 320 449 321T378 323H309L277 193Q244 61 244 59 244 55 245 54T252 50 269 48 302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2 146 2 117 2T71 2 50 1Q33 1 33 10 33 12 36 24 41 43 46 45 50 46 61 46H67Q94 46 127 49 141 52 146 61 149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627 385 624 352 494T319 361Q319 360 388 360 466 361 492 367 556 377 592 426 608 449 619 486T630 554Z"/></g></g></g></svg></mjx-container></p><p>​<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.452ex" xmlns="http://www.w3.org/2000/svg" width="9.05ex" height="2.149ex" role="img" focusable="false" viewbox="0 -750 4000 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="221E" d="M55 217Q55 305 111 373T254 442Q342 442 419 381 457 350 493 303L507 284 514 294Q618 442 747 442 833 442 888 374T944 214Q944 128 889 59T743-11Q657-11 580 50 542 81 506 128L492 147 485 137Q381-11 252-11 166-11 111 57T55 217ZM907 217Q907 285 869 341T761 397Q740 397 720 392T682 378 648 359 619 335 594 310 574 285 559 263 548 246L543 238 574 198Q605 158 622 138T664 94 714 61 765 51Q827 51 867 100T907 217ZM92 214Q92 145 131 89T239 33Q357 33 456 193L425 233Q364 312 334 337 285 380 233 380 171 380 132 331T92 214Z"/></g></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">无</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">边</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">弧</text></g></g></g></svg></mjx-container></p><p>如果两个顶点之间存在弧或边，那么我就记录两个顶点为权<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.462ex" xmlns="http://www.w3.org/2000/svg" width="3.808ex" height="2.007ex" role="img" focusable="false" viewbox="0 -683 1683 887"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674 695 670 692 659 687 641 683 639T661 637Q636 636 621 632T600 624 597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170 666 200 690 241 720 295 759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647 817 650 819 660 823 676 825 679T839 682Q842 682 856 682T895 682 949 681Q1015 681 1034 683 1048 683 1048 672 1048 666 1045 655T1038 640 1028 637Q1006 637 988 631T958 617 939 600 927 584L923 578 754 282Q586-14 585-15 579-22 561-22 546-22 542-17 539-14 523 229T506 480L494 462Q472 425 366 239 222-13 220-15T215-19Q210-22 197-22 178-22 176-15 176-12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648 52 671 64 683H76Q118 680 176 680 301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620 262 160 266 136L501 550 499 587Q496 629 489 632 483 636 447 637 428 637 422 639T416 648Q416 650 418 660 419 664 420 669T421 676 424 680 428 682 436 683Z"/></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mi" transform="translate(1271,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405 240 405 220 393T185 362 161 325 144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432 341 418 354 401T367 348V332L318 133Q267-67 264-75 246-125 194-164T75-204Q25-204 7-183T-12-137Q-12-110 7-91T53-71Q70-71 82-81T95-112Q95-148 63-167 69-168 77-168 111-168 139-140T182-74L193-32Q204 11 219 72T251 197 278 308 289 365Q289 372 288 376Z"/></g></g></g></svg></mjx-container>，如果不存在则记录无穷大</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787942f9fb6c.png" alt></p><h4 id="2-邻接矩阵的存储形式"><a href="#2-邻接矩阵的存储形式" class="headerlink" title="2.邻接矩阵的存储形式"></a>2.邻接矩阵的存储形式</h4><h6 id="1-用两个数组分别存储顶点表和邻接矩阵"><a href="#1-用两个数组分别存储顶点表和邻接矩阵" class="headerlink" title="1.用两个数组分别存储顶点表和邻接矩阵"></a>1.用两个数组分别存储顶点表和邻接矩阵</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100 <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;<span class="comment">//设顶点的娄文据类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;<span class="comment">//假设边的权值类型为整型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line">VerTexType vexs[MVNum]; <span class="comment">//顶点表</span></span><br><span class="line">ArcType arcs[MVNum][MVNum]; <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前点数和边数</span></span><br><span class="line">}AMGraph; <span class="comment">// Adjacency Matrix Graph</span></span><br></pre></td></tr></table></figure><h5 id="2-采用邻接矩阵表示法创建无向网"><a href="#2-采用邻接矩阵表示法创建无向网" class="headerlink" title="2.采用邻接矩阵表示法创建无向网"></a>2.采用邻接矩阵表示法创建无向网</h5><h6 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h6><p>​ (1)输入总顶点数和总边数。</p><p>(2)依次输点的信息存人顶点表中。</p><p>（3）初始化邻接矩阵，使每个权值初始化为极大值。</p><p>（4）构造邻接矩阵</p><p>代码先欠着</p><h5 id="3-邻接矩阵的好处和坏处"><a href="#3-邻接矩阵的好处和坏处" class="headerlink" title="3.邻接矩阵的好处和坏处"></a>3.邻接矩阵的好处和坏处</h5><h6 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h6><ul><li>直观、简单、好理解</li><li>方便检查任意一对顶点间是否存在边</li><li>方便找任一顶点的所有“邻接点”(有边直接相连的顶点)</li><li>方便计算任一顶点的“度”(从该点发出的边数为“出度”，指向该点的边数为“入度”)·无向图:对应行（或列)非O元素的个数·有向图:对应行非0元素的个数是“出度”;对应列非0元素的个数是“入度”</li></ul><h6 id="坏处"><a href="#坏处" class="headerlink" title="坏处"></a>坏处</h6><ul><li>不便于增加和删除顶点</li><li><p>浪费空间——传稀疏图人点很多而边很少）有大量无效元素</p></li><li><p>​ 对稠密图（特别是完全图)还是很合算的</p></li><li><p>浪费时间——统计稀疏图中一共有多少条边</p></li></ul><h4 id="3-邻接表表示法（链式）"><a href="#3-邻接表表示法（链式）" class="headerlink" title="3.邻接表表示法（链式）"></a>3.邻接表表示法（链式）</h4><h5 id="1-无向图的邻接表"><a href="#1-无向图的邻接表" class="headerlink" title="1.无向图的邻接表"></a>1.无向图的邻接表</h5><ul><li>·顶点:</li></ul><p>​ ·按编号顺序将顶点数据存储在一维数组中;·</p><ul><li><p>关联同一顶点的边(以顶点为尾的弧)︰</p><p>​ ·用线性链表存储</p></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67879431dfaa6.png" alt></p><p>data表示顶点本身，firstarc表示第一条边的指针（以v1为例子，下标为3或为1的元素的指针）adjvex表示邻接的顶点，nextarc表示下一元素的指针</p><h6 id="特点-3"><a href="#特点-3" class="headerlink" title="特点:"></a>特点:</h6><ul><li>·邻接表不唯一</li><li>·若无向图中有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.025ex" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>个顶点、<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.025ex" xmlns="http://www.w3.org/2000/svg" width="1.054ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 466 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350 174 402 244 433 307 442H310Q355 442 388 420T421 355Q421 265 310 237 261 224 176 223 139 223 138 221 138 219 132 186T125 128Q125 81 146 54T209 26 302 45 394 111Q403 121 406 121 410 121 419 112T429 98 420 82 390 55 344 24 281-1 205-11Q126-11 83 42T39 168ZM373 353Q367 405 305 405 272 405 244 391T199 357 170 316 154 280 149 261Q149 260 169 260 282 260 327 284T373 353Z"/></g></g></g></svg></mjx-container>条边，则其邻接表需<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.025ex" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>个头结点和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.025ex" xmlns="http://www.w3.org/2000/svg" width="2.186ex" height="1.532ex" role="img" focusable="false" viewbox="0 -666 966 677"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315 301 241Q265 210 201 149L142 93 218 92Q375 92 385 97 392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19 31Q50 38 56 46T86 81Q115 113 136 137 145 147 170 174T204 211 233 244 261 278 284 308 305 340 320 369 333 401 340 431 343 464Q343 527 309 573T212 619Q179 619 154 602T119 569 109 550Q109 549 114 549 132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350 174 402 244 433 307 442H310Q355 442 388 420T421 355Q421 265 310 237 261 224 176 223 139 223 138 221 138 219 132 186T125 128Q125 81 146 54T209 26 302 45 394 111Q403 121 406 121 410 121 419 112T429 98 420 82 390 55 344 24 281-1 205-11Q126-11 83 42T39 168ZM373 353Q367 405 305 405 272 405 244 391T199 357 170 316 154 280 149 261Q149 260 169 260 282 260 327 284T373 353Z"/></g></g></g></svg></mjx-container>个表结点。适宜存储稀疏图。</li><li>无向图中顶点v的度为第i个单链表中的结点数。</li></ul><h5 id="2-有向图"><a href="#2-有向图" class="headerlink" title="2.有向图"></a>2.有向图</h5><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67879433da3c4.png" alt></p><h6 id="特点-4"><a href="#特点-4" class="headerlink" title="特点:"></a>特点:</h6><blockquote><p>顶点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.357ex" xmlns="http://www.w3.org/2000/svg" width="2.059ex" height="1.902ex" role="img" focusable="false" viewbox="0 -683 910 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>的<strong>出度</strong>为第i个单链表中的结点个数。<br>顶点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.357ex" xmlns="http://www.w3.org/2000/svg" width="2.059ex" height="1.902ex" role="img" focusable="false" viewbox="0 -683 910 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>的<strong>入度</strong>为整个单链表中邻接点域值是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.186ex" xmlns="http://www.w3.org/2000/svg" width="4.677ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 2067.4 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(567.2,0)"><path data-c="2212" d="M84 237T84 250 98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1567.4,0)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g></g></g></svg></mjx-container>的结点个数。</p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678794361386e.png" alt></p><h5 id="3-链式代码"><a href="#3-链式代码" class="headerlink" title="3.链式代码"></a>3.链式代码</h5><h6 id="1-定义代码"><a href="#1-定义代码" class="headerlink" title="1.定义代码"></a>1.定义代码</h6><p>顶点</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>{</span></span><br><span class="line">    </span><br><span class="line">    VerTexType data;<span class="comment">//顶点信息--类型自义定</span></span><br><span class="line">    ArcNode * firstarc;<span class="comment">//指向第一条依附该顶点的边的指针</span></span><br><span class="line">    </span><br><span class="line">}VNode,AdjList[MVNum]; <span class="comment">//AdjList表示邻接表类型,MVNUM为最大数组数</span></span><br></pre></td></tr></table></figure><p>边结点</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>{</span><span class="comment">//边结点</span></span><br><span class="line"><span class="type">int</span> adjvex;<span class="comment">//该边所指向的顶点的位置</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> * <span class="title">nextarc</span>;</span><span class="comment">//指向下一条边的指针</span></span><br><span class="line">OtherInfo info;<span class="comment">//和边相关的信息</span></span><br><span class="line">}ArcNode;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678794396b6bc.png" alt></p><p>图结点</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">     AdjList vertices;<span class="comment">//vertices--vertex的复数顶点数组</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">} ALGraph;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787943ca4c9e.png" alt></p><h6 id="2-采用邻接表表示法创建无向网的算法思想"><a href="#2-采用邻接表表示法创建无向网的算法思想" class="headerlink" title="2.采用邻接表表示法创建无向网的算法思想"></a>2.采用邻接表表示法创建无向网的算法思想</h6><p>【算法思想】</p><ol><li>输入总顶点数和总边数。</li><li>建立顶点表<br>依次输入点的信息存入顶点表中<br>使每个表头结点的指针域初始化为NULL</li><li>创建邻接表<br>依次输入每条边依附的两个顶点确定两个顶点的序号i和j，建立边结点<br>将此边结点分别插入到<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.357ex" xmlns="http://www.w3.org/2000/svg" width="2.059ex" height="1.902ex" role="img" focusable="false" viewbox="0 -683 910 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.666ex" xmlns="http://www.w3.org/2000/svg" width="2.166ex" height="2.211ex" role="img" focusable="false" viewbox="0 -683 957.3 977.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405 240 405 220 393T185 362 161 325 144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432 341 418 354 401T367 348V332L318 133Q267-67 264-75 246-125 194-164T75-204Q25-204 7-183T-12-137Q-12-110 7-91T53-71Q70-71 82-81T95-112Q95-148 63-167 69-168 77-168 111-168 139-140T182-74L193-32Q204 11 219 72T251 197 278 308 289 365Q289 372 288 376Z"/></g></g></g></g></svg></mjx-container>对应的两个边链表的头部</li></ol><h4 id="5-邻接表的特点"><a href="#5-邻接表的特点" class="headerlink" title="5.邻接表的特点"></a>5.邻接表的特点</h4><h5 id="1-特点"><a href="#1-特点" class="headerlink" title="1.特点"></a>1.特点</h5><ul><li><p>·方便找任一顶点的所有“邻接点”</p></li><li><p>·节约稀疏图的空间</p><p>​ 需要N个头指针＋2E个结点(每个结点至少2个域)·</p></li><li><p>方便计算任一顶点的“度”?</p><pre><code>对无向图:是的
</code></pre><p>对有向图:只能计算“出度”;需要构造“逆邻接表”(存指向自己的边)来方便计算入度”</p></li><li><p>·不方便检查任意、对顶点间是否存在边</p></li></ul><h4 id="4-邻接矩阵与邻接表表示方法的关系"><a href="#4-邻接矩阵与邻接表表示方法的关系" class="headerlink" title="4.邻接矩阵与邻接表表示方法的关系"></a>4.邻接矩阵与邻接表表示方法的关系</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787943e9e6a3.png" alt></p><h5 id="2-联系"><a href="#2-联系" class="headerlink" title="2.联系:"></a>2.<strong>联系:</strong></h5><p>邻接表中每个链表对应于邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数。</p><h5 id="2-区别"><a href="#2-区别" class="headerlink" title="2.区别:"></a>2.区别:</h5><p>对于任一确定的无向图，邻接矩阵是唯一的(行列号与顶点编号一致)，但邻接表不唯一（链接次序与顶点编号无关）。</p><p>邻接矩阵的空间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewbox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42 304-22Q207-22 138 35T51 201Q50 209 50 244 50 346 98 438T227 601Q351 704 476 704 514 704 524 703 621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605 242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488 164 576 202 643 244 695 277 729 302 750H315 319Q333 750 333 741 333 738 316 720T275 667 226 581 184 443 167 250 184 58 225-81 274-167 316-220 333-241Q333-250 318-250H315 302L274-226Q180-141 137-14T94 250Z"/></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315 301 241Q265 210 201 149L142 93 218 92Q375 92 385 97 392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19 31Q50 38 56 46T86 81Q115 113 136 137 145 147 170 174T204 211 233 244 261 278 284 308 305 340 320 369 333 401 340 431 343 464Q343 527 309 573T212 619Q179 619 154 602T119 569 109 550Q109 549 114 549 132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749 64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12 224-76 186-143 145-194 113-227 90-246Q87-249 86-250H74Q66-250 63-250T58-247 55-238Q56-237 66-225 221-64 221 250T66 725Q56 737 55 738 55 746 60 749Z"/></g></g></g></svg></mjx-container>,而邻接表的空间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="8.664ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3829.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42 304-22Q207-22 138 35T51 201Q50 209 50 244 50 346 98 438T227 601Q351 704 476 704 514 704 524 703 621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605 242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488 164 576 202 643 244 695 277 729 302 750H315 319Q333 750 333 741 333 738 316 720T275 667 226 581 184 443 167 250 184 58 225-81 274-167 316-220 333-241Q333-250 318-250H315 302L274-226Q180-141 137-14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1974.2,0)"><path data-c="2B" d="M56 237T56 250 70 270H369V420L370 570Q380 583 389 583 402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401-82 391-82H389 387Q375-82 369-68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(2974.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350 174 402 244 433 307 442H310Q355 442 388 420T421 355Q421 265 310 237 261 224 176 223 139 223 138 221 138 219 132 186T125 128Q125 81 146 54T209 26 302 45 394 111Q403 121 406 121 410 121 419 112T429 98 420 82 390 55 344 24 281-1 205-11Q126-11 83 42T39 168ZM373 353Q367 405 305 405 272 405 244 391T199 357 170 316 154 280 149 261Q149 260 169 260 282 260 327 284T373 353Z"/></g><g data-mml-node="mo" transform="translate(3440.4,0)"><path data-c="29" d="M60 749 64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12 224-76 186-143 145-194 113-227 90-246Q87-249 86-250H74Q66-250 63-250T58-247 55-238Q56-237 66-225 221-64 221 250T66 725Q56 737 55 738 55 746 60 749Z"/></g></g></g></svg></mjx-container></p><h5 id="3-用途"><a href="#3-用途" class="headerlink" title="3.用途:"></a>3.用途:</h5><p>邻接矩阵多用于榈密图;而邻接表多用于稀疏图</p><h4 id="5-十字链表"><a href="#5-十字链表" class="headerlink" title="5.十字链表"></a>5.十字链表</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67879441e942a.png" alt></p><h5 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h5><p><strong>十字链表</strong>(Orthogonal List)是<strong>有向图</strong>的另一种链式存储结构。我们也可以把它看成是将有向图的邻接表和逆邻接表结合起来形成的一种链表。<br>有向图中的每一条弧对应十字链表中的一个<strong>弧结点</strong>，同时有向图中的每个顶点在十字链表中对应有一个结点，叫做<strong>顶点结点。</strong></p><h5 id="2-具体"><a href="#2-具体" class="headerlink" title="2.具体"></a>2.具体</h5><p>data:数据</p><p>firstin:第一个入度边</p><p>firstout:第一个出度边</p><p>tailvex:弧尾位置</p><p>headvex:弧头位置</p><p>hlink:弧头相同的下一条弧</p><p>tlink:弧尾相同的下一条弧</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678794454f6ba.png" alt></p><h4 id="6-邻接多重表"><a href="#6-邻接多重表" class="headerlink" title="6.邻接多重表"></a>6.邻接多重表</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67879446783fd.png" alt></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67879428ca77f.png" alt></p><h3 id="4-图的遍历"><a href="#4-图的遍历" class="headerlink" title="4.图的遍历"></a>4.图的遍历</h3><h4 id="1-定义-7"><a href="#1-定义-7" class="headerlink" title="1.定义"></a>1.定义</h4><p><strong>遍历定义:</strong></p><p>从已给的连通图中某一顶点出发，沿着一些边访遍图中所有的顶点，且使每个顶点仅被访问一次，就叫做<strong>图的遍历</strong>，它是图的基本运算</p><p><strong>遍历实质</strong>:找每个顶点的邻接点的过程。</p><p><strong>图的特点</strong>:<br>图中可能存在<strong>回路</strong>，且图的任一顶点都可能与其它顶点相通在访问完某个顶点之后可能会沿着某些边<strong>又回到了曾经访问过的顶点。</strong></p><p><strong>如何避免回路</strong>:</p><p>解决思路:设置<strong>辅助数组</strong><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="9.382ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4147 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405 130 405 104 376T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287 21 294 29 316T53 368 97 419 160 441Q202 441 225 417T249 361Q249 344 246 335 246 329 231 291T200 202 182 113Q182 86 187 69 200 26 250 26 287 26 319 60T369 139 398 222 409 277Q409 300 401 317T383 343 365 361 357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159 347 40 241-11Q177-11 139 22 102 54 102 117 102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(485,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(830,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415 300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372 367 378Q368 378 368 379 368 382 361 388T336 399 297 405Q249 405 227 379T204 326Q204 301 223 291T278 274 330 259Q396 230 396 163 396 135 385 107T352 51 289 7 195-10Q118-10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34 201 27Q237 27 263 38T301 66 318 97 323 122Q323 150 302 164T254 181 195 196 148 231Q131 256 131 289Z"/></g><g data-mml-node="mi" transform="translate(1299,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1644,0)"><path data-c="1D461" d="M26 385Q19 392 19 395 19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566 179 586 187 603 197 615 211 624 229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420 330 398 317 385H210L174 240Q135 80 135 68 135 26 162 26 197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145 322 142 319 133 314 117 301 95T267 48 216 6 155-11Q125-11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383 128 385 77 385H26Z"/></g><g data-mml-node="mi" transform="translate(2005,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350 174 402 244 433 307 442H310Q355 442 388 420T421 355Q421 265 310 237 261 224 176 223 139 223 138 221 138 219 132 186T125 128Q125 81 146 54T209 26 302 45 394 111Q403 121 406 121 410 121 419 112T429 98 420 82 390 55 344 24 281-1 205-11Q126-11 83 42T39 168ZM373 353Q367 405 305 405 272 405 244 391T199 357 170 316 154 280 149 261Q149 260 169 260 282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(2471,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686 523 679 450 384T375 83 374 68Q374 26 402 26 411 27 422 35 443 55 463 131 469 151 473 152 475 153 483 153H487 491Q506 153 506 145 506 140 503 129 490 79 473 48T445 8 417-8Q409-10 393-10 359-10 336 5T306 36L300 51Q299 52 296 50 294 48 292 46 233-10 172-10 117-10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400 369 394 369 396 370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405 242 405 210 374T160 293Q131 214 119 129 119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109 352 326Z"/></g><g data-mml-node="mo" transform="translate(2991,0)"><path data-c="5B" d="M118-250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(3269,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3869,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>，用来标记每个被访问过的顶点。</p><ul><li>初始状态<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="8.805ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3892 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405 130 405 104 376T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287 21 294 29 316T53 368 97 419 160 441Q202 441 225 417T249 361Q249 344 246 335 246 329 231 291T200 202 182 113Q182 86 187 69 200 26 250 26 287 26 319 60T369 139 398 222 409 277Q409 300 401 317T383 343 365 361 357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159 347 40 241-11Q177-11 139 22 102 54 102 117 102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(485,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(830,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415 300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372 367 378Q368 378 368 379 368 382 361 388T336 399 297 405Q249 405 227 379T204 326Q204 301 223 291T278 274 330 259Q396 230 396 163 396 135 385 107T352 51 289 7 195-10Q118-10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34 201 27Q237 27 263 38T301 66 318 97 323 122Q323 150 302 164T254 181 195 196 148 231Q131 256 131 289Z"/></g><g data-mml-node="mi" transform="translate(1299,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1644,0)"><path data-c="1D461" d="M26 385Q19 392 19 395 19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566 179 586 187 603 197 615 211 624 229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420 330 398 317 385H210L174 240Q135 80 135 68 135 26 162 26 197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145 322 142 319 133 314 117 301 95T267 48 216 6 155-11Q125-11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383 128 385 77 385H26Z"/></g><g data-mml-node="mi" transform="translate(2005,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350 174 402 244 433 307 442H310Q355 442 388 420T421 355Q421 265 310 237 261 224 176 223 139 223 138 221 138 219 132 186T125 128Q125 81 146 54T209 26 302 45 394 111Q403 121 406 121 410 121 419 112T429 98 420 82 390 55 344 24 281-1 205-11Q126-11 83 42T39 168ZM373 353Q367 405 305 405 272 405 244 391T199 357 170 316 154 280 149 261Q149 260 169 260 282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(2471,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686 523 679 450 384T375 83 374 68Q374 26 402 26 411 27 422 35 443 55 463 131 469 151 473 152 475 153 483 153H487 491Q506 153 506 145 506 140 503 129 490 79 473 48T445 8 417-8Q409-10 393-10 359-10 336 5T306 36L300 51Q299 52 296 50 294 48 292 46 233-10 172-10 117-10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400 369 394 369 396 370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405 242 405 210 374T160 293Q131 214 119 129 119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109 352 326Z"/></g><g data-mml-node="mo" transform="translate(2991,0)"><path data-c="5B" d="M118-250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(3269,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3614,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>为0</li><li>·顶点i被访问，改<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="8.805ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3892 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405 130 405 104 376T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287 21 294 29 316T53 368 97 419 160 441Q202 441 225 417T249 361Q249 344 246 335 246 329 231 291T200 202 182 113Q182 86 187 69 200 26 250 26 287 26 319 60T369 139 398 222 409 277Q409 300 401 317T383 343 365 361 357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159 347 40 241-11Q177-11 139 22 102 54 102 117 102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(485,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(830,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415 300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372 367 378Q368 378 368 379 368 382 361 388T336 399 297 405Q249 405 227 379T204 326Q204 301 223 291T278 274 330 259Q396 230 396 163 396 135 385 107T352 51 289 7 195-10Q118-10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34 201 27Q237 27 263 38T301 66 318 97 323 122Q323 150 302 164T254 181 195 196 148 231Q131 256 131 289Z"/></g><g data-mml-node="mi" transform="translate(1299,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1644,0)"><path data-c="1D461" d="M26 385Q19 392 19 395 19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566 179 586 187 603 197 615 211 624 229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420 330 398 317 385H210L174 240Q135 80 135 68 135 26 162 26 197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145 322 142 319 133 314 117 301 95T267 48 216 6 155-11Q125-11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383 128 385 77 385H26Z"/></g><g data-mml-node="mi" transform="translate(2005,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350 174 402 244 433 307 442H310Q355 442 388 420T421 355Q421 265 310 237 261 224 176 223 139 223 138 221 138 219 132 186T125 128Q125 81 146 54T209 26 302 45 394 111Q403 121 406 121 410 121 419 112T429 98 420 82 390 55 344 24 281-1 205-11Q126-11 83 42T39 168ZM373 353Q367 405 305 405 272 405 244 391T199 357 170 316 154 280 149 261Q149 260 169 260 282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(2471,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686 523 679 450 384T375 83 374 68Q374 26 402 26 411 27 422 35 443 55 463 131 469 151 473 152 475 153 483 153H487 491Q506 153 506 145 506 140 503 129 490 79 473 48T445 8 417-8Q409-10 393-10 359-10 336 5T306 36L300 51Q299 52 296 50 294 48 292 46 233-10 172-10 117-10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400 369 394 369 396 370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405 242 405 210 374T160 293Q131 214 119 129 119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109 352 326Z"/></g><g data-mml-node="mo" transform="translate(2991,0)"><path data-c="5B" d="M118-250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(3269,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3614,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>为1，防止被多次访问</li></ul><h4 id="2-深度优先-DFS"><a href="#2-深度优先-DFS" class="headerlink" title="2.深度优先(DFS)"></a>2.深度优先(DFS)</h4><h5 id="1-连通图的遍历"><a href="#1-连通图的遍历" class="headerlink" title="1.连通图的遍历"></a>1.连通图的遍历</h5><h6 id="方法"><a href="#方法" class="headerlink" title="方法:"></a>方法:</h6><ul><li>在访问图中某一起始顶点v后，由v出发，访问它的任一邻接顶点w1</li><li>再从w出发，访问与w邻接但还未被访问过的顶点W2;</li><li>然后再从w出发，进行类似的访问，…</li><li>如此进行下去，直至到达所有的邻接顶点都被访问过的顶点u为止。接着，退回一步，退到前一次刚访问过的顶点，看是否还有其它没有被访问的邻接顶点。</li><li>如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问;</li><li>如果没有，就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787943315a1d.png" alt></p><h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67879434eaab8.png" alt></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//王道代码</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];<span class="comment">//访问标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(Graph G)</span><span class="comment">//对图G进行深度优先遍历</span></span><br><span class="line">{</span><br><span class="line">   <span class="type">int</span> v;</span><br><span class="line">   <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G;v++)</span><br><span class="line">   {</span><br><span class="line">       visited[v]=<span class="literal">false</span>;<span class="comment">//初始化已访问数组</span></span><br><span class="line">       <span class="keyword">for</span> ( v = <span class="number">0</span>; v &lt; G; ++v) {<span class="comment">//从v0开始遍历</span></span><br><span class="line">           <span class="keyword">if</span>(!visited[v])</span><br><span class="line">           {</span><br><span class="line">               DFS(G,v);</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Grap G,<span class="type">int</span> V)</span><span class="comment">//从顶点v出发，深度遍历图G</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    visit(v);<span class="comment">//访问顶点v</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>;<span class="comment">//设已访问标记</span></span><br><span class="line">    <span class="keyword">for</span> (w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,v,w))<span class="comment">//依次检查邻接矩阵v所在的行 </span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])<span class="comment">//w为v还没访问的邻接顶点</span></span><br><span class="line">        {</span><br><span class="line">            DFS(G,w);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h6><p>用邻接矩阵来表示图，遍历图中每一个顶点都要从头扫描该顶点所在的行，时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2577.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42 304-22Q207-22 138 35T51 201Q50 209 50 244 50 346 98 438T227 601Q351 704 476 704 514 704 524 703 621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605 242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488 164 576 202 643 244 695 277 729 302 750H315 319Q333 750 333 741 333 738 316 720T275 667 226 581 184 443 167 250 184 58 225-81 274-167 316-220 333-241Q333-250 318-250H315 302L274-226Q180-141 137-14T94 250Z"/></g><g data-mml-node="msub" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315 301 241Q265 210 201 149L142 93 218 92Q375 92 385 97 392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19 31Q50 38 56 46T86 81Q115 113 136 137 145 147 170 174T204 211 233 244 261 278 284 308 305 340 320 369 333 401 340 431 343 464Q343 527 309 573T212 619Q179 619 154 602T119 569 109 550Q109 549 114 549 132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749 64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12 224-76 186-143 145-194 113-227 90-246Q87-249 86-250H74Q66-250 63-250T58-247 55-238Q56-237 66-225 221-64 221 250T66 725Q56 737 55 738 55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p><p>用邻接表来表示图，虽然有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.025ex" xmlns="http://www.w3.org/2000/svg" width="2.186ex" height="1.532ex" role="img" focusable="false" viewbox="0 -666 966 677"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315 301 241Q265 210 201 149L142 93 218 92Q375 92 385 97 392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19 31Q50 38 56 46T86 81Q115 113 136 137 145 147 170 174T204 211 233 244 261 278 284 308 305 340 320 369 333 401 340 431 343 464Q343 527 309 573T212 619Q179 619 154 602T119 569 109 550Q109 549 114 549 132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350 174 402 244 433 307 442H310Q355 442 388 420T421 355Q421 265 310 237 261 224 176 223 139 223 138 221 138 219 132 186T125 128Q125 81 146 54T209 26 302 45 394 111Q403 121 406 121 410 121 419 112T429 98 420 82 390 55 344 24 281-1 205-11Q126-11 83 42T39 168ZM373 353Q367 405 305 405 272 405 244 391T199 357 170 316 154 280 149 261Q149 260 169 260 282 260 327 284T373 353Z"/></g></g></g></svg></mjx-container>个表结点，但只需扫描e个结点即可完成遍历，加上访问n个头结点的时间，时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="8.664ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3829.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42 304-22Q207-22 138 35T51 201Q50 209 50 244 50 346 98 438T227 601Q351 704 476 704 514 704 524 703 621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605 242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488 164 576 202 643 244 695 277 729 302 750H315 319Q333 750 333 741 333 738 316 720T275 667 226 581 184 443 167 250 184 58 225-81 274-167 316-220 333-241Q333-250 318-250H315 302L274-226Q180-141 137-14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1974.2,0)"><path data-c="2B" d="M56 237T56 250 70 270H369V420L370 570Q380 583 389 583 402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401-82 391-82H389 387Q375-82 369-68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(2974.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350 174 402 244 433 307 442H310Q355 442 388 420T421 355Q421 265 310 237 261 224 176 223 139 223 138 221 138 219 132 186T125 128Q125 81 146 54T209 26 302 45 394 111Q403 121 406 121 410 121 419 112T429 98 420 82 390 55 344 24 281-1 205-11Q126-11 83 42T39 168ZM373 353Q367 405 305 405 272 405 244 391T199 357 170 316 154 280 149 261Q149 260 169 260 282 260 327 284T373 353Z"/></g><g data-mml-node="mo" transform="translate(3440.4,0)"><path data-c="29" d="M60 749 64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12 224-76 186-143 145-194 113-227 90-246Q87-249 86-250H74Q66-250 63-250T58-247 55-238Q56-237 66-225 221-64 221 250T66 725Q56 737 55 738 55 746 60 749Z"/></g></g></g></svg></mjx-container>.</p><h6 id="结论"><a href="#结论" class="headerlink" title="结论:"></a><strong>结论</strong>:</h6><ul><li><strong>稠密图</strong>适于在邻接矩阵上进行深度遍历;</li><li><strong>稀疏图</strong>通于在邻接表上进行深度遍历。</li></ul><h4 id="2-广度优先遍历"><a href="#2-广度优先遍历" class="headerlink" title="2.广度优先遍历"></a>2.广度优先遍历</h4><h5 id="1-方法-1"><a href="#1-方法-1" class="headerlink" title="1.方法"></a>1.方法</h5><p>方法:从图的某一结点出发，首先依次访问该结点的所有邻接点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.439ex" xmlns="http://www.w3.org/2000/svg" width="13.127ex" height="1.984ex" role="img" focusable="false" viewbox="0 -683 5802 877"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mn" transform="translate(616,-150) scale(0.707)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(1019.6,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1464.2,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mn" transform="translate(616,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315 301 241Q265 210 201 149L142 93 218 92Q375 92 385 97 392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19 31Q50 38 56 46T86 81Q115 113 136 137 145 147 170 174T204 211 233 244 261 278 284 308 305 340 320 369 333 401 340 431 343 464Q343 527 309 573T212 619Q179 619 154 602T119 569 109 550Q109 549 114 549 132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2483.8,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g><g data-mml-node="mo" transform="translate(2928.4,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0 96 17 78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0 543 17 525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0 990 17 972 60Z"/></g><g data-mml-node="mo" transform="translate(4267.1,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(4711.8,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>,再按这些顶点被访问的先后次序依次访问与它们相邻接的所有未被访问的顶点<br>重复此过程，直至所有顶点均被访问为止。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67879439013da.png" alt></p><h5 id="2-实现-1"><a href="#2-实现-1" class="headerlink" title="2.实现"></a>2.实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//王道代码</span></span><br><span class="line"><span class="type">bool</span> visited [Max_VERTEX_NUM];<span class="comment">//访问标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTraverse</span><span class="params">(Grap G)</span>{<span class="comment">//对图G进行广度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i) {</span><br><span class="line">        visited[i]=<span class="literal">false</span>;<span class="comment">//访问标记数组初始化</span></span><br><span class="line">    }</span><br><span class="line">    InitQueue(Q);<span class="comment">//初始化辅助队列Q</span></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;G.vexnum ; ++i) {<span class="comment">//从0号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i]){<span class="comment">//对每个连通分量调用一次BFS</span></span><br><span class="line">            BFS(G,i);<span class="comment">//vi未访问过，从vi开始BFS</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span>{<span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">    visit(v);<span class="comment">//访问初始顶点v</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>;<span class="comment">//对v做以访问标志</span></span><br><span class="line">    Enqueue(Q,v);<span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(Q)){</span><br><span class="line">        DeQueue(Q,v);<span class="comment">//顶点v出队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> w = FirstNeighbor(G,v); w&gt;<span class="number">0</span> ; w=NextNeighbor(G,v,w)) {</span><br><span class="line">                                           <span class="comment">//检测到v的所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[w]){<span class="comment">//w为v未访问的邻接顶点</span></span><br><span class="line">                visit(w);<span class="comment">//访问顶点w</span></span><br><span class="line">                visited[w]=<span class="literal">true</span>;<span class="comment">//对w做以访问标记</span></span><br><span class="line">                Enqueue(Q,w);<span class="comment">//顶点w入队列</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3-效率分析"><a href="#3-效率分析" class="headerlink" title="3.效率分析"></a>3.效率分析</h5><ul><li>如果使用邻接矩阵，则BFS对于每一个被访问到的顶点，都要<br>循环检测矩阵中的整整一行（ n个元素)，总的时间代价为O(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.025ex" xmlns="http://www.w3.org/2000/svg" width="2.345ex" height="1.912ex" role="img" focusable="false" viewbox="0 -833.9 1036.6 844.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315 301 241Q265 210 201 149L142 93 218 92Q375 92 385 97 392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19 31Q50 38 56 46T86 81Q115 113 136 137 145 147 170 174T204 211 233 244 261 278 284 308 305 340 320 369 333 401 340 431 343 464Q343 527 309 573T212 619Q179 619 154 602T119 569 109 550Q109 549 114 549 132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></g></svg></mjx-container>)。</li><li>用邻接表来表示图，虽然有2e个表结点，但只需扫描e个结点即可完成遍历，加上访问n个头结点的时间，时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="8.664ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3829.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42 304-22Q207-22 138 35T51 201Q50 209 50 244 50 346 98 438T227 601Q351 704 476 704 514 704 524 703 621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605 242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488 164 576 202 643 244 695 277 729 302 750H315 319Q333 750 333 741 333 738 316 720T275 667 226 581 184 443 167 250 184 58 225-81 274-167 316-220 333-241Q333-250 318-250H315 302L274-226Q180-141 137-14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1974.2,0)"><path data-c="2B" d="M56 237T56 250 70 270H369V420L370 570Q380 583 389 583 402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401-82 391-82H389 387Q375-82 369-68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(2974.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350 174 402 244 433 307 442H310Q355 442 388 420T421 355Q421 265 310 237 261 224 176 223 139 223 138 221 138 219 132 186T125 128Q125 81 146 54T209 26 302 45 394 111Q403 121 406 121 410 121 419 112T429 98 420 82 390 55 344 24 281-1 205-11Q126-11 83 42T39 168ZM373 353Q367 405 305 405 272 405 244 391T199 357 170 316 154 280 149 261Q149 260 169 260 282 260 327 284T373 353Z"/></g><g data-mml-node="mo" transform="translate(3440.4,0)"><path data-c="29" d="M60 749 64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12 224-76 186-143 145-194 113-227 90-246Q87-249 86-250H74Q66-250 63-250T58-247 55-238Q56-237 66-225 221-64 221 250T66 725Q56 737 55 738 55 746 60 749Z"/></g></g></g></svg></mjx-container>。</li></ul><h5 id="4-效率比较"><a href="#4-效率比较" class="headerlink" title="4.效率比较"></a>4.效率比较</h5><ul><li>·空间复杂度相同，都是O(n)(借用了堆栈或队列) ;</li><li>·时间复杂度只与存储结构,(邻接矩阵或邻接表)有关，而与搜索路径无关。</li></ul><h3 id="5-图的应用"><a href="#5-图的应用" class="headerlink" title="5.图的应用"></a>5.图的应用</h3><h4 id="1-最小生成树"><a href="#1-最小生成树" class="headerlink" title="1.最小生成树"></a>1.最小生成树</h4><h5 id="1-生成树的简介"><a href="#1-生成树的简介" class="headerlink" title="1.生成树的简介"></a>1.生成树的简介</h5><p><strong>生成树</strong>：所有顶点均由边连接在一起，但不存在回路</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787943a92ab9.png" alt></p><blockquote><p>一个图可以有许多棵不同的生成树</p><p>所有生成树具有以下共同特点</p><ul><li>生成树的顶点个数与图的<strong>顶点个数相同;</strong></li><li>生成树是图的<strong>极小连通子图</strong>，去掉一条边则非连通;·</li><li>一个有n个顶点的连通图的生成树有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.186ex" xmlns="http://www.w3.org/2000/svg" width="5.254ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 2322.4 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(822.2,0)"><path data-c="2212" d="M84 237T84 250 98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1822.4,0)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g></g></g></svg></mjx-container>条边;</li><li><strong>·在生成树中再加一条边必然形成回路。</strong></li><li>生成树中任意两个顶点间的<strong>路径是唯一</strong>的;</li></ul><p>含有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.025ex" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>个顶点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.186ex" xmlns="http://www.w3.org/2000/svg" width="5.254ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 2322.4 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341 56 388 89 425 135 442Q171 442 195 424T225 390 231 369Q231 367 232 367L243 378Q304 442 382 442 436 442 469 415T503 336 465 179 427 52Q427 26 444 26 450 26 453 27 482 32 505 65T540 145Q542 153 560 153 580 153 580 145 580 144 576 130 568 101 554 73T508 17 439-10Q392-10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291 189 157Q156 26 151 16 138-11 108-11 95-11 87-5T76 7 74 17Q74 30 112 180T152 343Q153 348 153 366 153 405 129 405 91 405 66 305 60 285 60 284 58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(822.2,0)"><path data-c="2212" d="M84 237T84 250 98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1822.4,0)"><path data-c="31" d="M213 578 200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641 273 663Q275 666 285 666 294 666 302 660V361L303 61Q310 54 315 52T339 48 401 46H427V0H416Q395 3 257 3 121 3 100 0H88V46H114Q136 46 152 46T177 47 193 50 201 52 207 57 213 61V578Z"/></g></g></g></svg></mjx-container>条边的图不一定是最小生成树</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787943d83d9a.png" alt></p></blockquote><h5 id="2-无向图的生成树"><a href="#2-无向图的生成树" class="headerlink" title="2.无向图的生成树"></a>2.无向图的生成树</h5><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787944158d73.png" alt></p><h5 id="3-最小生成树"><a href="#3-最小生成树" class="headerlink" title="3.最小生成树"></a>3.最小生成树</h5><p><strong>最小生成树</strong>:给定一个无向网络在该网的所有生成树中，使得各边权值之和最小的那棵生成树称为该网的最小生成树，也叫最小代价生成树。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678794449832b.png" alt></p><h6 id="构造最小生成树"><a href="#构造最小生成树" class="headerlink" title="构造最小生成树"></a>构造最小生成树</h6><p>构造最小生成树的算法很多，其中多数算法都利用了<strong>MST</strong>的性质。</p><p><strong>MST性质</strong>:设N =(V, E)是一个连通网,U是顶点集V的一个非空子集。若边(u, v)是一条具有最小权值的边，其中u∈u,v∈V-U,则必存<br>在一棵包含边(u, v)的最小生成树。</p><h6 id="Prim-普里姆算法"><a href="#Prim-普里姆算法" class="headerlink" title="Prim-普里姆算法"></a>Prim-普里姆算法</h6><p>算法思想</p><blockquote><p>设<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="11.229ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4963.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637 201 637 196 638T191 649Q191 676 202 682 204 683 299 683 376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606 723 633 659 637 635 637 635 648 635 650 637 660 641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672 888 650 880 642 878 637 858 637 787 633 769 597L620 7Q618 0 599 0 585 0 582 2 579 5 453 305L326 604 261 344Q196 88 196 79 201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2 123 2 100 2T63 2 46 1Q31 1 31 10 31 14 34 26T39 40Q41 46 62 46 130 49 150 85 154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(1165.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347 722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153 722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(2221.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488 164 576 202 643 244 695 277 729 302 750H315 319Q333 750 333 741 333 738 316 720T275 667 226 581 184 443 167 250 184 58 225-81 274-167 316-220 333-241Q333-250 318-250H315 302L274-226Q180-141 137-14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2610.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mo" transform="translate(3379.6,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(3824.2,0)"><path data-c="1D434" d="M208 74Q208 50 254 46 272 46 272 35 272 34 270 22 267 8 264 4T251 0Q249 0 239 0T205 1 141 2Q70 2 50 0H42Q35 7 35 11 37 38 48 46H62Q132 49 164 96 170 102 345 401T523 704Q530 716 547 716H555 572Q578 707 578 706L606 383Q634 60 636 57 641 46 701 46 726 46 726 36 726 34 723 22 720 7 718 4T704 0Q701 0 690 0T651 1 578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260 413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(4574.2,0)"><path data-c="29" d="M60 749 64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12 224-76 186-143 145-194 113-227 90-246Q87-249 86-250H74Q66-250 63-250T58-247 55-238Q56-237 66-225 221-64 221 250T66 725Q56 737 55 738 55 746 60 749Z"/></g></g></g></svg></mjx-container>是连通网，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:0" xmlns="http://www.w3.org/2000/svg" width="3.321ex" height="1.538ex" role="img" focusable="false" viewbox="0 -680 1468 680"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445 21 450 37 501T71 602L88 651Q93 669 101 677H569 659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437 640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631 469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46 418 46 427 45T436 36Q436 31 433 22 429 4 424 1L422 0Q419 0 415 0 410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83 94Q174 46 189 55 190 56 191 56 196 59 201 76T241 233Q258 301 269 344 339 619 339 625 339 630 310 630H279Q212 630 191 624 146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(704,0)"><path data-c="1D438" d="M492 213Q472 213 472 226 472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272 690 274 698 274 718 274 718 261 613 7 608 2 605 0 322 0H133Q31 0 31 11 31 13 34 25 38 41 42 43T65 46Q92 46 125 49 139 52 144 61 146 66 215 342T285 622Q285 629 281 629 273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669 764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528 704 558 697 578T678 609 643 625 596 632 532 634H485Q397 633 392 631 388 629 386 622 385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492 572 491 574 487 577 483L544 351Q511 218 508 216 505 213 492 213Z"/></g></g></g></svg></mjx-container>是N上最小生成树中边的集合。</p><p>初 始 令<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.357ex" xmlns="http://www.w3.org/2000/svg" width="7.01ex" height="1.902ex" role="img" focusable="false" viewbox="0 -683 3098.5 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D448" d="M107 637Q73 637 71 641 70 643 70 649 70 673 81 682 83 683 98 683 139 681 234 681 268 681 297 681T342 682 362 682Q378 682 378 672 378 670 376 658 371 641 366 638H364Q362 638 359 638T352 638 343 637 334 637Q295 636 284 634T266 623Q265 621 238 518T184 302 154 169Q152 155 152 140 152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606 599 633 535 637 511 637 511 648 511 650 513 660 517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672 767 650 759 642 756 637 737 637 666 633 648 597 646 592 598 404 557 235 548 205 515 105 433 42T263-22Q171-22 116 34T60 167V183Q60 201 115 421 164 622 164 628 164 635 107 637Z"/></g><g data-mml-node="mo" transform="translate(1044.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347 722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153 722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2100.6,0)"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370 99 420 158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27 291 44 328 78L339 95Q341 99 377 247 407 367 413 387T427 416Q444 431 463 431 480 431 488 421T496 402L420 84Q419 79 419 68 419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153 551 153 551 144 550 139 549 130T540 98 523 55 498 17 462-8Q454-10 438-10 372-10 347 46 345 45 336 36T318 21 296 6 267-6 233-11Q189-11 155 7 103 38 103 113 103 170 138 262T173 379Q173 380 173 381 173 390 173 393T169 400 158 404H154Q131 404 112 385T82 344 65 302 57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(605,-150) scale(0.707)"><path data-c="1D45C" d="M201-11Q126-11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441 333 441 341 440 354 437 367 433T402 417 438 387 464 338 476 268Q476 161 390 75T201-11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375 346 405 306 405 243 405 195 347 158 303 140 230T121 120Z"/></g></g></g></g></g></svg></mjx-container>,<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="9.025ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3989.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488 164 576 202 643 244 695 277 729 302 750H315 319Q333 750 333 741 333 738 316 720T275 667 226 581 184 443 167 250 184 58 225-81 274-167 316-220 333-241Q333-250 318-250H315 302L274-226Q180-141 137-14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370 99 420 158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27 291 44 328 78L339 95Q341 99 377 247 407 367 413 387T427 416Q444 431 463 431 480 431 488 421T496 402L420 84Q419 79 419 68 419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153 551 153 551 144 550 139 549 130T540 98 523 55 498 17 462-8Q454-10 438-10 372-10 347 46 345 45 336 36T318 21 296 6 267-6 233-11Q189-11 155 7 103 38 103 113 103 170 138 262T173 379Q173 380 173 381 173 390 173 393T169 400 158 404H154Q131 404 112 385T82 344 65 302 57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(605,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666 297 666 345 640T423 548Q460 465 460 320 460 165 417 83 397 41 362 16T301-15 250-22Q224-22 198-16T137 16 82 83Q39 165 39 320 39 494 96 585ZM321 597Q291 629 250 629 208 629 178 597 153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16 290 16 318 46 347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(1675.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">∊</text></g><g data-mml-node="mi" transform="translate(2553.1,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mo" transform="translate(3322.1,0)"><path data-c="29" d="M60 749 64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12 224-76 186-143 145-194 113-227 90-246Q87-249 86-250H74Q66-250 63-250T58-247 55-238Q56-237 66-225 221-64 221 250T66 725Q56 737 55 738 55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(3711.1,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g></g></g></svg></mjx-container>TE=${ }。</p><p>在所有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.452ex" xmlns="http://www.w3.org/2000/svg" width="5.644ex" height="2.149ex" role="img" focusable="false" viewbox="0 -750 2494.6 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370 99 420 158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27 291 44 328 78L339 95Q341 99 377 247 407 367 413 387T427 416Q444 431 463 431 480 431 488 421T496 402L420 84Q419 79 419 68 419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153 551 153 551 144 550 139 549 130T540 98 523 55 498 17 462-8Q454-10 438-10 372-10 347 46 345 45 336 36T318 21 296 6 267-6 233-11Q189-11 155 7 103 38 103 113 103 170 138 262T173 379Q173 380 173 381 173 390 173 393T169 400 158 404H154Q131 404 112 385T82 344 65 302 57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(849.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">∊</text></g><g data-mml-node="mi" transform="translate(1727.6,0)"><path data-c="1D448" d="M107 637Q73 637 71 641 70 643 70 649 70 673 81 682 83 683 98 683 139 681 234 681 268 681 297 681T342 682 362 682Q378 682 378 672 378 670 376 658 371 641 366 638H364Q362 638 359 638T352 638 343 637 334 637Q295 636 284 634T266 623Q265 621 238 518T184 302 154 169Q152 155 152 140 152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606 599 633 535 637 511 637 511 648 511 650 513 660 517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672 767 650 759 642 756 637 737 637 666 633 648 597 646 592 598 404 557 235 548 205 515 105 433 42T263-22Q171-22 116 34T60 167V183Q60 201 115 421 164 622 164 628 164 635 107 637Z"/></g></g></g></svg></mjx-container>,<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.452ex" xmlns="http://www.w3.org/2000/svg" width="9.952ex" height="2.149ex" role="img" focusable="false" viewbox="0 -750 4399 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405 130 405 104 376T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287 21 294 29 316T53 368 97 419 160 441Q202 441 225 417T249 361Q249 344 246 335 246 329 231 291T200 202 182 113Q182 86 187 69 200 26 250 26 287 26 319 60T369 139 398 222 409 277Q409 300 401 317T383 343 365 361 357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159 347 40 241-11Q177-11 139 22 102 54 102 117 102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mo" transform="translate(762.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">∊</text></g><g data-mml-node="mi" transform="translate(1640.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mo" transform="translate(2631.8,0)"><path data-c="2212" d="M84 237T84 250 98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(3632,0)"><path data-c="1D448" d="M107 637Q73 637 71 641 70 643 70 649 70 673 81 682 83 683 98 683 139 681 234 681 268 681 297 681T342 682 362 682Q378 682 378 672 378 670 376 658 371 641 366 638H364Q362 638 359 638T352 638 343 637 334 637Q295 636 284 634T266 623Q265 621 238 518T184 302 154 169Q152 155 152 140 152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606 599 633 535 637 511 637 511 648 511 650 513 660 517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672 767 650 759 642 756 637 737 637 666 633 648 597 646 592 598 404 557 235 548 205 515 105 433 42T263-22Q171-22 116 34T60 167V183Q60 201 115 421 164 622 164 628 164 635 107 637Z"/></g></g></g></svg></mjx-container>的边<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="9.501ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4199.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488 164 576 202 643 244 695 277 729 302 750H315 319Q333 750 333 741 333 738 316 720T275 667 226 581 184 443 167 250 184 58 225-81 274-167 316-220 333-241Q333-250 318-250H315 302L274-226Q180-141 137-14T94 250Z"/></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370 99 420 158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27 291 44 328 78L339 95Q341 99 377 247 407 367 413 387T427 416Q444 431 463 431 480 431 488 421T496 402L420 84Q419 79 419 68 419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153 551 153 551 144 550 139 549 130T540 98 523 55 498 17 462-8Q454-10 438-10 372-10 347 46 345 45 336 36T318 21 296 6 267-6 233-11Q189-11 155 7 103 38 103 113 103 170 138 262T173 379Q173 380 173 381 173 390 173 393T169 400 158 404H154Q131 404 112 385T82 344 65 302 57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(961,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1405.7,0)"><path data-c="1D463" d="M173 380Q173 405 154 405 130 405 104 376T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287 21 294 29 316T53 368 97 419 160 441Q202 441 225 417T249 361Q249 344 246 335 246 329 231 291T200 202 182 113Q182 86 187 69 200 26 250 26 287 26 319 60T369 139 398 222 409 277Q409 300 401 317T383 343 365 361 357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159 347 40 241-11Q177-11 139 22 102 54 102 117 102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mo" transform="translate(1890.7,0)"><path data-c="29" d="M60 749 64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12 224-76 186-143 145-194 113-227 90-246Q87-249 86-250H74Q66-250 63-250T58-247 55-238Q56-237 66-225 221-64 221 250T66 725Q56 737 55 738 55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2557.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">∊</text></g><g data-mml-node="mi" transform="translate(3435.2,0)"><path data-c="1D438" d="M492 213Q472 213 472 226 472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272 690 274 698 274 718 274 718 261 613 7 608 2 605 0 322 0H133Q31 0 31 11 31 13 34 25 38 41 42 43T65 46Q92 46 125 49 139 52 144 61 146 66 215 342T285 622Q285 629 281 629 273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669 764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528 704 558 697 578T678 609 643 625 596 632 532 634H485Q397 633 392 631 388 629 386 622 385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492 572 491 574 487 577 483L544 351Q511 218 508 216 505 213 492 213Z"/></g></g></g></svg></mjx-container>中，找一条代价最小的边<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="7.133ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3152.8 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488 164 576 202 643 244 695 277 729 302 750H315 319Q333 750 333 741 333 738 316 720T275 667 226 581 184 443 167 250 184 58 225-81 274-167 316-220 333-241Q333-250 318-250H315 302L274-226Q180-141 137-14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370 99 420 158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27 291 44 328 78L339 95Q341 99 377 247 407 367 413 387T427 416Q444 431 463 431 480 431 488 421T496 402L420 84Q419 79 419 68 419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153 551 153 551 144 550 139 549 130T540 98 523 55 498 17 462-8Q454-10 438-10 372-10 347 46 345 45 336 36T318 21 296 6 267-6 233-11Q189-11 155 7 103 38 103 113 103 170 138 262T173 379Q173 380 173 381 173 390 173 393T169 400 158 404H154Q131 404 112 385T82 344 65 302 57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(605,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666 297 666 345 640T423 548Q460 465 460 320 460 165 417 83 397 41 362 16T301-15 250-22Q224-22 198-16T137 16 82 83Q39 165 39 320 39 494 96 585ZM321 597Q291 629 250 629 208 629 178 597 153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16 290 16 318 46 347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(1397.6,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1842.2,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405 130 405 104 376T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287 21 294 29 316T53 368 97 419 160 441Q202 441 225 417T249 361Q249 344 246 335 246 329 231 291T200 202 182 113Q182 86 187 69 200 26 250 26 287 26 319 60T369 139 398 222 409 277Q409 300 401 317T383 343 365 361 357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159 347 40 241-11Q177-11 139 22 102 54 102 117 102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mn" transform="translate(518,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666 297 666 345 640T423 548Q460 465 460 320 460 165 417 83 397 41 362 16T301-15 250-22Q224-22 198-16T137 16 82 83Q39 165 39 320 39 494 96 585ZM321 597Q291 629 250 629 208 629 178 597 153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16 290 16 318 46 347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(2763.8,0)"><path data-c="29" d="M60 749 64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12 224-76 186-143 145-194 113-227 90-246Q87-249 86-250H74Q66-250 63-250T58-247 55-238Q56-237 66-225 221-64 221 250T66 725Q56 737 55 738 55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p><p>将<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="7.133ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3152.8 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488 164 576 202 643 244 695 277 729 302 750H315 319Q333 750 333 741 333 738 316 720T275 667 226 581 184 443 167 250 184 58 225-81 274-167 316-220 333-241Q333-250 318-250H315 302L274-226Q180-141 137-14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370 99 420 158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27 291 44 328 78L339 95Q341 99 377 247 407 367 413 387T427 416Q444 431 463 431 480 431 488 421T496 402L420 84Q419 79 419 68 419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153 551 153 551 144 550 139 549 130T540 98 523 55 498 17 462-8Q454-10 438-10 372-10 347 46 345 45 336 36T318 21 296 6 267-6 233-11Q189-11 155 7 103 38 103 113 103 170 138 262T173 379Q173 380 173 381 173 390 173 393T169 400 158 404H154Q131 404 112 385T82 344 65 302 57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(605,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666 297 666 345 640T423 548Q460 465 460 320 460 165 417 83 397 41 362 16T301-15 250-22Q224-22 198-16T137 16 82 83Q39 165 39 320 39 494 96 585ZM321 597Q291 629 250 629 208 629 178 597 153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16 290 16 318 46 347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(1397.6,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1842.2,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405 130 405 104 376T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287 21 294 29 316T53 368 97 419 160 441Q202 441 225 417T249 361Q249 344 246 335 246 329 231 291T200 202 182 113Q182 86 187 69 200 26 250 26 287 26 319 60T369 139 398 222 409 277Q409 300 401 317T383 343 365 361 357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159 347 40 241-11Q177-11 139 22 102 54 102 117 102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mn" transform="translate(518,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666 297 666 345 640T423 548Q460 465 460 320 460 165 417 83 397 41 362 16T301-15 250-22Q224-22 198-16T137 16 82 83Q39 165 39 320 39 494 96 585ZM321 597Q291 629 250 629 208 629 178 597 153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16 290 16 318 46 347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(2763.8,0)"><path data-c="29" d="M60 749 64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12 224-76 186-143 145-194 113-227 90-246Q87-249 86-250H74Q66-250 63-250T58-247 55-238Q56-237 66-225 221-64 221 250T66 725Q56 737 55 738 55 746 60 749Z"/></g></g></g></svg></mjx-container>并入集合<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:0" xmlns="http://www.w3.org/2000/svg" width="3.321ex" height="1.538ex" role="img" focusable="false" viewbox="0 -680 1468 680"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445 21 450 37 501T71 602L88 651Q93 669 101 677H569 659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437 640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631 469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46 418 46 427 45T436 36Q436 31 433 22 429 4 424 1L422 0Q419 0 415 0 410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83 94Q174 46 189 55 190 56 191 56 196 59 201 76T241 233Q258 301 269 344 339 619 339 625 339 630 310 630H279Q212 630 191 624 146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(704,0)"><path data-c="1D438" d="M492 213Q472 213 472 226 472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272 690 274 698 274 718 274 718 261 613 7 608 2 605 0 322 0H133Q31 0 31 11 31 13 34 25 38 41 42 43T65 46Q92 46 125 49 139 52 144 61 146 66 215 342T285 622Q285 629 281 629 273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669 764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528 704 558 697 578T678 609 643 625 596 632 532 634H485Q397 633 392 631 388 629 386 622 385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492 572 491 574 487 577 483L544 351Q511 218 508 216 505 213 492 213Z"/></g></g></g></svg></mjx-container>，同时<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.357ex" xmlns="http://www.w3.org/2000/svg" width="2.061ex" height="1.359ex" role="img" focusable="false" viewbox="0 -443 910.9 600.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405 130 405 104 376T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287 21 294 29 316T53 368 97 419 160 441Q202 441 225 417T249 361Q249 344 246 335 246 329 231 291T200 202 182 113Q182 86 187 69 200 26 250 26 287 26 319 60T369 139 398 222 409 277Q409 300 401 317T383 343 365 361 357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159 347 40 241-11Q177-11 139 22 102 54 102 117 102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D45C" d="M201-11Q126-11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441 333 441 341 440 354 437 367 433T402 417 438 387 464 338 476 268Q476 161 390 75T201-11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375 346 405 306 405 243 405 195 347 158 303 140 230T121 120Z"/></g></g></g></g></svg></mjx-container>并入U</p><p>重复上述操作直至<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.186ex" xmlns="http://www.w3.org/2000/svg" width="6.492ex" height="1.731ex" role="img" focusable="false" viewbox="0 -683 2869.6 765"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D448" d="M107 637Q73 637 71 641 70 643 70 649 70 673 81 682 83 683 98 683 139 681 234 681 268 681 297 681T342 682 362 682Q378 682 378 672 378 670 376 658 371 641 366 638H364Q362 638 359 638T352 638 343 637 334 637Q295 636 284 634T266 623Q265 621 238 518T184 302 154 169Q152 155 152 140 152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606 599 633 535 637 511 637 511 648 511 650 513 660 517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672 767 650 759 642 756 637 737 637 666 633 648 597 646 592 598 404 557 235 548 205 515 105 433 42T263-22Q171-22 116 34T60 167V183Q60 201 115 421 164 622 164 628 164 635 107 637Z"/></g><g data-mml-node="mo" transform="translate(1044.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347 722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153 722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(2100.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g></g></g></svg></mjx-container>，则<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="12.437ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5497.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445 21 450 37 501T71 602L88 651Q93 669 101 677H569 659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437 640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631 469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46 418 46 427 45T436 36Q436 31 433 22 429 4 424 1L422 0Q419 0 415 0 410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83 94Q174 46 189 55 190 56 191 56 196 59 201 76T241 233Q258 301 269 344 339 619 339 625 339 630 310 630H279Q212 630 191 624 146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mo" transform="translate(981.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347 722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153 722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(2037.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488 164 576 202 643 244 695 277 729 302 750H315 319Q333 750 333 741 333 738 316 720T275 667 226 581 184 443 167 250 184 58 225-81 274-167 316-220 333-241Q333-250 318-250H315 302L274-226Q180-141 137-14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2426.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mo" transform="translate(3195.6,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(3640.2,0)"><path data-c="1D447" d="M40 437Q21 437 21 445 21 450 37 501T71 602L88 651Q93 669 101 677H569 659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437 640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631 469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46 418 46 427 45T436 36Q436 31 433 22 429 4 424 1L422 0Q419 0 415 0 410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83 94Q174 46 189 55 190 56 191 56 196 59 201 76T241 233Q258 301 269 344 339 619 339 625 339 630 310 630H279Q212 630 191 624 146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(4344.2,0)"><path data-c="1D438" d="M492 213Q472 213 472 226 472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272 690 274 698 274 718 274 718 261 613 7 608 2 605 0 322 0H133Q31 0 31 11 31 13 34 25 38 41 42 43T65 46Q92 46 125 49 139 52 144 61 146 66 215 342T285 622Q285 629 281 629 273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669 764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528 704 558 697 578T678 609 643 625 596 632 532 634H485Q397 633 392 631 388 629 386 622 385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492 572 491 574 487 577 483L544 351Q511 218 508 216 505 213 492 213Z"/></g><g data-mml-node="mo" transform="translate(5108.2,0)"><path data-c="29" d="M60 749 64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12 224-76 186-143 145-194 113-227 90-246Q87-249 86-250H74Q66-250 63-250T58-247 55-238Q56-237 66-225 221-64 221 250T66 725Q56 737 55 738 55 746 60 749Z"/></g></g></g></svg></mjx-container>为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:0" xmlns="http://www.w3.org/2000/svg" width="2.009ex" height="1.545ex" role="img" focusable="false" viewbox="0 -683 888 683"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637 201 637 196 638T191 649Q191 676 202 682 204 683 299 683 376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606 723 633 659 637 635 637 635 648 635 650 637 660 641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672 888 650 880 642 878 637 858 637 787 633 769 597L620 7Q618 0 599 0 585 0 582 2 579 5 453 305L326 604 261 344Q196 88 196 79 201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2 123 2 100 2T63 2 46 1Q31 1 31 10 31 14 34 26T39 40Q41 46 62 46 130 49 150 85 154 91 221 362L289 634Q287 635 234 637Z"/></g></g></g></svg></mjx-container>的最小生成树。</p></blockquote><p>从顶点往下找最小的权</p><h6 id="Kruskal-克鲁斯卡尔算法"><a href="#Kruskal-克鲁斯卡尔算法" class="headerlink" title="Kruskal-克鲁斯卡尔算法"></a>Kruskal-克鲁斯卡尔算法</h6><p>所有边按权值排序,然后选择最小的</p><p>当有循环时舍弃这条边</p><p>当所有边连通时结束</p><p>与prim算法不同的是他是按排序来找最小,prim是依次选最小</p><blockquote><p>设连通网<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="11.261ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4977.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637 201 637 196 638T191 649Q191 676 202 682 204 683 299 683 376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606 723 633 659 637 635 637 635 648 635 650 637 660 641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672 888 650 880 642 878 637 858 637 787 633 769 597L620 7Q618 0 599 0 585 0 582 2 579 5 453 305L326 604 261 344Q196 88 196 79 201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2 123 2 100 2T63 2 46 1Q31 1 31 10 31 14 34 26T39 40Q41 46 62 46 130 49 150 85 154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(1165.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347 722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153 722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(2221.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488 164 576 202 643 244 695 277 729 302 750H315 319Q333 750 333 741 333 738 316 720T275 667 226 581 184 443 167 250 184 58 225-81 274-167 316-220 333-241Q333-250 318-250H315 302L274-226Q180-141 137-14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2610.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mo" transform="translate(3379.6,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(3824.2,0)"><path data-c="1D438" d="M492 213Q472 213 472 226 472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272 690 274 698 274 718 274 718 261 613 7 608 2 605 0 322 0H133Q31 0 31 11 31 13 34 25 38 41 42 43T65 46Q92 46 125 49 139 52 144 61 146 66 215 342T285 622Q285 629 281 629 273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669 764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528 704 558 697 578T678 609 643 625 596 632 532 634H485Q397 633 392 631 388 629 386 622 385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492 572 491 574 487 577 483L544 351Q511 218 508 216 505 213 492 213Z"/></g><g data-mml-node="mo" transform="translate(4588.2,0)"><path data-c="29" d="M60 749 64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12 224-76 186-143 145-194 113-227 90-246Q87-249 86-250H74Q66-250 63-250T58-247 55-238Q56-237 66-225 221-64 221 250T66 725Q56 737 55 738 55 746 60 749Z"/></g></g></g></svg></mjx-container>，令最小生D树初始状态为只有n个顶点而无边的非连通图<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="9.116ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4029.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445 21 450 37 501T71 602L88 651Q93 669 101 677H569 659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437 640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631 469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46 418 46 427 45T436 36Q436 31 433 22 429 4 424 1L422 0Q419 0 415 0 410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83 94Q174 46 189 55 190 56 191 56 196 59 201 76T241 233Q258 301 269 344 339 619 339 625 339 630 310 630H279Q212 630 191 624 146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mo" transform="translate(981.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347 722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153 722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(2037.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488 164 576 202 643 244 695 277 729 302 750H315 319Q333 750 333 741 333 738 316 720T275 667 226 581 184 443 167 250 184 58 225-81 274-167 316-220 333-241Q333-250 318-250H315 302L274-226Q180-141 137-14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2426.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mo" transform="translate(3195.6,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3640.2,0)"/><g data-mml-node="mo" transform="translate(3640.2,0)"><path data-c="29" d="M60 749 64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12 224-76 186-143 145-194 113-227 90-246Q87-249 86-250H74Q66-250 63-250T58-247 55-238Q56-237 66-225 221-64 221 250T66 725Q56 737 55 738 55 746 60 749Z"/></g></g></g></svg></mjx-container>,每个顶点自成一个连通分量。</p><p>在E中选取代价最小的边，若该边依附的顶点落在T中不同的连通分量上(即:不能形成环)，则将此边加入到T中;否则，舍去此边，选取下一条代价最小的边。</p><p>依此类推，直至T中所有顶点都在同一连通分量上为止。</p></blockquote><p>最小生成树可能不唯一</p><h6 id="两种比较"><a href="#两种比较" class="headerlink" title="两种比较"></a>两种比较</h6><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678794300e5fe.png" alt></p><h4 id="2-最短路径"><a href="#2-最短路径" class="headerlink" title="2.最短路径"></a>2.最短路径</h4><h5 id="1-定义-8"><a href="#1-定义-8" class="headerlink" title="1.定义"></a>1.定义</h5><p><strong>最短路径与最小生成树不同</strong>，路径上不一定包含n个顶点，也不一定包含n-1条边。</p><p>单源最短路径-Dijkstra迪杰斯特拉算法</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787943a49d87.png" alt></p><p>所有顶点间的最短路径—Floyd弗洛伊德算法</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787943d6e333.png" alt></p><h5 id="2-Dijkstra算法"><a href="#2-Dijkstra算法" class="headerlink" title="2.Dijkstra算法"></a>2.Dijkstra算法</h5><h6 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h6><blockquote><p>1.初始化:先找出从源点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.375ex" xmlns="http://www.w3.org/2000/svg" width="2.307ex" height="1.92ex" role="img" focusable="false" viewbox="0 -683 1019.6 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mn" transform="translate(616,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666 297 666 345 640T423 548Q460 465 460 320 460 165 417 83 397 41 362 16T301-15 250-22Q224-22 198-16T137 16 82 83Q39 165 39 320 39 494 96 585ZM321 597Q291 629 250 629 208 629 178 597 153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16 290 16 318 46 347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></g></svg></mjx-container>到各终点v的直达路径<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="7.413ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3276.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488 164 576 202 643 244 695 277 729 302 750H315 319Q333 750 333 741 333 738 316 720T275 667 226 581 184 443 167 250 184 58 225-81 274-167 316-220 333-241Q333-250 318-250H315 302L274-226Q180-141 137-14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mn" transform="translate(616,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666 297 666 345 640T423 548Q460 465 460 320 460 165 417 83 397 41 362 16T301-15 250-22Q224-22 198-16T137 16 82 83Q39 165 39 320 39 494 96 585ZM321 597Q291 629 250 629 208 629 178 597 153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16 290 16 318 46 347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(1408.6,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1853.2,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686 294 679 244 477 194 279 194 272 213 282 223 291 247 309 292 354T362 415Q402 442 438 442 468 442 485 423T503 369Q503 344 496 327T477 302 456 291 438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316 228 255Q230 254 243 252T267 246 293 238 320 224 342 206 359 180 365 147Q365 130 360 106T354 66Q354 26 381 26 429 26 459 145 461 153 479 153H483Q499 153 499 144 499 139 496 130 455-11 378-11 333-11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206 200 217 182 220H180Q168 178 159 139T145 81 136 44 129 20 122 7 111-2Q98-11 83-11 66-11 57-1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640 121 647Z"/></g></g><g data-mml-node="mo" transform="translate(2887.6,0)"><path data-c="29" d="M60 749 64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12 224-76 186-143 145-194 113-227 90-246Q87-249 86-250H74Q66-250 63-250T58-247 55-238Q56-237 66-225 221-64 221 250T66 725Q56 737 55 738 55 746 60 749Z"/></g></g></g></svg></mjx-container>, 即通过一条弧到达的路径。</p><p>2选择:从这些路径中找出一条长度最短的路径<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="6.121ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2705.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488 164 576 202 643 244 695 277 729 302 750H315 319Q333 750 333 741 333 738 316 720T275 667 226 581 184 443 167 250 184 58 225-81 274-167 316-220 333-241Q333-250 318-250H315 302L274-226Q180-141 137-14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405 130 405 104 376T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287 21 294 29 316T53 368 97 419 160 441Q202 441 225 417T249 361Q249 344 246 335 246 329 231 291T200 202 182 113Q182 86 187 69 200 26 250 26 287 26 319 60T369 139 398 222 409 277Q409 300 401 317T383 343 365 361 357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159 347 40 241-11Q177-11 139 22 102 54 102 117 102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D45C" d="M201-11Q126-11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441 333 441 341 440 354 437 367 433T402 417 438 387 464 338 476 268Q476 161 390 75T201-11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375 346 405 306 405 243 405 195 347 158 303 140 230T121 120Z"/></g></g><g data-mml-node="mo" transform="translate(1299.9,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1744.6,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370 99 420 158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27 291 44 328 78L339 95Q341 99 377 247 407 367 413 387T427 416Q444 431 463 431 480 431 488 421T496 402L420 84Q419 79 419 68 419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153 551 153 551 144 550 139 549 130T540 98 523 55 498 17 462-8Q454-10 438-10 372-10 347 46 345 45 336 36T318 21 296 6 267-6 233-11Q189-11 155 7 103 38 103 113 103 170 138 262T173 379Q173 380 173 381 173 390 173 393T169 400 158 404H154Q131 404 112 385T82 344 65 302 57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2316.6,0)"><path data-c="29" d="M60 749 64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12 224-76 186-143 145-194 113-227 90-246Q87-249 86-250H74Q66-250 63-250T58-247 55-238Q56-237 66-225 221-64 221 250T66 725Q56 737 55 738 55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p><p>3.更新:然后对其余各条路径进行适当调整:</p><p>​ 若在图中存在弧<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="6.401ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2829.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488 164 576 202 643 244 695 277 729 302 750H315 319Q333 750 333 741 333 738 316 720T275 667 226 581 184 443 167 250 184 58 225-81 274-167 316-220 333-241Q333-250 318-250H315 302L274-226Q180-141 137-14T94 250Z"/></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370 99 420 158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27 291 44 328 78L339 95Q341 99 377 247 407 367 413 387T427 416Q444 431 463 431 480 431 488 421T496 402L420 84Q419 79 419 68 419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153 551 153 551 144 550 139 549 130T540 98 523 55 498 17 462-8Q454-10 438-10 372-10 347 46 345 45 336 36T318 21 296 6 267-6 233-11Q189-11 155 7 103 38 103 113 103 170 138 262T173 379Q173 380 173 381 173 390 173 393T169 400 158 404H154Q131 404 112 385T82 344 65 302 57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(961,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1405.7,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686 294 679 244 477 194 279 194 272 213 282 223 291 247 309 292 354T362 415Q402 442 438 442 468 442 485 423T503 369Q503 344 496 327T477 302 456 291 438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316 228 255Q230 254 243 252T267 246 293 238 320 224 342 206 359 180 365 147Q365 130 360 106T354 66Q354 26 381 26 429 26 459 145 461 153 479 153H483Q499 153 499 144 499 139 496 130 455-11 378-11 333-11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206 200 217 182 220H180Q168 178 159 139T145 81 136 44 129 20 122 7 111-2Q98-11 83-11 66-11 57-1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640 121 647Z"/></g></g><g data-mml-node="mo" transform="translate(2440.1,0)"><path data-c="29" d="M60 749 64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12 224-76 186-143 145-194 113-227 90-246Q87-249 86-250H74Q66-250 63-250T58-247 55-238Q56-237 66-225 221-64 221 250T66 725Q56 737 55 738 55 746 60 749Z"/></g></g></g></svg></mjx-container>，且<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="25.029ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 11062.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488 164 576 202 643 244 695 277 729 302 750H315 319Q333 750 333 741 333 738 316 720T275 667 226 581 184 443 167 250 184 58 225-81 274-167 316-220 333-241Q333-250 318-250H315 302L274-226Q180-141 137-14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405 130 405 104 376T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287 21 294 29 316T53 368 97 419 160 441Q202 441 225 417T249 361Q249 344 246 335 246 329 231 291T200 202 182 113Q182 86 187 69 200 26 250 26 287 26 319 60T369 139 398 222 409 277Q409 300 401 317T383 343 365 361 357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159 347 40 241-11Q177-11 139 22 102 54 102 117 102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D45C" d="M201-11Q126-11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441 333 441 341 440 354 437 367 433T402 417 438 387 464 338 476 268Q476 161 390 75T201-11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375 346 405 306 405 243 405 195 347 158 303 140 230T121 120Z"/></g></g><g data-mml-node="mo" transform="translate(1299.9,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1744.6,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370 99 420 158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27 291 44 328 78L339 95Q341 99 377 247 407 367 413 387T427 416Q444 431 463 431 480 431 488 421T496 402L420 84Q419 79 419 68 419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153 551 153 551 144 550 139 549 130T540 98 523 55 498 17 462-8Q454-10 438-10 372-10 347 46 345 45 336 36T318 21 296 6 267-6 233-11Q189-11 155 7 103 38 103 113 103 170 138 262T173 379Q173 380 173 381 173 390 173 393T169 400 158 404H154Q131 404 112 385T82 344 65 302 57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2316.6,0)"><path data-c="29" d="M60 749 64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12 224-76 186-143 145-194 113-227 90-246Q87-249 86-250H74Q66-250 63-250T58-247 55-238Q56-237 66-225 221-64 221 250T66 725Q56 737 55 738 55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2927.8,0)"><path data-c="2B" d="M56 237T56 250 70 270H369V420L370 570Q380 583 389 583 402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401-82 391-82H389 387Q375-82 369-68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mo" transform="translate(3928.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488 164 576 202 643 244 695 277 729 302 750H315 319Q333 750 333 741 333 738 316 720T275 667 226 581 184 443 167 250 184 58 225-81 274-167 316-220 333-241Q333-250 318-250H315 302L274-226Q180-141 137-14T94 250Z"/></g><g data-mml-node="mi" transform="translate(4317.1,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370 99 420 158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27 291 44 328 78L339 95Q341 99 377 247 407 367 413 387T427 416Q444 431 463 431 480 431 488 421T496 402L420 84Q419 79 419 68 419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153 551 153 551 144 550 139 549 130T540 98 523 55 498 17 462-8Q454-10 438-10 372-10 347 46 345 45 336 36T318 21 296 6 267-6 233-11Q189-11 155 7 103 38 103 113 103 170 138 262T173 379Q173 380 173 381 173 390 173 393T169 400 158 404H154Q131 404 112 385T82 344 65 302 57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(4889.1,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(5333.7,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405 130 405 104 376T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287 21 294 29 316T53 368 97 419 160 441Q202 441 225 417T249 361Q249 344 246 335 246 329 231 291T200 202 182 113Q182 86 187 69 200 26 250 26 287 26 319 60T369 139 398 222 409 277Q409 300 401 317T383 343 365 361 357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159 347 40 241-11Q177-11 139 22 102 54 102 117 102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686 294 679 244 477 194 279 194 272 213 282 223 291 247 309 292 354T362 415Q402 442 438 442 468 442 485 423T503 369Q503 344 496 327T477 302 456 291 438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316 228 255Q230 254 243 252T267 246 293 238 320 224 342 206 359 180 365 147Q365 130 360 106T354 66Q354 26 381 26 429 26 459 145 461 153 479 153H483Q499 153 499 144 499 139 496 130 455-11 378-11 333-11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206 200 217 182 220H180Q168 178 159 139T145 81 136 44 129 20 122 7 111-2Q98-11 83-11 66-11 57-1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640 121 647Z"/></g></g><g data-mml-node="mo" transform="translate(6270.1,0)"><path data-c="29" d="M60 749 64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12 224-76 186-143 145-194 113-227 90-246Q87-249 86-250H74Q66-250 63-250T58-247 55-238Q56-237 66-225 221-64 221 250T66 725Q56 737 55 738 55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(6936.9,0)"><path data-c="3C" d="M694-11T694-19 688-33 678-40Q671-40 524 29T234 166L90 235Q83 240 83 250 83 261 91 266 664 540 678 540 681 540 687 534T694 519 687 505Q686 504 417 376L151 250 417 124Q686-4 687-5 694-11 694-19Z"/></g><g data-mml-node="mo" transform="translate(7992.7,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488 164 576 202 643 244 695 277 729 302 750H315 319Q333 750 333 741 333 738 316 720T275 667 226 581 184 443 167 250 184 58 225-81 274-167 316-220 333-241Q333-250 318-250H315 302L274-226Q180-141 137-14T94 250Z"/></g><g data-mml-node="msub" transform="translate(8381.7,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405 130 405 104 376T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287 21 294 29 316T53 368 97 419 160 441Q202 441 225 417T249 361Q249 344 246 335 246 329 231 291T200 202 182 113Q182 86 187 69 200 26 250 26 287 26 319 60T369 139 398 222 409 277Q409 300 401 317T383 343 365 361 357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159 347 40 241-11Q177-11 139 22 102 54 102 117 102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D45C" d="M201-11Q126-11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441 333 441 341 440 354 437 367 433T402 417 438 387 464 338 476 268Q476 161 390 75T201-11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375 346 405 306 405 243 405 195 347 158 303 140 230T121 120Z"/></g></g><g data-mml-node="mo" transform="translate(9292.6,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(9737.3,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405 130 405 104 376T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287 21 294 29 316T53 368 97 419 160 441Q202 441 225 417T249 361Q249 344 246 335 246 329 231 291T200 202 182 113Q182 86 187 69 200 26 250 26 287 26 319 60T369 139 398 222 409 277Q409 300 401 317T383 343 365 361 357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159 347 40 241-11Q177-11 139 22 102 54 102 117 102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686 294 679 244 477 194 279 194 272 213 282 223 291 247 309 292 354T362 415Q402 442 438 442 468 442 485 423T503 369Q503 344 496 327T477 302 456 291 438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316 228 255Q230 254 243 252T267 246 293 238 320 224 342 206 359 180 365 147Q365 130 360 106T354 66Q354 26 381 26 429 26 459 145 461 153 479 153H483Q499 153 499 144 499 139 496 130 455-11 378-11 333-11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206 200 217 182 220H180Q168 178 159 139T145 81 136 44 129 20 122 7 111-2Q98-11 83-11 66-11 57-1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640 121 647Z"/></g></g><g data-mml-node="mo" transform="translate(10673.7,0)"><path data-c="29" d="M60 749 64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12 224-76 186-143 145-194 113-227 90-246Q87-249 86-250H74Q66-250 63-250T58-247 55-238Q56-237 66-225 221-64 221 250T66 725Q56 737 55 738 55 746 60 749Z"/></g></g></g></svg></mjx-container>则以路径<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="9.689ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4282.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488 164 576 202 643 244 695 277 729 302 750H315 319Q333 750 333 741 333 738 316 720T275 667 226 581 184 443 167 250 184 58 225-81 274-167 316-220 333-241Q333-250 318-250H315 302L274-226Q180-141 137-14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D45C" d="M201-11Q126-11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441 333 441 341 440 354 437 367 433T402 417 438 387 464 338 476 268Q476 161 390 75T201-11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375 346 405 306 405 243 405 195 347 158 303 140 230T121 120Z"/></g></g><g data-mml-node="mo" transform="translate(1397.9,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1842.6,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370 99 420 158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27 291 44 328 78L339 95Q341 99 377 247 407 367 413 387T427 416Q444 431 463 431 480 431 488 421T496 402L420 84Q419 79 419 68 419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153 551 153 551 144 550 139 549 130T540 98 523 55 498 17 462-8Q454-10 438-10 372-10 347 46 345 45 336 36T318 21 296 6 267-6 233-11Q189-11 155 7 103 38 103 113 103 170 138 262T173 379Q173 380 173 381 173 390 173 393T169 400 158 404H154Q131 404 112 385T82 344 65 302 57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2414.6,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(2859.3,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686 294 679 244 477 194 279 194 272 213 282 223 291 247 309 292 354T362 415Q402 442 438 442 468 442 485 423T503 369Q503 344 496 327T477 302 456 291 438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316 228 255Q230 254 243 252T267 246 293 238 320 224 342 206 359 180 365 147Q365 130 360 106T354 66Q354 26 381 26 429 26 459 145 461 153 479 153H483Q499 153 499 144 499 139 496 130 455-11 378-11 333-11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206 200 217 182 220H180Q168 178 159 139T145 81 136 44 129 20 122 7 111-2Q98-11 83-11 66-11 57-1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640 121 647Z"/></g></g><g data-mml-node="mo" transform="translate(3893.7,0)"><path data-c="29" d="M60 749 64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12 224-76 186-143 145-194 113-227 90-246Q87-249 86-250H74Q66-250 63-250T58-247 55-238Q56-237 66-225 221-64 221 250T66 725Q56 737 55 738 55 746 60 749Z"/></g></g></g></svg></mjx-container>代替<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="7.348ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3247.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488 164 576 202 643 244 695 277 729 302 750H315 319Q333 750 333 741 333 738 316 720T275 667 226 581 184 443 167 250 184 58 225-81 274-167 316-220 333-241Q333-250 318-250H315 302L274-226Q180-141 137-14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405 130 405 104 376T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287 21 294 29 316T53 368 97 419 160 441Q202 441 225 417T249 361Q249 344 246 335 246 329 231 291T200 202 182 113Q182 86 187 69 200 26 250 26 287 26 319 60T369 139 398 222 409 277Q409 300 401 317T383 343 365 361 357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159 347 40 241-11Q177-11 139 22 102 54 102 117 102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D45C" d="M201-11Q126-11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441 333 441 341 440 354 437 367 433T402 417 438 387 464 338 476 268Q476 161 390 75T201-11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375 346 405 306 405 243 405 195 347 158 303 140 230T121 120Z"/></g></g><g data-mml-node="mo" transform="translate(1299.9,0)"><path data-c="2C" d="M78 35T78 60 94 103 137 121Q165 121 187 96T210 8Q210-27 201-60T180-117 154-158 130-185 117-194Q113-194 104-185T95-172Q95-168 106-156T131-126 157-76 173-3V9L172 8Q170 7 167 6T161 3 152 1 140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1744.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(2513.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369 98 420 158 442Q197 442 223 419T250 357Q250 340 236 301T196 196 154 83Q149 61 149 51 149 26 166 26 175 26 185 29T208 43 235 78 260 137Q263 149 265 151T282 153Q302 153 302 143 302 135 293 112T268 61 223 11 161-11Q129-11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2858.6,0)"><path data-c="29" d="M60 749 64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12 224-76 186-143 145-194 113-227 90-246Q87-249 86-250H74Q66-250 63-250T58-247 55-238Q56-237 66-225 221-64 221 250T66 725Q56 737 55 738 55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p><p>在调整后的各条路径中，再找长度最短的路径)依此类推。</p><p>(先找出直达的,然后与不直达的比较,有小的就更新被比较的)</p></blockquote><h6 id="具体-按路径长度递增次序产生最短路径"><a href="#具体-按路径长度递增次序产生最短路径" class="headerlink" title="具体-按路径长度递增次序产生最短路径"></a>具体-按路径长度递增次序产生最短路径</h6><blockquote><p>1、把V分成两组:辅助数组D存放。<br>(1) S:已求出最短路径的顶点的集合。<br>(2)T=V -s∶尚未确定最短路径的顶点集合。</p><p>2、将T中顶点按最短路径递增的次序加入到S中，</p><p>保证:(1）从源点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.357ex" xmlns="http://www.w3.org/2000/svg" width="2.061ex" height="1.359ex" role="img" focusable="false" viewbox="0 -443 910.9 600.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405 130 405 104 376T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287 21 294 29 316T53 368 97 419 160 441Q202 441 225 417T249 361Q249 344 246 335 246 329 231 291T200 202 182 113Q182 86 187 69 200 26 250 26 287 26 319 60T369 139 398 222 409 277Q409 300 401 317T383 343 365 361 357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159 347 40 241-11Q177-11 139 22 102 54 102 117 102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D45C" d="M201-11Q126-11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441 333 441 341 440 354 437 367 433T402 417 438 387 464 338 476 268Q476 161 390 75T201-11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375 346 405 306 405 243 405 195 347 158 303 140 230T121 120Z"/></g></g></g></g></svg></mjx-container>到S中各顶点的最短路径长度都不大于从<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.375ex" xmlns="http://www.w3.org/2000/svg" width="2.307ex" height="1.92ex" role="img" focusable="false" viewbox="0 -683 1019.6 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680 299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635 245 630 242 620 242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609 599 633 555 637 537 637 537 648 537 649 539 661 542 675 545 679T558 683Q560 683 570 683T604 682 668 681Q737 681 755 683H762Q769 676 769 672 769 655 760 640 757 637 743 637 730 636 719 635T698 630 682 623 670 615 660 608 652 599 645 592L452 282Q272-9 266-16 263-18 259-21L241-22H234Q216-22 216-15 213-9 177 305 139 623 138 626 133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mn" transform="translate(616,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666 297 666 345 640T423 548Q460 465 460 320 460 165 417 83 397 41 362 16T301-15 250-22Q224-22 198-16T137 16 82 83Q39 165 39 320 39 494 96 585ZM321 597Q291 629 250 629 208 629 178 597 153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16 290 16 318 46 347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></g></svg></mjx-container>到T中任何顶点的最短路径长度。</p><p>(2)每个顶点对应一个距离值:<br>S中顶点:从<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.357ex" xmlns="http://www.w3.org/2000/svg" width="2.061ex" height="1.359ex" role="img" focusable="false" viewbox="0 -443 910.9 600.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405 130 405 104 376T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287 21 294 29 316T53 368 97 419 160 441Q202 441 225 417T249 361Q249 344 246 335 246 329 231 291T200 202 182 113Q182 86 187 69 200 26 250 26 287 26 319 60T369 139 398 222 409 277Q409 300 401 317T383 343 365 361 357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159 347 40 241-11Q177-11 139 22 102 54 102 117 102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D45C" d="M201-11Q126-11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441 333 441 341 440 354 437 367 433T402 417 438 387 464 338 476 268Q476 161 390 75T201-11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375 346 405 306 405 243 405 195 347 158 303 140 230T121 120Z"/></g></g></g></g></svg></mjx-container>到此顶点的最短路径长度。</p><p>​ T中顶点:从<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.357ex" xmlns="http://www.w3.org/2000/svg" width="2.061ex" height="1.359ex" role="img" focusable="false" viewbox="0 -443 910.9 600.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405 130 405 104 376T61 287Q60 286 59 284T58 281 56 279 53 278 49 278 41 278H27Q21 284 21 287 21 294 29 316T53 368 97 419 160 441Q202 441 225 417T249 361Q249 344 246 335 246 329 231 291T200 202 182 113Q182 86 187 69 200 26 250 26 287 26 319 60T369 139 398 222 409 277Q409 300 401 317T383 343 365 361 357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159 347 40 241-11Q177-11 139 22 102 54 102 117 102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D45C" d="M201-11Q126-11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441 333 441 341 440 354 437 367 433T402 417 438 387 464 338 476 268Q476 161 390 75T201-11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375 346 405 306 405 243 405 195 347 158 303 140 230T121 120Z"/></g></g></g></g></svg></mjx-container>到此顶点的只包括S中顶点作中间顶点的最短路径长度。</p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67879440514d7.png" alt></p><h5 id="3-Floyd-弗洛伊德算法"><a href="#3-Floyd-弗洛伊德算法" class="headerlink" title="3.Floyd 弗洛伊德算法"></a>3.Floyd 弗洛伊德算法</h5><h6 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h6><ul><li>·逐个顶点试探</li><li>·从到v,的所有可能存在的路径中·</li><li><p>选出一条长度最短的路径</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678794435647b.png" alt></p></li></ul><h4 id="3-拓扑排序"><a href="#3-拓扑排序" class="headerlink" title="3.拓扑排序"></a>3.拓扑排序</h4><p>有向无环图：无环的有向图，简称DAG</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67879445bb557.png" alt></p><p>一个结点可能有多个前驱，但是没有回路</p><h5 id="1-AOV网"><a href="#1-AOV网" class="headerlink" title="1.AOV网"></a>1.AOV网</h5><h6 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h6><p>用一个有向图表示一个工程的各子工程及其相冥制约的关系，其中<strong>以顶点表示活动</strong>，<strong>弧表示活动之间的优先制约关系</strong>，称这种有向图为<strong>顶点表示活动的网</strong>，简称AOV网(Activity On Vertex network)</p><h6 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h6><ul><li>若从i到j有一条有向路径，则i是j的前驱;j是i的后继。</li><li>若<i ,j>是网中有向边，则i是j的直接前驱;j是i的直接后继</i></li><li>AOV网中不允许有回路，因为如果有回路存在，则表明某项活动以自己为先决条件，显然这是荒谬的。</li></ul><h6 id="检测AOV-网中是否存在环方法"><a href="#检测AOV-网中是否存在环方法" class="headerlink" title="检测AOV 网中是否存在环方法:"></a>检测AOV 网中是否存在环方法:</h6><p>对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV 网必定不存在环。</p><h5 id="2-AOE网"><a href="#2-AOE网" class="headerlink" title="2.AOE网"></a>2.AOE网</h5><p>用一个有向图表承一个工程的各子工程及其相互制约的关系,以<strong>弧表示活动</strong>，以<strong>顶点表示活动的开始或结束事件</strong>，称这种有向图为<strong>边表示活动的网</strong>，简称为AOE网(Activity On Edge)。</p><h5 id="3-拓扑排序-1"><a href="#3-拓扑排序-1" class="headerlink" title="3.拓扑排序"></a>3.拓扑排序</h5><p>在AOV网没有回路的前提下，我们将全部活动排列成一个线性序列，使得若AOV网中有弧<i ,j>存在，则在这个序列甲，I一疋排仕J的前面，具有这种性质的线性序列称为<strong>拓扑有序序列</strong>，相应的拓扑有序排序的算法称为<strong>拓扑排序。</strong></i></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67879447897b0.png" alt></p><h4 id="4-关键路径"><a href="#4-关键路径" class="headerlink" title="4.关键路径"></a>4.关键路径</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/67879448cf99e.png" alt></p><p>对于AOE网，我们关心两个问题:</p><p>(1)完成整项工程至少需要多少时间?</p><p>(2)哪些活动是影响工程进度的关键?</p><p>关键路径 ：路径长度最长的路径。<br>路径长度：路径上各活动持续时间之和。</p><p>———&gt;求解关键路径问题</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787944a28050.png" alt></p><p>由若干个关键活动组成的就是关键路径</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787944b6b543.png" alt></p><p>ve(j)最早开始时间：从原点开始找到权的最大值</p><p>vl(n)最迟发生时间：从汇点向前，找到最小值</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787944d1e382.png" alt></p><p>具体计算</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/6787944e77dc7.png" alt></p><p>e(i)就是弧尾的长度</p><p>​ eg: v5就是6（v5连接的是v2，只用算v2），</p><p>l(i)就是vl-路径上的权值</p><p>​ eg: v5就是7-a4的权=7-1=6</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/01/15/678794379647b.png" alt></p><h5 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h5><p>1、若网中有几条关键路径,则需加快同时在几条关键路径上的关键活动。<br>如: a11、a10、a8、a7。</p><p>2、如果一个活动处于所有的关键路径上，那么提高这个活动的速度，就能缩短整个工程的完成时间。如: a1、a4。</p><p>3、处于所有的关键路径上的活动完成时间不能缩短太多)，否则会使原来的关键路径变成不是关键路径。这时，必须重新寻找关键路径。</p><p>​ 如:a1由6天变成3天，就会改变关键路径。</p></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/03/01/67c2609b7c10b.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/03/01/67c2609b7c10b.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">李阳</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://blog.baskly.fun/posts/79666db/">原创</a><a class="post-copyright-title"><span onclick='rm.copyPageUrl("https://blog.baskly.fun/posts/79666db/")'>数据结构</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://blog.baskly.fun/posts/79666db/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=数据结构&amp;url=https://blog.baskly.fun/posts/79666db/&amp;pic=https://bu.dusays.com/2024/12/15/675eec5c414d7.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl(){var e=window.location.href,t=document.createElement("input");t.setAttribute("value",e),document.body.appendChild(t),t.select(),t.setSelectionRange(0,99999),document.execCommand("copy"),document.body.removeChild(t)}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.baskly.fun" target="_blank">李阳的秘密小屋</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/408/"><span class="categoryes-punctuation"><i class="anzhiyufont anzhiyu-icon-inbox"></i></span> 408<span class="categoryesPageCount">6</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tags-punctuation"><i class="anzhiyufont anzhiyu-icon-tag"></i></span> 数据结构<span class="tagsPageCount">1</span></a></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2024/12/24/676a8d8bc7d9f.png?_r_=b766501c-375f-d622-6ca5-bfbc65ab58d7" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/66e64d45/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2024/11/24/674340e1191e4.png?_r_=8c734623-57bc-6b24-1ae3-19d402d0b459" onerror='onerror=null,src="https://bu.dusays.com/2025/05/30/68398ca86a127.gif"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">考研408大纲</div></div></a></div><div class="next-post pull-right"><a href="/posts/fc2c180e/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="/" onerror='onerror=null,src="https://bu.dusays.com/2025/05/30/68398ca86a127.gif"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络期末版</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i> <span>评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left:4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/03/01/67c2609b7c10b.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"><div class="author-status"><img class="g-status" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2021/01/15/805daa7195f2c.gif" alt="status"></div></div><div class="author-info__description"><div style="line-height:1.38;margin:.6rem 0;text-align:justify;color:rgba(255,255,255,.8)">这有描绘<b style="color:#fff">我的痕迹</b></div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about"><h1 class="author-info__name">李阳</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/lyay23" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">C语言—数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">一、数据结构之基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.数据结构的三要素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%9C%89%E5%87%A0%E7%A7%8D"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">数据的存储结构有几种</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">2、存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">顺序结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">链式存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">索引存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">散列存储</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%AE%97%E6%B3%95%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.算法特征：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%BD%E7%AE%97%E6%B3%95%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">好算法特征：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">二、链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.数组的优缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%AF%E8%AF%AD%EF%BC%9A"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.术语：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A6%96%E8%8A%82%E7%82%B9"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">首节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BE%E8%8A%82%E7%82%B9"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">尾节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E7%BB%93%E7%82%B9%EF%BC%9A"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">头结点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E6%8C%87%E9%92%88"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">头指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.4.</span> <span class="toc-text">4.链表的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-number">1.2.5.</span> <span class="toc-text">5.分类：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.6.</span> <span class="toc-text">6.算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%88%9B%E5%BB%BA%E5%B8%A6%E5%A4%B4%E5%8D%95%E9%93%BE%E8%A1%A8%E5%B9%B6%E9%81%8D%E5%8E%86%E8%BE%93%E5%87%BA"><span class="toc-number">1.2.7.</span> <span class="toc-text">7.创建带头单链表并遍历输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E2%80%BB%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E2%80%BB"><span class="toc-number">1.2.8.</span> <span class="toc-text">8.※链表的基本操作※</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%9D%8E%E9%98%B3%E7%9A%84%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">1.2.9.</span> <span class="toc-text">9.李阳的线性表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E6%9D%8E%E9%98%B3%E7%9A%84%E5%B8%A6%E5%A4%B4%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.10.</span> <span class="toc-text">10.李阳的带头单链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%A0%88"><span class="toc-number">1.3.</span> <span class="toc-text">三、栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.4.</span> <span class="toc-text">4.应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%A0%88%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E2%80%94%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89"><span class="toc-number">1.3.5.</span> <span class="toc-text">5.栈的表达式求值—后缀表达式（逆波兰表达式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E4%B8%AD%E7%BC%80"><span class="toc-number">1.3.6.</span> <span class="toc-text">6.后缀表达式转中缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%9D%8E%E9%98%B3%E7%9A%84%E6%A0%88"><span class="toc-number">1.3.7.</span> <span class="toc-text">7.李阳的栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%98%9F%E5%88%97"><span class="toc-number">1.4.</span> <span class="toc-text">四、队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">1、定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%86%E7%B1%BB-1"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%98%9F%E5%88%97%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.队列的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9D%8E%E9%98%B3%E7%9A%84%E9%98%9F%E5%88%97"><span class="toc-number">1.4.5.</span> <span class="toc-text">5.李阳的队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%9D%8E%E9%98%B3%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.4.6.</span> <span class="toc-text">6.李阳的循环队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%80%92%E5%BD%92"><span class="toc-number">1.5.</span> <span class="toc-text">五、递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8%E2%80%94%E9%98%B6%E5%B1%82"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.简单应用—阶层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9A%E4%B9%89%EF%BC%8C%E8%A6%81%E6%B1%82%EF%BC%8C%E6%84%8F%E4%B9%89"><span class="toc-number">1.5.2.</span> <span class="toc-text">2.定义，要求，意义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">①定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E9%80%92%E5%BD%92%E9%9C%80%E8%A6%81%E6%BB%A1%E8%B6%B3%E7%9A%84%E4%B8%89%E4%B8%AA%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">②递归需要满足的三个条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E6%84%8F%E4%B9%89"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">③意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E5%BE%AA%E7%8E%AF%EF%BC%9A"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">④循环：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="toc-number">1.6.</span> <span class="toc-text">六、串、数组和广义表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%B2%EF%BC%88string%EF%BC%89"><span class="toc-number">1.6.1.</span> <span class="toc-text">一、串（string）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AD%90%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">1.子串的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%B2%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%90%E7%AE%97"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">2.串的类型定义、存储结构及运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%B2%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">3.串的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.6.1.3.1.</span> <span class="toc-text">顺序存储</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8-1"><span class="toc-number">1.6.1.3.2.</span> <span class="toc-text">链式存储</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">1.6.1.4.</span> <span class="toc-text">4.串的模式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-BF%E7%AE%97%E6%B3%95%EF%BC%88%E7%A9%B7%E4%B8%BE%E6%B3%95%EF%BC%89"><span class="toc-number">1.6.1.4.1.</span> <span class="toc-text">1.BF算法（穷举法）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E2%80%BB%E2%80%BB%E2%80%BB-KMP%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.1.4.2.</span> <span class="toc-text">2.※※※ KMP算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-KMP%E7%AE%97%E6%B3%95%E6%94%B9%E8%BF%9B"><span class="toc-number">1.6.1.4.3.</span> <span class="toc-text">3.KMP算法改进</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.2.</span> <span class="toc-text">二、数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89-1"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">2.存储位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">3.压缩存储</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5"><span class="toc-number">1.6.2.3.1.</span> <span class="toc-text">1.对称矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.6.2.3.1.1.</span> <span class="toc-text">[特点]</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.2.3.1.2.</span> <span class="toc-text">[存储方法]</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5"><span class="toc-number">1.6.2.3.2.</span> <span class="toc-text">2.三角矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-number">1.6.2.3.2.1.</span> <span class="toc-text">[特点]</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%96%B9%E6%B3%95-1"><span class="toc-number">1.6.2.3.2.2.</span> <span class="toc-text">[存储方法]</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5%EF%BC%88%E5%B8%A6%E7%8A%B6%E7%9F%A9%E9%98%B5%EF%BC%89"><span class="toc-number">1.6.2.3.3.</span> <span class="toc-text">3.对角矩阵（带状矩阵）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5"><span class="toc-number">1.6.2.3.4.</span> <span class="toc-text">4.稀疏矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="toc-number">1.6.2.3.4.1.</span> <span class="toc-text">十字链表</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="toc-number">1.6.3.</span> <span class="toc-text">三.广义表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89-2"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%80%A7%E8%B4%A8"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">2.性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B9%BF%E4%B9%89%E8%A1%A8%E5%92%8C%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">3.广义表和线性表的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B9%BF%E4%B9%89%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97"><span class="toc-number">1.6.3.4.</span> <span class="toc-text">4.广义表的基本运算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%A0%91"><span class="toc-number">1.7.</span> <span class="toc-text">七、树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.7.1.</span> <span class="toc-text">1.树的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">树的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">树的基本术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%BB%93%E6%9E%84%E5%92%8C%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">树结构和线性结构的比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.7.2.</span> <span class="toc-text">2.二叉树的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-2"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8C%BA%E5%88%AB"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">树和二叉树区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A1%88%E4%BE%8B%E5%BC%95%E7%94%A8"><span class="toc-number">1.7.3.</span> <span class="toc-text">3.案例引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-number">1.7.4.</span> <span class="toc-text">4.树和二叉树的抽象数据类型定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8%E5%92%8C%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.5.</span> <span class="toc-text">5.二叉树的性质和存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%80%A7%E8%B4%A8"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">1.性质</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.7.5.1.1.</span> <span class="toc-text">满二叉树与完全二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%A7%E8%B4%A81"><span class="toc-number">1.7.5.1.1.1.</span> <span class="toc-text">性质1</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%A7%E8%B4%A82"><span class="toc-number">1.7.5.1.1.2.</span> <span class="toc-text">性质2</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%A7%E8%B4%A83"><span class="toc-number">1.7.5.1.1.3.</span> <span class="toc-text">性质3</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%A7%E8%B4%A84"><span class="toc-number">1.7.5.1.1.4.</span> <span class="toc-text">性质4</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%A7%E8%B4%A85"><span class="toc-number">1.7.5.1.1.5.</span> <span class="toc-text">性质5</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.5.2.</span> <span class="toc-text">2.存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.5.2.1.</span> <span class="toc-text">1.二叉树的顺序存储结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.5.2.2.</span> <span class="toc-text">2.二叉树的链式存储结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%B8%89%E5%8F%89%E9%93%BE%E8%A1%A8"><span class="toc-number">1.7.5.2.3.</span> <span class="toc-text">3.三叉链表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.7.5.3.</span> <span class="toc-text">3.遍历二叉树和线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.5.3.1.</span> <span class="toc-text">1.类型</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%88%E2%80%94%E6%A0%B9%E5%B7%A6%E5%8F%B3"><span class="toc-number">1.7.5.3.1.1.</span> <span class="toc-text">先—根左右</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%AD%E2%80%94%E5%B7%A6%E6%A0%B9%E5%8F%B3"><span class="toc-number">1.7.5.3.1.2.</span> <span class="toc-text">中—左根右</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%8E%E2%80%94%E5%B7%A6%E5%8F%B3%E6%A0%B9"><span class="toc-number">1.7.5.3.1.3.</span> <span class="toc-text">后—左右根</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%A0%B9%E6%8D%AE%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E7%A1%AE%E5%AE%9A%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%85%88-%E4%B8%AD-%E5%90%8E%E5%BA%8F%EF%BC%89"><span class="toc-number">1.7.5.3.2.</span> <span class="toc-text">2.根据遍历序列确定二叉树（先 中 后序）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B1%EF%BC%9A%E5%85%88%E5%BA%8F-%E4%B8%AD%E5%BA%8F"><span class="toc-number">1.7.5.3.2.1.</span> <span class="toc-text">实例1：先序+中序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B2%E2%80%94%E4%B8%AD%E5%BA%8F-%E5%90%8E%E7%BB%AD"><span class="toc-number">1.7.5.3.2.2.</span> <span class="toc-text">实例2—中序+后续</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%81%8D%E5%8E%86%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.5.3.3.</span> <span class="toc-text">3.遍历的算法实现-先序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.5.3.3.1.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A"><span class="toc-number">1.7.5.3.3.2.</span> <span class="toc-text">递归代码解释</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E9%81%8D%E5%8E%86%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.5.3.4.</span> <span class="toc-text">4.遍历的算法实现-中序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%8E%86%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.5.3.5.</span> <span class="toc-text">5.历的算法实现-后序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.5.3.6.</span> <span class="toc-text">6.二叉树遍历小总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95-%E6%A0%88"><span class="toc-number">1.7.5.3.7.</span> <span class="toc-text">7.中序遍历非递归算法-栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.5.3.8.</span> <span class="toc-text">8.二叉树的层次遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.7.5.3.9.</span> <span class="toc-text">9.二叉树遍历算法的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-number">1.7.5.3.9.1.</span> <span class="toc-text">1.二叉树的建立</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%A4%8D%E5%88%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.7.5.3.9.2.</span> <span class="toc-text">2.复制二叉树</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-number">1.7.5.3.9.3.</span> <span class="toc-text">3.计算二叉树的深度</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9%E6%80%BB%E6%95%B0"><span class="toc-number">1.7.5.3.9.4.</span> <span class="toc-text">4.计算二叉树的结点总数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-%E8%AE%A1%E7%AE%97%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">1.7.5.3.9.5.</span> <span class="toc-text">5.计算叶子结点的个数</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.7.5.3.10.</span> <span class="toc-text">10.线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89-3"><span class="toc-number">1.7.5.3.10.1.</span> <span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%94%BB%E6%B3%95"><span class="toc-number">1.7.5.3.10.2.</span> <span class="toc-text">2.线索二叉树画法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.5.3.10.3.</span> <span class="toc-text">3.遍历算法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-%E6%9D%8E%E9%98%B3%E7%9A%84%E4%BA%A4%E6%8D%A2%E5%B7%A6%E5%8F%B3%E5%AD%90%E6%A0%91"><span class="toc-number">1.7.5.3.11.</span> <span class="toc-text">11.李阳的交换左右子树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97"><span class="toc-number">1.7.6.</span> <span class="toc-text">6.树和森林</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89-4"><span class="toc-number">1.7.6.1.</span> <span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">1.7.6.2.</span> <span class="toc-text">2.双亲表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AD%A9%E5%AD%90%E9%93%BE%E8%A1%A8"><span class="toc-number">1.7.6.3.</span> <span class="toc-text">3.孩子链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%8C%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%89"><span class="toc-number">1.7.6.4.</span> <span class="toc-text">4.*孩子兄弟表示法（二叉树表示法，二叉链表表示法）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89-5"><span class="toc-number">1.7.6.4.1.</span> <span class="toc-text">1.定义</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.7.6.5.</span> <span class="toc-text">5.*树与二叉树的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89-6"><span class="toc-number">1.7.6.5.1.</span> <span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.6.5.2.</span> <span class="toc-text">2.操作</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%B0%86%E6%A0%91%E8%BD%AC%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.7.6.5.2.1.</span> <span class="toc-text">1.将树转为二叉树</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%B0%86%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E4%B8%BA%E6%A0%91"><span class="toc-number">1.7.6.5.2.2.</span> <span class="toc-text">2.将二叉树转为树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%A3%AE%E6%9E%97%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%A4%9A%E6%A3%B5%E6%A0%91%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.7.6.6.</span> <span class="toc-text">6.*森林和二叉树的转换（二叉树与多棵树之间的关系)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A3%AE%E6%9E%97%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.7.6.6.1.</span> <span class="toc-text">1.森林转化为二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E4%B8%BA%E6%A3%AE%E6%9E%97"><span class="toc-number">1.7.6.6.2.</span> <span class="toc-text">2.二叉树转为森林</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.6.7.</span> <span class="toc-text">7.树与森林的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F-%E5%85%88%E6%A0%B9%EF%BC%88%E6%AC%A1%E5%BA%8F-%EF%BC%8C%E5%90%8E%E6%A0%B9%EF%BC%8C%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.6.7.1.</span> <span class="toc-text">1.树的遍历的三种方式{先根（次序)，后根，层次遍历}</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.6.7.2.</span> <span class="toc-text">2.森林的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.6.7.2.1.</span> <span class="toc-text">1.先序遍历</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.6.7.2.2.</span> <span class="toc-text">2.中序遍历</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E5%B0%8F%E6%A1%88%E4%BE%8B"><span class="toc-number">1.7.6.7.2.3.</span> <span class="toc-text">3.小案例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8"><span class="toc-number">1.7.7.</span> <span class="toc-text">7.*哈夫曼树及其应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.7.1.</span> <span class="toc-text">1.基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.7.2.</span> <span class="toc-text">2.哈夫曼算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.7.2.1.</span> <span class="toc-text">1.构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.7.2.1.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.7.2.2.</span> <span class="toc-text">2.哈夫曼树的算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%89"><span class="toc-number">1.7.7.2.2.1.</span> <span class="toc-text">顺序结构（一维数组）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">1.7.7.3.</span> <span class="toc-text">3.哈夫曼编码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.7.3.1.</span> <span class="toc-text">1.方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.7.3.1.1.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.7.3.2.</span> <span class="toc-text">2.实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%BC%96%E7%A0%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.7.4.</span> <span class="toc-text">4.编码的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%9B%BE"><span class="toc-number">1.8.</span> <span class="toc-text">八、图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.8.1.</span> <span class="toc-text">1.图的定义和基本术语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">1.图的定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9B%BE%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-number">1.8.2.</span> <span class="toc-text">2.图的类型定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9B%BE%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E5%A6%82%E4%B8%8B"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">1.图的抽象数据类型定义如下:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9B%BE%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">2. 图的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.8.2.3.</span> <span class="toc-text">3.图的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%EF%BC%88%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%EF%BC%89%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">1.8.2.3.1.</span> <span class="toc-text">1.数组（邻接矩阵）表示法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">1.8.2.3.1.1.</span> <span class="toc-text">无向图邻接矩阵</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">1.8.2.3.1.2.</span> <span class="toc-text">有向图的邻接矩阵</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E7%BD%91%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">1.8.2.3.2.</span> <span class="toc-text">有向网的邻接矩阵</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.8.2.4.</span> <span class="toc-text">2.邻接矩阵的存储形式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E5%88%86%E5%88%AB%E5%AD%98%E5%82%A8%E9%A1%B6%E7%82%B9%E8%A1%A8%E5%92%8C%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">1.8.2.4.0.1.</span> <span class="toc-text">1.用两个数组分别存储顶点表和邻接矩阵</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%87%87%E7%94%A8%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA%E6%B3%95%E5%88%9B%E5%BB%BA%E6%97%A0%E5%90%91%E7%BD%91"><span class="toc-number">1.8.2.4.1.</span> <span class="toc-text">2.采用邻接矩阵表示法创建无向网</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">1.8.2.4.1.1.</span> <span class="toc-text">算法思想</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E5%A5%BD%E5%A4%84%E5%92%8C%E5%9D%8F%E5%A4%84"><span class="toc-number">1.8.2.4.2.</span> <span class="toc-text">3.邻接矩阵的好处和坏处</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84"><span class="toc-number">1.8.2.4.2.1.</span> <span class="toc-text">好处</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9D%8F%E5%A4%84"><span class="toc-number">1.8.2.4.2.2.</span> <span class="toc-text">坏处</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88%E9%93%BE%E5%BC%8F%EF%BC%89"><span class="toc-number">1.8.2.5.</span> <span class="toc-text">3.邻接表表示法（链式）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">1.8.2.5.1.</span> <span class="toc-text">1.无向图的邻接表</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-3"><span class="toc-number">1.8.2.5.1.1.</span> <span class="toc-text">特点:</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%9C%89%E5%90%91%E5%9B%BE"><span class="toc-number">1.8.2.5.2.</span> <span class="toc-text">2.有向图</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-4"><span class="toc-number">1.8.2.5.2.1.</span> <span class="toc-text">特点:</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%93%BE%E5%BC%8F%E4%BB%A3%E7%A0%81"><span class="toc-number">1.8.2.5.3.</span> <span class="toc-text">3.链式代码</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E4%BB%A3%E7%A0%81"><span class="toc-number">1.8.2.5.3.1.</span> <span class="toc-text">1.定义代码</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E9%87%87%E7%94%A8%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95%E5%88%9B%E5%BB%BA%E6%97%A0%E5%90%91%E7%BD%91%E7%9A%84%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">1.8.2.5.3.2.</span> <span class="toc-text">2.采用邻接表表示法创建无向网的算法思想</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.8.2.6.</span> <span class="toc-text">5.邻接表的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%89%B9%E7%82%B9"><span class="toc-number">1.8.2.6.1.</span> <span class="toc-text">1.特点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.8.2.7.</span> <span class="toc-text">4.邻接矩阵与邻接表表示方法的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%81%94%E7%B3%BB"><span class="toc-number">1.8.2.7.1.</span> <span class="toc-text">2.联系:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.8.2.7.2.</span> <span class="toc-text">2.区别:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%94%A8%E9%80%94"><span class="toc-number">1.8.2.7.3.</span> <span class="toc-text">3.用途:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="toc-number">1.8.2.8.</span> <span class="toc-text">5.十字链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.8.2.8.1.</span> <span class="toc-text">1.简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%85%B7%E4%BD%93"><span class="toc-number">1.8.2.8.2.</span> <span class="toc-text">2.具体</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8"><span class="toc-number">1.8.2.9.</span> <span class="toc-text">6.邻接多重表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.8.3.</span> <span class="toc-text">4.图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89-7"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88-DFS"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">2.深度优先(DFS)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.8.3.2.1.</span> <span class="toc-text">1.连通图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.3.2.1.1.</span> <span class="toc-text">方法:</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.8.3.2.1.2.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90"><span class="toc-number">1.8.3.2.1.3.</span> <span class="toc-text">效率分析</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">1.8.3.2.1.4.</span> <span class="toc-text">结论:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">1.8.3.3.</span> <span class="toc-text">2.广度优先遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%96%B9%E6%B3%95-1"><span class="toc-number">1.8.3.3.1.</span> <span class="toc-text">1.方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.8.3.3.2.</span> <span class="toc-text">2.实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90"><span class="toc-number">1.8.3.3.3.</span> <span class="toc-text">3.效率分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83"><span class="toc-number">1.8.3.3.4.</span> <span class="toc-text">4.效率比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.8.4.</span> <span class="toc-text">5.图的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">1.最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-number">1.8.4.1.1.</span> <span class="toc-text">1.生成树的简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.8.4.1.2.</span> <span class="toc-text">2.无向图的生成树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.8.4.1.3.</span> <span class="toc-text">3.最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.8.4.1.3.1.</span> <span class="toc-text">构造最小生成树</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Prim-%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.8.4.1.3.2.</span> <span class="toc-text">Prim-普里姆算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Kruskal-%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95"><span class="toc-number">1.8.4.1.3.3.</span> <span class="toc-text">Kruskal-克鲁斯卡尔算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%AF%94%E8%BE%83"><span class="toc-number">1.8.4.1.3.4.</span> <span class="toc-text">两种比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">1.8.4.2.</span> <span class="toc-text">2.最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89-8"><span class="toc-number">1.8.4.2.1.</span> <span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Dijkstra%E7%AE%97%E6%B3%95"><span class="toc-number">1.8.4.2.2.</span> <span class="toc-text">2.Dijkstra算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.8.4.2.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B7%E4%BD%93-%E6%8C%89%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%E9%80%92%E5%A2%9E%E6%AC%A1%E5%BA%8F%E4%BA%A7%E7%94%9F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">1.8.4.2.2.2.</span> <span class="toc-text">具体-按路径长度递增次序产生最短路径</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Floyd-%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95"><span class="toc-number">1.8.4.2.3.</span> <span class="toc-text">3.Floyd 弗洛伊德算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-1"><span class="toc-number">1.8.4.2.3.1.</span> <span class="toc-text">算法思想</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.4.3.</span> <span class="toc-text">3.拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-AOV%E7%BD%91"><span class="toc-number">1.8.4.3.1.</span> <span class="toc-text">1.AOV网</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">1.8.4.3.1.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-5"><span class="toc-number">1.8.4.3.1.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A3%80%E6%B5%8BAOV-%E7%BD%91%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E7%8E%AF%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.4.3.1.3.</span> <span class="toc-text">检测AOV 网中是否存在环方法:</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-AOE%E7%BD%91"><span class="toc-number">1.8.4.3.2.</span> <span class="toc-text">2.AOE网</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-1"><span class="toc-number">1.8.4.3.3.</span> <span class="toc-text">3.拓扑排序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">1.8.4.4.</span> <span class="toc-text">4.关键路径</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A8%E8%AE%BA"><span class="toc-number">1.8.4.4.1.</span> <span class="toc-text">讨论</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/11096/" title="Redis黑马版"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2024/12/24/676a8d8bc7d9f.png?_r_=b766501c-375f-d622-6ca5-bfbc65ab58d7" onerror='this.onerror=null,this.src="https://bu.dusays.com/2025/05/30/68398ca86a127.gif"' alt="Redis黑马版"></a><div class="content"><a class="title" href="/posts/11096/" title="Redis黑马版">Redis黑马版</a><time datetime="2025-09-08T02:34:21.000Z" title="发表于 2025-09-08 10:34:21">2025-09-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/45509/" title="java面试黑马版"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2024/12/24/676a8d8bc7d9f.png?_r_=5e1e8eaa-d06e-99e8-9cb5-857ffc74fb88" onerror='this.onerror=null,this.src="https://bu.dusays.com/2025/05/30/68398ca86a127.gif"' alt="java面试黑马版"></a><div class="content"><a class="title" href="/posts/45509/" title="java面试黑马版">java面试黑马版</a><time datetime="2025-09-07T02:34:21.000Z" title="发表于 2025-09-07 10:34:21">2025-09-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3860/" title="黑马学成在线"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2024/11/24/674340e0cd15e.png?_r_=456351c6-24ef-054b-2585-a57c1677c6ef" onerror='this.onerror=null,this.src="https://bu.dusays.com/2025/05/30/68398ca86a127.gif"' alt="黑马学成在线"></a><div class="content"><a class="title" href="/posts/3860/" title="黑马学成在线">黑马学成在线</a><time datetime="2025-08-04T02:34:21.000Z" title="发表于 2025-08-04 10:34:21">2025-08-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/42622/" title="SpringCloud"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2024/11/24/674340e0cd15e.png?_r_=320ac6a6-3bf5-9cc8-180a-c9c4b73ea680" onerror='this.onerror=null,this.src="https://bu.dusays.com/2025/05/30/68398ca86a127.gif"' alt="SpringCloud"></a><div class="content"><a class="title" href="/posts/42622/" title="SpringCloud">SpringCloud</a><time datetime="2025-07-13T00:34:21.000Z" title="发表于 2025-07-13 08:34:21">2025-07-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/49515/" title="前端学习（tlias为例）"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/05/30/68398ca86a127.gif&quot;" data-lazy-src="https://bu.dusays.com/2024/11/24/674340e151d6a.png?_r_=90fa1921-0a69-b602-3178-9ee5211c46f1" onerror='this.onerror=null,this.src="https://bu.dusays.com/2025/05/30/68398ca86a127.gif"' alt="前端学习（tlias为例）"></a><div class="content"><a class="title" href="/posts/49515/" title="前端学习（tlias为例）">前端学习（tlias为例）</a><time datetime="2025-05-25T03:34:21.000Z" title="发表于 2025-05-25 11:34:21">2025-05-25</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By 李阳</div><div class="footer_custom_text">下次再见！</div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">5</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size:.9em"></i> <span>隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size:.9em"></i> <span>分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size:.9em"></i> <span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/charts/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tongji1"></use></svg> <span>统计</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=12781955100&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size:.9em"></i> <span>耳机分你一半</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size:.9em"></i> <span>留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/todolist/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zuji"></use></svg> <span>脚步</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/essay/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-taiyang"></use></svg> <span>小太阳</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-a-xiaoyangyang_huaban1"></use></svg> <span>了解我</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/408/" style="font-size:.88rem">408<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size:.88rem">C语言<sup>1</sup></a><a href="/tags/java/" style="font-size:.88rem;font-weight:500;color:var(--anzhiyu-lighttext)">java<sup>1</sup></a><a href="/tags/javaweb/" style="font-size:.88rem">javaweb<sup>9</sup></a><a href="/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/" style="font-size:.88rem">力扣刷题<sup>1</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size:.88rem">操作系统<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size:.88rem">数据结构<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size:.88rem">计算机组成原理<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size:.88rem">计算机网络<sup>2</sup></a><a href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" style="font-size:.88rem">软件工程<sup>1</sup></a></div></div><hr></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="anzhiyu.scrollToDest(document.body.scrollHeight,500)"><i class="anzhiyufont anzhiyu-icon-arrow-down"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="12781955100" server="netease" type="playlist" mutex="true" preload="none" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size:1rem"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/playlist?id=12781955100&quot;, &quot;_blank&quot;);" style="display:none"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>var HoldLog=console.log;console.log=function(){};let now1=new Date;queueMicrotask((()=>{const o=function(){HoldLog.apply(console,arguments)},n=new Date("04/01/2021 00:00:00");now1.setTime(now1.getTime()+250);const c=(now1-n)/1e3/60/60/24,e=["欢迎使用安知鱼!","生活明朗, 万物可爱","\n        \n       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗\n      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║\n      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║\n      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║\n      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝\n      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝\n        \n        ","已上线",Math.floor(c),"天","©2024 By 安知鱼 V1.6.14"],t=["NCC2-036","调用前置摄像头拍照成功，识别为【小笨蛋】.","Photo captured: ","🤪"];setTimeout(o.bind(console,`\n%c${e[0]} %c ${e[1]} %c ${e[2]} %c${e[3]}%c ${e[4]}%c ${e[5]}\n\n%c ${e[6]}\n`,"color:#425AEF","","color:#425AEF","color:#425AEF","","color:#425AEF","")),setTimeout(o.bind(console,`%c ${t[0]} %c ${t[1]} %c \n${t[2]} %c\n${t[3]}\n`,"color:white; background-color:#4fd953","","",'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%')),setTimeout(o.bind(console,"%c WELCOME %c 你好，小笨蛋.","color:white; background-color:#4f90d9","")),setTimeout(console.warn.bind(console,"%c ⚡ Powered by 安知鱼 %c 你正在访问 李阳 的博客.","color:white; background-color:#f0ad4e","")),setTimeout(o.bind(console,"%c W23-12 %c 你已打开控制台.","color:white; background-color:#4f90d9","")),setTimeout(console.warn.bind(console,"%c S013-782 %c 你现在正处于监控中.","color:white; background-color:#d9534f",""))}))</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" href="https://cdn.cbd.int/katex@0.16.0/dist/katex.min.css"><script src="https://cdn.cbd.int/katex@0.16.0/dist/contrib/copy-tex.min.js"></script><script>document.querySelectorAll("#article-container span.katex-display").forEach((a=>{anzhiyu.wrap(a,"div",{class:"katex-wrap"})}))</script><script>(()=>{const e=document.querySelectorAll("#article-container .mermaid-wrap");if(0===e.length)return;const t=()=>{window.loadMermaid=!0;const t="dark"===document.documentElement.getAttribute("data-theme")?"dark":"default";Array.from(e).forEach(((e,n)=>{const d=e.firstElementChild,r="mermaid-"+n,a="%%{init:{ 'theme':'"+t+"'}}%%\n"+d.textContent,i=mermaid.render(r,a);var m;"string"==typeof i?(m=i,d.insertAdjacentHTML("afterend",m)):i.then((({svg:e})=>{d.insertAdjacentHTML("afterend",e)}))}))},n=()=>{window.loadMermaid?t():getScript("https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js").then(t)};anzhiyu.addGlobalFn("themeChange",t,"mermaid"),window.pjax?n():document.addEventListener("DOMContentLoaded",n)})()</script><script>(()=>{const t=()=>{"object"==typeof twikoo?setTimeout(o,0):getScript("https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js").then(o)},o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo.baskly.fun",region:"",onCommentLoaded:()=>{anzhiyu.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const t=document.getElementById("twikoo-count");t&&twikoo.getCommentsCount({envId:"https://twikoo.baskly.fun",region:"",urls:[window.location.pathname],includeReply:!1}).then((o=>{t.textContent=o[0].count})).catch((t=>{console.error(t)}))})()};t()})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener("load",(()=>{const e=e=>{let t="";if(e.length)for(let n=0;n<e.length;n++){t+="<div class='aside-list-item'>";{const a="data-lazy-src";t+=`<a href='${e[n].url}' class='thumbnail'><img ${a}='${e[n].avatar}' alt='${e[n].nick}'><div class='name'><span>${e[n].nick} </span></div></a>`}t+=`<div class='content'>\n        <a class='comment' href='${e[n].url}' title='${e[n].content}'>${e[n].content}</a>\n        <time datetime="${e[n].date}">${anzhiyu.diffDate(e[n].date,!0)}</time></div>\n        </div>`}else t+="没有评论";let n=document.querySelector("#card-newest-comments .aside-list");n&&(n.innerHTML=t),window.lazyLoadInstance&&window.lazyLoadInstance.update(),window.pjax&&window.pjax.refresh(n)},t=()=>{if(document.querySelector("#card-newest-comments .aside-list")){const t=saveToLocal.get("twikoo-newest-comments");t?e(JSON.parse(t)):(()=>{const t=()=>{twikoo.getRecentComments({envId:"https://twikoo.baskly.fun",region:"",pageSize:6,includeReply:!0}).then((function(t){const n=t.map((e=>{return{content:(t=e.comment,""===t||(t=(t=(t=(t=t.replace(/<img.*?src="(.*?)"?[^\>]+>/gi,"[图片]")).replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi,"[链接]")).replace(/<pre><code>.*?<\/pre>/gi,"[代码]")).replace(/<[^>]+>/g,"")).length>150&&(t=t.substring(0,150)+"..."),t),avatar:e.avatar,nick:e.nick,url:e.url+"#"+e.id,date:new Date(e.created).toISOString()};var t}));saveToLocal.set("twikoo-newest-comments",JSON.stringify(n),10/1440),e(n)})).catch((function(e){document.querySelector("#card-newest-comments .aside-list").textContent="无法获取评论，请确认相关配置是否正确"}))};"object"==typeof twikoo?t():getScript("https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js").then(t)})()}};t(),document.addEventListener("pjax:complete",t)}))</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail="yang@li.com"</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script async src="//at.alicdn.com/t/c/font_4782341_g014uvnbwk6.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/echarts/4.9.0-rc.1/echarts.min.js"></script><script src="https://lib.baomitu.com/echarts/4.9.0-rc.1/echarts.min.js"></script><script src="https://jsd-proxy.ygxz.in/gh/lyay23/blogstatic@v1.0.0/static/imgloaded.min.js"></script><script src="https://jsd-proxy.ygxz.in/gh/lyay23/blogstatic@v1.0.0/static/countdown.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors=['meta[property="og:image"]','meta[property="og:title"]','meta[property="og:url"]','meta[property="og:type"]','meta[property="og:site_name"]','meta[property="og:description"]',"head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"]):not([href="/music/"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(anzhiyu.removeGlobalFnEvent("pjax"),anzhiyu.removeGlobalFnEvent("themeChange"),document.getElementById("rightside").classList.remove("rightside-show"),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>